include "polyglot/ext/jl7/parse/jl7.ppg"

package bolt.parse;

import bolt.ast.BoltNodeFactory;
import bolt.ast.Label;
import bolt.ast.LabelComponent;
import bolt.ast.Policy;
import bolt.ast.Principal;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
  public final BoltNodeFactory nf;

  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
    super(l, t, n, q);
    this.nf = (BoltNodeFactory) n;
  }
:};

terminal Token ATOMIC;
terminal Token JAVA;
terminal Token LABEL;
terminal Token PRINCIPAL;

terminal Token TOP;
terminal Token BOTTOM;
terminal Token LEFTARROW;
terminal Token RIGHTARROW;
terminal Token JOIN;
terminal Token MEET;
terminal Token ACTSFOR;
terminal Token EQUIV;
terminal Token INFO_LTEQ;
terminal Token TRUST_GTEQ;

non terminal Label label;
non terminal List<LabelComponent> label_join_component_list;
non terminal List<LabelComponent> label_meet_component_list;
non terminal LabelComponent label_component;
non terminal Policy label_component_policy;

non terminal Principal principal_opt;
non terminal Principal principal;
non terminal List<Principal> principal_disjunctive_list;
non terminal List<Principal> principal_conjunctive_list;
non terminal Principal principal_base;
non terminal Token leftarrow, rightarrow;
non terminal Expr access_path;
non terminal Expr primary_access_path;
non terminal Expr location_expr;

non terminal ConstructorCall explicit_super_constructor_invocation;

start with goal;

/************************************
 * Labels
 ************************************/

// Labels
label ::=
    // Label
    LBRACE:x RBRACE:y {:
      RESULT = parser.nf.emptyLabel(pos(x, y));
    :}
  | LBRACE:x label_join_component_list:a RBRACE:y {:
      RESULT = parser.nf.JoinLabel(pos(x, y), a);
    :}
  ;

// List of label components to be joined together.
label_join_component_list ::=
    // List<LabelComponent>
    label_meet_component_list:a {:
      RESULT = new ArrayList<>();
      RESULT.add(parser.nf.MeetLabel(pos(a), a));
    :}
  | label_join_component_list:a JOIN label_meet_component_list:b {:
      a.add(parser.nf.MeetLabel(pos(b), b));
      RESULT = a;
    :}
  | label_join_component_list:a SEMICOLON label_meet_component_list:b {:
      a.add(parser.nf.MeetLabel(pos(b), b));
      RESULT = a;
    :}
  ;

// List of label components to be meeted together.
label_meet_component_list ::=
    // List<LabelComponent>
    label_component:a {:
      RESULT = new ArrayList<>();
      RESULT.add(a);
    :}
  | label_meet_component_list:a MEET label_component:b {:
      a.add(b);
      RESULT = a;
    :}
  ;

label_component ::=
    // LabelComponent
    label_component_policy:a {:
      RESULT = a;
    :}
  | access_path:a {:
      RESULT = parser.nf.ExprLabel(pos(a), a);
    :}
  | label:a {:
      RESULT = a;
    :}
  | LBRACK:x expression:a RBRACK:y {:
      RESULT = parser.nf.ExprLabel(pos(x, y), a);
    :}
  ;

leftarrow ::=
    LEFTARROW
  | LT MINUS
  ;

rightarrow ::=
    RIGHTARROW
  | MINUS GT
  ;

label_component_policy ::=
    // Policy
    principal:a rightarrow principal_opt:b {:
      if (b == null) b = parser.nf.BottomPrincipal(pos(b));
      RESULT = parser.nf.ReaderPolicy(pos(a, b), a, b);
    :}
  | principal:a leftarrow principal_opt:b {:
      if (b == null) b = parser.nf.BottomPrincipal(pos(b));
      RESULT = parser.nf.WriterPolicy(pos(a, b), a, b);
    :}
  ;

principal_opt ::=
    // Principal
  | principal:a {:
      RESULT = a;
    :}
  ;

/************************************
 * Principals
 ************************************/

// Principals.
principal ::=
    // Principal
    principal_disjunctive_list:a {:
      if (a.size() == 1) {
        RESULT = a.get(0);
      } else {
        RESULT = parser.nf.DisjunctivePrincipal(pos(a), a);
      }
    :}
  ;

// Disjunctive principals.
principal_disjunctive_list ::=
    // List<Principal>
    principal_conjunctive_list:a {:
      if (a.size() == 1) {
        RESULT = a;
      } else {
        RESULT = new ArrayList<>();
        RESULT.add(parser.nf.ConjunctivePrincipal(pos(a), a));
      }
    :}
  | principal_disjunctive_list:a OR principal_conjunctive_list:b {:
      RESULT = a;
      if (b.size() == 1) {
        a.addAll(b);
      } else {
        a.add(parser.nf.ConjunctivePrincipal(pos(b), b));
      }
    :}
  ;

// Conjunctive principals.
principal_conjunctive_list ::=
    // List<Principal>
    principal_base:a {:
      RESULT = new ArrayList<>();
      RESULT.add(a);
    :}
  | principal_conjunctive_list:a AND principal_base:b {:
      RESULT = a;
      RESULT.add(b);
    :}
  ;

// Base principals.
principal_base ::=
    // Principal
    MULT:a {:
      // Top principal.
      RESULT = parser.nf.TopPrincipal(pos(a));
    :}
  | TOP:a {:
      // Top principal.
      RESULT = parser.nf.TopPrincipal(pos(a));
    :}
  | BOTTOM:a {:
      // Bottom principal.
      RESULT = parser.nf.BottomPrincipal(pos(a));
    :}
  | LBRACK:x expression:a RBRACK:y {:
      RESULT = parser.nf.ExprPrincipal(pos(a), a);
    :}
  | LPAREN principal:a RPAREN {:
      RESULT = a;
    :}
  | access_path:a {:
      RESULT = parser.nf.ExprPrincipal(pos(a), a);
    :}
  ;

// Dotted sequence of identifiers/'this'/'super'.
access_path ::=
    // Expr
    primary_access_path:a {:
      RESULT = a;
    :}
  | name:a {:
      RESULT = a.toExpr();
    :}
  ;

primary_access_path ::=
    // Expr
    THIS:a {:
      RESULT = parser.nf.This(pos(a));
    :}
  | primary_access_path:a DOT IDENTIFIER:b {:
      RESULT = parser.nf.Field(pos(a, b, b), a,
          parser.nf.Id(pos(b), b.getIdentifier()));
    :}
  | SUPER:n DOT IDENTIFIER:a {:
      RESULT = parser.nf.Field(pos(a),
          parser.nf.Super(pos(n)),
          parser.nf.Id(pos(a), a.getIdentifier()));
    :}
  | name:a DOT SUPER:n DOT IDENTIFIER:b {:
      RESULT = parser.nf.Field(pos(b),
          parser.nf.Super(pos(n), a.toType()),
          parser.nf.Id(pos(b), b.getIdentifier()));
    :}
  | name:a DOT THIS:n {:
      RESULT = parser.nf.This(pos(a, n, n), a.toType());
    :}
  ;

/************************************
 * Field declarations
 ************************************/

// Field declarations can have labels.
extend field_declaration ::=
    modifiers_or_annotations_opt:a type:b label:c variable_declarators:d
    SEMICOLON:e {:
      List<ClassMember> l = new LinkedList<>();
      for (VarDeclarator decl : d) {
        l.add(parser.nf.FieldDecl(pos(b, e), a.flags(), a.annotations(),
            parser.array(b, decl.dims), c, decl.name, decl.init,
            parser.javadoc(a.position(), pos(b))));
      }
      RESULT = l;
    :}
  ;

/************************************
 * Label/principal construction
 ************************************/

// Expressions for constructing labels and principals.
extend primary ::=
    NEW:n LABEL label:a {:
      RESULT = parser.nf.NewLabel(pos(n, a), a);
    :}
  | NEW:n location_expr:a LABEL label:b {:
      RESULT = parser.nf.NewLabel(pos(n, b, b), a, b);
    :}
  | NEW:n PRINCIPAL LPAREN principal:a RPAREN {:
      RESULT = parser.nf.NewPrincipal(pos(n, a), a);
    :}
  | NEW:n location_expr:a PRINCIPAL LPAREN principal:b RPAREN:z {:
      RESULT = parser.nf.NewPrincipal(pos(n, z, b), a, b);
    :}
  ;

location_expr ::=
    // Expr
    AT access_path:a {:
      RESULT = a;
    :}
  | AT LPAREN expression:a RPAREN {:
      RESULT = a;
    :}
  ;

/************************************
 * Constructor calls
 ************************************/

// Constructor calls can have location annotations.
extend class_instance_creation_expression ::=
    NEW:n location_expr:a class_or_interface_type:b LPAREN argument_list_opt:c
    RPAREN class_body_opt:d {:
      // ONE
      RESULT = parser.nf.New(pos(n), null, a, null, b, c, d);
    :}
  | NEW:n location_expr:a type_arguments:b class_or_interface_type:c LPAREN
    argument_list_opt:d RPAREN class_body_opt:e {:
      // Instantiating type arguments
      // TWO
      RESULT = parser.nf.New(pos(n), null, a, b, c, d, e);
    :}
  | primary:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d LPAREN
    argument_list_opt:e RPAREN class_body_opt:f {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(d),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      // THREE
      RESULT = parser.nf.New(pos(a), a, b, c, aa, e, f);
    :}
  | name:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d LPAREN
    argument_list_opt:e RPAREN class_body_opt:f {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(d),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      // FOUR
      RESULT = parser.nf.New(pos(a), a.toExpr(), b, c, aa, e, f);
    :}
  | primary:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d
    type_arguments:e LPAREN argument_list_opt:f RPAREN class_body_opt:g {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(d),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      TypeNode tn = parser.nf.AmbTypeInstantiation(pos(d, e), aa, e); 
      // FIVE
      RESULT = parser.nf.New(pos(a), a, b, c, tn, f, g);
    :}
  | name:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d
    type_arguments:e LPAREN argument_list_opt:f RPAREN class_body_opt:g {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(d),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      TypeNode tn = parser.nf.AmbTypeInstantiation(pos(d, e), aa, e);
      // SIX
      RESULT = parser.nf.New(pos(a), a.toExpr(), b, c, tn, f, g);
    :}
  | NEW:n location_expr:b class_or_interface:c LT GT:x LPAREN
    argument_list_opt:d RPAREN class_body_opt:e {:
      TypeNode tn = parser.nf.AmbDiamondTypeNode(pos(c, x), c);
      // SEVEN
      RESULT = parser.nf.New(pos(n), null, b, null, tn, d, e);
    :}
  | NEW:n location_expr:a type_arguments:b class_or_interface:c LT GT:x LPAREN
    argument_list_opt:d RPAREN class_body_opt:e {:
      // Instantiating type arguments
      TypeNode tn = parser.nf.AmbDiamondTypeNode(pos(c, x), c);
      // EIGHT
      RESULT = parser.nf.New(pos(n), null, a, b, tn, d, e);
    :}
  | primary:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d LT GT:x
    LPAREN argument_list_opt:e RPAREN class_body_opt:f {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(b),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      TypeNode tn = parser.nf.AmbDiamondTypeNode(pos(d, x), aa);
      // NINE
      RESULT = parser.nf.New(pos(a), a, b, c, tn, e, f);
    :}
  | name:a DOT NEW location_expr:b type_arguments_opt:c IDENTIFIER:d LT GT:x
    LPAREN argument_list_opt:e RPAREN class_body_opt:f {:
      // Instantiating type arguments
      TypeNode aa =
          new JL5Name(parser.nf, parser.ts, pos(d),
              parser.nf.Id(pos(d), d.getIdentifier())).toType();
      TypeNode tn = parser.nf.AmbDiamondTypeNode(pos(d, x), aa);
      // TEN
      RESULT = parser.nf.New(pos(a), a.toExpr(), b, c, tn, e, f);
    :}
  ;

/************************************
 * Method calls
 ************************************/

// Method invocations can have location annotations.
extend method_invocation ::=
    // Call
    name location_expr LPAREN argument_list_opt RPAREN
  | primary DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | SUPER DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | name DOT SUPER DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | primary DOT type_arguments IDENTIFIER location_expr LPAREN
    argument_list_opt RPAREN
  | name DOT type_arguments IDENTIFIER location_expr LPAREN argument_list_opt
    RPAREN
  | SUPER DOT type_arguments IDENTIFIER location_expr LPAREN argument_list_opt
    RPAREN
  | name DOT SUPER DOT type_arguments IDENTIFIER location_expr LPAREN
    argument_list_opt RPAREN
  ;

/************************************
 * Arrays
 ************************************/

// Native arrays in variable declarations: "int foo native[]".
extend variable_declarator_id ::=
    variable_declarator_id NATIVE LBRACK RBRACK
  ;

// Native array types: "int native[]".
extend dims ::=
    NATIVE LBRACK RBRACK
  ;

// Native array initializers: "int native[5]".
// Fabric array initializers specify a label for the array: "int [5, L]".
override dim_expr ::=
    NATIVE LBRACK expression RBRACK
  | LBRACK expression COMMA expression RBRACK
  ;

// Array creation expressions can have location annotations.
extend array_creation_expression ::=
    // NewArray
    NEW location_expr primitive_type dim_exprs dims_opt
  | NEW location_expr class_or_interface_type dim_exprs dims_opt
  ;

// Array creation expressions with initializers can have location annotations.
extend initialized_array_creation_expression ::=
    NEW location_expr primitive_type dims array_initializer
  | NEW location_expr class_or_interface_type dims array_initializer
  ;

// Array initializers can have location annotations and can have labels.
extend array_initializer ::=
    LBRACE expression COLON variable_initializers COMMA RBRACE
  | location_expr LBRACE variable_initializers COMMA RBRACE
  | location_expr LBRACE expression COLON variable_initializers COMMA RBRACE
  | LBRACE expression COLON variable_initializers RBRACE
  | location_expr LBRACE variable_initializers RBRACE
  | location_expr LBRACE expression COLON variable_initializers RBRACE
  ;

/************************************
 * Atomic blocks
 ************************************/

// Atomic blocks.
extend statement_without_trailing_substatement ::=
    // Stmt
    ATOMIC block
  | ATOMIC THROWS class_type_list block
  ;

/************************************
 * Constructor bodies
 ************************************/

// Constructor bodies can have super() calls in the middle.
extend constructor_body ::=
    LBRACE block_statements explicit_super_constructor_invocation RBRACE
  | LBRACE block_statements explicit_super_constructor_invocation
    block_statements RBRACE
  ;

drop {
  explicit_constructor_invocation ::=
      SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | primary DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | name DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | name DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    ;
}

extend explicit_constructor_invocation ::=
    explicit_super_constructor_invocation
  ;

explicit_super_constructor_invocation ::=
    SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | primary DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | name DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | name DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  ;
