include "polyglot/ext/jl7/parse/jl7.ppg"

package bolt.parse;

import bolt.ast.BoltNodeFactory;
import bolt.ast.Label;
import bolt.ast.LabelComponent;
import bolt.ast.Policy;
import bolt.ast.Principal;

parser Grm extends polyglot.ext.jl7.parse.Grm {:
  public final BoltNodeFactory nf;

  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
    super(l, t, n, q);
    this.nf = (BoltNodeFactory) n;
  }
:};

terminal token ATOMIC;
terminal token JAVA;
terminal token LABEL;
terminal token PRINCIPAL;

terminal token TOP;
terminal token BOTTOM;
terminal token LEFTARROW;
terminal token RIGHTARROW;
terminal token JOIN;
terminal token MEET;
terminal token ACTSFOR;
terminal token EQUIV;
terminal token INFO_LTEQ;
terminal token TRUST_GTEQ;

non terminal Label label;
non terminal List<LabelComponent> label_join_component_list;
non terminal List<LabelComponent> label_meet_component_list;
non terminal LabelComponent label_component;
non terminal Policy label_component_policy;

non terminal Principal principal_opt;
non terminal Principal principal;
non terminal Principal principal_disjunctive;
non terminal Principal principal_conjunctive;
non terminal Principal principal_base;
non terminal Token leftarrow, rightarrow;
non terminal Expr access_path;
non terminal Expr location_expr;

non terminal ConstructorCall explicit_super_constructor_invocation;

start with goal;

/************************************
 * Labels
 ************************************/

// Labels
label ::=
    // Label
    LBRACE:x RBRACE:y {:
      RESULT = parser.nf.emptyLabel(parser.pos(x, y));
    :}
  | LBRACE:x label_join_component_list:a RBRACE:y {:
      RESULT = parser.nf.JoinLabel(parser.pos(x, y), a);
    :}
  ;

// List of label components to be joined together.
label_join_component_list ::=
    // List<LabelComponent>
    label_meet_component_list:a {:
      RESULT = new ArrayList<>();
      RESULT.add(parser.nf.MeetLabel(parser.pos(a), a));
    :}
  | label_join_component_list:a JOIN label_meet_component_list:b {:
      a.add(parser.nf.MeetLabel(parser.pos(b), b));
      RESULT = a;
    :}
  | label_join_component_list:a SEMICOLON label_meet_component_list:b {:
      a.add(parser.nf.MeetLabel(parser.pos(b), b));
      RESULT = a;
    :}
  ;

// List of label components to be meeted together.
label_meet_component_list ::=
    // List<LabelComponent>
    label_component:a {:
      RESULT = new ArrayList<>();
      RESULT.add(a);
    :}
  | label_meet_component_list:a MEET label_component:b {:
      a.add(b);
      RESULT = a;
    :}
  ;

label_component ::=
    // LabelComponent
    label_component_policy:a {:
      RESULT = a;
    :}
  | access_path:a {:
      RESULT = parser.nf.ExprLabel(pos(a), a);
    :}
  | label:a {:
      RESULT = a;
    :}
  | LBRACK:x expression:a RBRACK:y {:
      RESULT = parser.nf.ExprLabel(pos(x, y), a);
    :}
  ;

leftarrow ::=
    LEFTARROW
  | LT MINUS
  ;

rightarrow ::=
    RIGHTARROW
  | MINUS GT
  ;

label_component_policy ::=
    // Policy
    principal:a rightarrow principal_opt:b {:
      if (b == null) b = parser.nf.BottomPrincipal(pos(b));
      RESULT = parser.nf.ReaderPolicy(pos(a, b), a, b);
    :}
  | principal:a leftarrow principal_opt:b {:
      if (b == null) b = parser.nf.BottomPrincipal(pos(b));
      RESULT = parser.nf.WriterPolicy(pos(a, b), a, b);
    :}
  ;

principal_opt ::=
    // Principal
  | principal:a {:
      RESULT = a;
    :}
  ;

/************************************
 * Principals
 ************************************/

// Principals.
principal ::=
    // Principal
    principal_disjunctive
  ;

// Disjunctive principals.
principal_disjunctive ::=
    // Principal
    principal_conjunctive
  | principal_disjunctive OR principal_conjunctive
  ;

// Conjunctive principals.
principal_conjunctive ::=
    // Principal
    principal_base
  | principal_conjunctive AND principal_base
  ;

// Base principals.
principal_base ::=
    // Principal
    MULT // Top principal.
  | TOP // Top principal.
  | BOTTOM // Bottom principal.
  | LBRACK expression RBRACK
  | LPAREN principal RPAREN
  | access_path
  ;

// Dotted sequence of identifiers/'this'es.
access_path ::=
    // Expr
    THIS
  | IDENTIFIER
  | access_path DOT IDENTIFIER
  | access_path DOT THIS
  ;

/************************************
 * Field declarations
 ************************************/

// Field declarations can have labels.
extend field_declaration ::=
    modifiers_or_annotations_opt type label variable_declarators SEMICOLON
  ;

/************************************
 * Label/principal construction
 ************************************/

// Expressions for constructing labels and principals.
extend primary ::=
    NEW LABEL label
  | NEW location_expr LABEL label
  | NEW PRINCIPAL LPAREN principal RPAREN
  | NEW location_expr PRINCIPAL LPAREN principal RPAREN
  ;

location_expr ::=
    // Expr
    AT access_path
  | AT LPAREN expression RPAREN
  ;

/************************************
 * Constructor calls
 ************************************/

// Constructor calls can have location annotations.
extend class_instance_creation_expression ::=
    NEW location_expr class_or_interface_type LPAREN argument_list_opt RPAREN
    class_body_opt
  | NEW location_expr type_arguments class_or_interface_type LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | primary DOT NEW location_expr type_arguments_opt IDENTIFIER LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | name DOT NEW location_expr type_arguments_opt IDENTIFIER LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | primary DOT NEW location_expr type_arguments_opt IDENTIFIER type_arguments
    LPAREN argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | name DOT NEW location_expr type_arguments_opt IDENTIFIER type_arguments
    LPAREN argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | NEW location_expr class_or_interface LT GT LPAREN argument_list_opt RPAREN
    class_body_opt
  | NEW location_expr type_arguments class_or_interface LT GT LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | primary DOT NEW location_expr type_arguments_opt IDENTIFIER LT GT LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  | name DOT NEW location_expr type_arguments_opt IDENTIFIER LT GT LPAREN
    argument_list_opt RPAREN class_body_opt
      // Instantiating type arguments
  ;

/************************************
 * Method calls
 ************************************/

// Method invocations can have location annotations.
extend method_invocation ::=
    // Call
    name location_expr LPAREN argument_list_opt RPAREN
  | primary DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | SUPER DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | name DOT SUPER DOT IDENTIFIER location_expr LPAREN argument_list_opt RPAREN
  | primary DOT type_arguments IDENTIFIER location_expr LPAREN
    argument_list_opt RPAREN
  | name DOT type_arguments IDENTIFIER location_expr LPAREN argument_list_opt
    RPAREN
  | SUPER DOT type_arguments IDENTIFIER location_expr LPAREN argument_list_opt
    RPAREN
  | name DOT SUPER DOT type_arguments IDENTIFIER location_expr LPAREN
    argument_list_opt RPAREN
  ;

/************************************
 * Arrays
 ************************************/

// Native arrays in variable declarations: "int foo native[]".
extend variable_declarator_id ::=
    variable_declarator_id NATIVE LBRACK RBRACK
  ;

// Native array types: "int native[]".
extend dims ::=
    NATIVE LBRACK RBRACK
  ;

// Native array initializers: "int native[5]".
// Fabric array initializers specify a label for the array: "int [5, L]".
override dim_expr ::=
    NATIVE LBRACK expression RBRACK
  | LBRACK expression COMMA expression RBRACK
  ;

// Array creation expressions can have location annotations.
extend array_creation_expression ::=
    // NewArray
    NEW location_expr primitive_type dim_exprs dims_opt
  | NEW location_expr class_or_interface_type dim_exprs dims_opt
  ;

// Array creation expressions with initializers can have location annotations.
extend initialized_array_creation_expression ::=
    NEW location_expr primitive_type dims array_initializer
  | NEW location_expr class_or_interface_type dims array_initializer
  ;

// Array initializers can have location annotations and can have labels.
extend array_initializer ::=
    LBRACE expression COLON variable_initializers COMMA RBRACE
  | location_expr LBRACE variable_initializers COMMA RBRACE
  | location_expr LBRACE expression COLON variable_initializers COMMA RBRACE
  | LBRACE expression COLON variable_initializers RBRACE
  | location_expr LBRACE variable_initializers RBRACE
  | location_expr LBRACE expression COLON variable_initializers RBRACE
  ;

/************************************
 * Atomic blocks
 ************************************/

// Atomic blocks.
extend statement_without_trailing_substatement ::=
    // Stmt
    ATOMIC block
  | ATOMIC THROWS class_type_list block
  ;

/************************************
 * Constructor bodies
 ************************************/

// Constructor bodies can have super() calls in the middle.
extend constructor_body ::=
    LBRACE block_statements explicit_super_constructor_invocation RBRACE
  | LBRACE block_statements explicit_super_constructor_invocation
    block_statements RBRACE
  ;

drop {
  explicit_constructor_invocation ::=
      SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | primary DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | name DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    | name DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
    ;
}

extend explicit_constructor_invocation ::=
    explicit_super_constructor_invocation
  ;

explicit_super_constructor_invocation ::=
    SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | primary DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | name DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  | name DOT type_arguments SUPER LPAREN argument_list_opt RPAREN SEMICOLON
  ;
