// Assumes polyglot.jar is in classpath
include "polyglot/parse/java12.cup"

package fabil.parse;

import fabil.ast.Atomic;
import fabil.ast.FabILNodeFactory;
import polyglot.parse.*;
import fabil.types.FabILTypeSystem;
import fabil.types.FabILFlags;

parser Grm extends polyglot.parse.Grm {:
    public final FabILTypeSystem ts;
    public final FabILNodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (FabILTypeSystem) t;
        nf = (FabILNodeFactory) n;
    }
:};

terminal Token AT;
terminal Token ATOMIC;

terminal Token ACTSFOR;
terminal Token ACTSFOR_LOWER;
terminal Token AUTHORITY;
terminal Token CALLER;
terminal Token COVARIANT;
terminal Token DECLASSIFY;
terminal Token ENDORSE;
terminal Token EQUIV;
terminal Token INVARIANT;
terminal Token JOIN;
terminal Token LABEL;
terminal Token LEFTARROW;
terminal Token MEET;
terminal Token PRINCIPAL;
terminal Token RIGHTARROW;
terminal Token TO;
terminal Token WHERE;

non terminal Atomic atomic_statement;
non terminal Expr   location_expr_opt;

start with goal;


////////////////////////////////////////////////////////////////////////
// Atomic Sections                                                    //
////////////////////////////////////////////////////////////////////////

extend statement_without_trailing_substatement ::=
                    // Stmt
        atomic_statement:a {: RESULT = a; :};

atomic_statement ::=
                    // Atomic
        ATOMIC:n block:a {: RESULT = parser.nf.Atomic(parser.pos(n,a), a.statements()); :};

////////////////////////////////////////////////////////////////////////
// Locations for constructors                                         //
////////////////////////////////////////////////////////////////////////

location_expr_opt ::=
                    // Expr
            {: RESULT = null; :}
    |   AT name:a
            {: RESULT = a.toExpr(); :}
    ;

override class_instance_creation_expression ::=
                    // Expr
        NEW:n class_type:a location_expr_opt:loc LPAREN argument_list_opt:b RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(n, d), a, loc, b); :}
    |   NEW:n class_type:a location_expr_opt:loc LPAREN argument_list_opt:b RPAREN class_body:c
            {: RESULT = parser.nf.New(parser.pos(n, c), a, loc, b, c); :}
    |   primary_no_new_array:a DOT NEW simple_name:b location_expr_opt:loc LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a, b.toType(), loc, c); :}
    |   primary_no_new_array:a DOT NEW simple_name:b location_expr_opt:loc LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a, b.toType(), loc, c, d); :}
    |   name:a DOT NEW simple_name:b location_expr_opt:loc LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(), b.toType(), loc, c); :}
    |   name:a DOT NEW simple_name:b location_expr_opt:loc LPAREN argument_list_opt:c RPAREN class_body:d
            {: RESULT = parser.nf.New(parser.pos(a, d), a.toExpr(), b.toType(), loc, c, d); :}
    ;

override array_creation_expression ::=
                    // NewArray
        NEW:n primitive_type:a dim_exprs:b dims_opt:c location_expr_opt:loc
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, loc, b,
                c.intValue()); :}
    |   NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c location_expr_opt:loc
            {: RESULT = parser.nf.NewArray(parser.pos(n, b), a, loc, b,
                c.intValue()); :}
    |   NEW:n primitive_type:a dims:b location_expr_opt:loc array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, c), a, loc,
                b.intValue(), c); :}
    |   NEW:n class_or_interface_type:a dims:b location_expr_opt:loc array_initializer:c
            {: RESULT = parser.nf.NewArray(parser.pos(n, c), a, loc,
                b.intValue(), c); :}
    ;

//
// In order to prevent ambiguity, we disallow dereferencing (.) a new array:
//   new Foo[]@a.b means new Foo[]@(a.b) rather than (new Foo[]@a).b
// Note that this also disallows new Foo[].length which we could allow
//
// The following updated productions are to enforce this.
//

// class_instance_creation_expression modified above

// field_access
drop {
    field_access ::=
            primary:a DOT IDENTIFIER:b
        ;
}
extend field_access ::=
        primary_no_new_array:a DOT IDENTIFIER:b
            {: RESULT = parser.nf.Field(parser.pos(a, b, b), a,
                parser.nf.Id(parser.pos(b), b.getIdentifier())); :}
    ;

// method_invocation
drop {
    method_invocation ::=
            primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN
        ;
}
extend method_invocation ::=
        primary_no_new_array:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.Call(parser.pos(b,d), a,
                parser.nf.Id(parser.pos(b), b.getIdentifier()), c); :}
    ;

// explicit_constructor_invocation
// TODO: this doesn't seem right.
drop {
    explicit_constructor_invocation ::=
            primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON
        |   primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON
        ;
}
extend explicit_constructor_invocation ::=
        primary_no_new_array:a DOT THIS:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.ThisCall(parser.pos(a, c, n), a, b); :}
    |   primary_no_new_array:a DOT SUPER:n LPAREN argument_list_opt:b RPAREN SEMICOLON:c
            {: RESULT = parser.nf.SuperCall(parser.pos(a, c, n), a, b); :}
    ;

extend modifier ::=
        ATOMIC:a
            {: RESULT = FabILFlags.ATOMIC; :}
    ;
