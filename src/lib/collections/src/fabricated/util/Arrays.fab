/**
 * Copyright (C) 2010-2012 Fabric project group, Cornell University
 *
 * This file is part of Fabric.
 *
 * Fabric is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 * 
 * Fabric is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 */
package fabricated.util;

/**
  * This class contains various static utility methods performing operations on
  * arrays, and a method to provide a List "view" of an array to facilitate
  * using arrays with Collection-based APIs. All methods throw a
  * {@link NullPointerException} if the parameter array is null.
  * <p>
  *
  * Implementations may use their own algorithms, but must obey the general
  * properties; for example, the sort must be stable and n*log(n) complexity.
  * Sun's implementation of sort, and therefore ours, is a tuned quicksort,
  * adapted from Jon L. Bentley and M. Douglas McIlroy's "Engineering a Sort
  * Function", Software-Practice and Experience, Vol. 23(11) P. 1249-1265
  * (November 1993). This algorithm offers n*log(n) performance on many data
  * sets that cause other quicksorts to degrade to quadratic performance.
  *
  * @author Original author unknown
  * @author Bryce McKinlay
  * @author Eric Blake (ebb9@email.byu.edu)
  * @see Comparable
  * @see Comparator
  * @since 1.2
  * @status updated to 1.4
  */
public class Arrays {
   /**
    * This class is non-instantiable.
    */
   private Arrays()
   {
   }
  //binarySearch
  /**
   * Perform a binary search of a byte array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, byte{*lbl}[]{*lbl} a, byte{*lbl} key) throws (NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final byte d = a[mid];
        if (d == key)
          return mid;
        else if (d > key)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop.
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of a char array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, char{*lbl}[]{*lbl} a, char{*lbl} key) throws (NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final char d = a[mid];
        if (d == key)
          return mid;
        else if (d > key)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop.
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of a short array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, short{*lbl}[]{*lbl} a, short{*lbl} key) throws (NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final short d = a[mid];
        if (d == key)
          return mid;
        else if (d > key)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop.
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of an int array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, int{*lbl}[]{*lbl} a, int{*lbl} key) throws (NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final int d = a[mid];
        if (d == key)
          return mid;
        else if (d > key)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop.
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of a long array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, long{*lbl}[]{*lbl} a, long{*lbl} key) throws (NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final long d = a[mid];
        if (d == key)
          return mid;
        else if (d > key)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop.
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of a float array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, float{*lbl}[]{*lbl} a, float{*lbl} key) throws (NullPointerException{*lbl})
  {
    // Must use Float.compare to take into account NaN, +-0.
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final int r = Float.compare(a[mid], key);
        if (r == 0)
          return mid;
        else if (r > 0)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of a double array for a key. The array must be
   * sorted (as by the sort() method) - if it is not, the behaviour of this
   * method is undefined, and may be an infinite loop. If the array contains
   * the key more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, double{*lbl}[]{*lbl} a, double{*lbl} key) throws (NullPointerException{*lbl})
  {
    // Must use Double.compare to take into account NaN, +-0.
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final int r = Double.compare(a[mid], key);
        if (r == 0)
          return mid;
        else if (r > 0)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop
          low = ++mid;
      }
    return -mid - 1;
  }

  /**
   * Perform a binary search of an Object array for a key, using a supplied
   * Comparator. The array must be sorted (as by the sort() method with the
   * same Comparator) - if it is not, the behaviour of this method is
   * undefined, and may be an infinite loop. Further, the key must be
   * comparable with every item in the array. If the array contains the key
   * more than once, any one of them may be found. Note: although the
   * specification allows for an infinite loop if the array is unsorted, it
   * will not happen in this (JCL) implementation.
   *
   * @param a the array to search (must be sorted)
   * @param key the value to search for
   * @param c the comparator by which the array is sorted; or null to
   *        use the elements' natural order
   * @return the index at which the key was found, or -n-1 if it was not
   *         found, where n is the index of the first value higher than key or
   *         a.length if there is no such value.
   * @throws ClassCastException if key could not be compared with one of the
   *         elements of a
   * @throws NullPointerException if a null element is compared with natural
   *         ordering (only possible when c is null)
   */
  public static int{*lbl} binarySearch{*lbl}(label lbl, Object{*lbl}[]{*lbl} a, Object{*lbl} key, Comparator[{*lbl}]{*lbl} c) 
      throws (UnsupportedOperationException{*lbl},ClassCastException{*lbl}, NullPointerException{*lbl})
  {
    int low = 0;
    int hi = a.length - 1;
    int mid = 0;
    while (low <= hi)
      {
        mid = (low + hi) >>> 1;
        final int d = c.compare(key, a[mid]);
        if (d == 0)
          return mid;
        else if (d < 0)
          hi = mid - 1;
        else
          // This gets the insertion point right on the last loop
          low = ++mid;
      }
    return -mid - 1;
  }

//equals
  /**
   * Compare two boolean arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, boolean{*lbl}[]{*lbl} a1, boolean{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;
    
    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two byte arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, byte{*lbl}[]{*lbl} a1, byte{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;

    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two char arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, char{*lbl}[]{*lbl} a1, char{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;
    
    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two short arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, short{*lbl}[]{*lbl} a1, short{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;

    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two int arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, int{*lbl}[]{*lbl} a1, int{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;

    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two long arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, long{*lbl}[]{*lbl} a1, long{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;

    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (a1[i] != a2[i])
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two float arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, float{*lbl}[]{*lbl} a1, float{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;

    // Must use Float.compare to take into account NaN, +-0.
    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (Float.compare(a1[i], a2[i]) != 0)
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two double arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a2 is of the same length
   *         as a1, and for each 0 <= i < a1.length, a1[i] == a2[i]
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, double{*lbl}[]{*lbl} a1, double{*lbl}[]{*lbl} a2)
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;
    
    // Must use Double.compare to take into account NaN, +-0.
    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (Double.compare(a1[i], a2[i]) != 0)
            return false;
        return true;
      }
    return false;
  }

  /**
   * Compare two Object arrays for equality.
   *
   * @param a1 the first array to compare
   * @param a2 the second array to compare
   * @return true if a1 and a2 are both null, or if a1 is of the same length
   *         as a2, and for each 0 <= i < a.length, a1[i] == null ?
   *         a2[i] == null : a1[i].equals(a2[i]).
   */
  public static boolean{*lbl} equals{*lbl}(label lbl, Object{*lbl}[]{*lbl} a1, Object{*lbl}[]{*lbl} a2, Comparator[{*lbl}]{*lbl} c) 
      throws (UnsupportedOperationException{*lbl},ClassCastException{*lbl}, NullPointerException{*lbl})
  {
    // Quick test which saves comparing elements of the same array, and also
    // catches the case that both are null.
    if (a1 == a2)
      return true;

    if (null == a1 || null == a2)
      return false;
    
    // If they're the same length, test each element
    if (a1.length == a2.length)
      {
        int i = a1.length;
        while (--i >= 0)
          if (!c.equals(a1[i], a2[i]))
            return false;
        return true;
      }
    return false;
  }
 
  //fill
  /**
   * Fill an array with a boolean value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, boolean{*lbl}[]{*lbl} a, boolean{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a boolean value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, boolean{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, boolean{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a byte value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, byte{*lbl}[]{*lbl} a, byte{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a byte value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, byte{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, byte{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a char value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, char{*lbl}[]{*lbl} a, char{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a char value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, char{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, char{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a short value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, short{*lbl}[]{*lbl} a, short{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a short value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, short{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, short{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with an int value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, int{*lbl}[]{*lbl} a, int{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with an int value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, int{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, int{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a long value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, long{*lbl}[]{*lbl} a, long{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a long value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, long{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, long{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a float value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, float{*lbl}[]{*lbl} a, float{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a float value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, float{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, float{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
  /**
   * Fill an array with a double value.
   *
   * @param a the array to fill
   * @param val the value to fill it with
   */
  public static void fill{*lbl}(label lbl, double{*lbl}[]{*lbl} a, double{*lbl} val)
   throws (NullPointerException{*lbl})
  {
    fill(lbl, a, 0, a.length, val);
  }
  
  /**
   * Fill a range of an array with a double value.
   *
   * @param a the array to fill
   * @param fromIndex the index to fill from, inclusive
   * @param toIndex the index to fill to, exclusive
   * @param val the value to fill with
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void fill{*lbl}(label lbl, double{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, double{*lbl} val) 
   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    for (int i = fromIndex; i < toIndex; i++)
      a[i] = val;
  }
  
//  /**
//   * Fill an array with an Object value.
//   *
//   * @param a the array to fill
//   * @param val the value to fill it with
//   * @throws ClassCastException if val is not an instance of the element
//   *         type of a.
//   */
//  public static void fill{*lbl}(label lbl, Object{*lbl}[]{*lbl} a, Object{*lbl} val)
//   throws (NullPointerException{*lbl})
//  {
//    fill(lbl, a, 0, a.length, val);
//  }
//  
//  /**
//   * Fill a range of an array with an Object value.
//   *
//   * @param a the array to fill
//   * @param fromIndex the index to fill from, inclusive
//   * @param toIndex the index to fill to, exclusive
//   * @param val the value to fill with
//   * @throws ClassCastException if val is not an instance of the element
//   *         type of a.
//   * @throws IllegalArgumentException if fromIndex &gt; toIndex
//   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
//   *         || toIndex &gt; a.length
//   */
//  public static void fill{*lbl}(label lbl, Object{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, Object{*lbl} val) 
//   throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
//  {
//    if (fromIndex > toIndex)
//      throw new IllegalArgumentException();
//    for (int i = fromIndex; i < toIndex; i++)
//      a[i] = val;
//  }
  
  //sort
  // Thanks to Paul Fisher (rao@gnu.org) for finding this quicksort algorithm
  // as specified by Sun and porting it to Java. The algorithm is an optimised
  // quicksort, as described in Jon L. Bentley and M. Douglas McIlroy's
  // "Engineering a Sort Function", Software-Practice and Experience, Vol.
  // 23(11) P. 1249-1265 (November 1993). This algorithm gives n*log(n)
  // performance on many arrays that would take quadratic time with a standard
  // quicksort.
  
  /**
  * Performs a stable sort on the elements, arranging them according to their
  * natural order.
  *
  * @param a the byte array to sort
  */
  public static void sort{*lbl}(label lbl, byte{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
   qsort(lbl, a, 0, a.length);
  }
  
  /**
  * Performs a stable sort on the elements, arranging them according to their
  * natural order.
  *
  * @param a the byte array to sort
  * @param fromIndex the first index to sort (inclusive)
  * @param toIndex the last index to sort (exclusive)
  * @throws IllegalArgumentException if fromIndex &gt; toIndex
  * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
  *         || toIndex &gt; a.length
  */
  public static void sort{*lbl}(label lbl, byte{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)  
     throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
   if (fromIndex > toIndex)
     throw new IllegalArgumentException();
   if (fromIndex < 0)
     throw new ArrayIndexOutOfBoundsException();
   qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }
  
  /**
  * Finds the index of the median of three array elements.
  *
  * @param a the first index
  * @param b the second index
  * @param c the third index
  * @param d the array
  * @return the index (a, b, or c) which has the middle value of the three
  */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, byte{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
   return (d[a] < d[b]
           ? (d[b] < d[c] ? b : d[a] < d[c] ? c : a)
           : (d[b] > d[c] ? b : d[a] > d[c] ? c : a));
  }
  
  /**
  * Swaps the elements at two locations of an array
  *
  * @param i the first index
  * @param j the second index
  * @param a the array
  */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, byte{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
   byte c = a[i];
   a[i] = a[j];
   a[j] = c;
  }
  
  /**
  * Swaps two ranges of an array.
  *
  * @param i the first range start
  * @param j the second range start
  * @param n the element count
  * @param a the array
  */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, byte{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
   int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
     swap(lbl, _i, _j, a);
  }
  
  /**
  * Performs a recursive modified quicksort.
  *
  * @param array the array to sort
  * @param from the start index (inclusive)
  * @param count the number of elements to sort
  */
  private static void qsort{*lbl}(label lbl, byte{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
   // Use an insertion sort on small arrays.
   if (count <= 7)
     {
       for (int i = from + 1; i < from + count; i++)
         for (int j = i; j > from && array[j - 1] > array[j]; j--)
           swap(lbl, j, j - 1, array);
       return;
     }
  
   // Determine a good median element.
   int mid = count / 2;
   int lo = from;
   int hi = from + count - 1;
  
   if (count > 40)
     { // big arrays, pseudomedian of 9
       int s = count / 8;
       lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
       mid = med3(lbl, mid - s, mid, mid + s, array);
       hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
     }
   mid = med3(lbl, lo, mid, hi, array);
  
   int a, b, c, d;
   int comp;
  
   // Pull the median element out of the fray, and use it as a pivot.
   swap(lbl, from, mid, array);
   a = b = from;
   c = d = from + count - 1;
  
   // Repeatedly move b and c to each other, swapping elements so
   // that all elements before index b are less than the pivot, and all
   // elements after index c are greater than the pivot. a and b track
   // the elements equal to the pivot.
   while (true)
     {
       while (b <= c && (comp = array[b] - array[from]) <= 0)
         {
           if (comp == 0)
             {
               swap(lbl, a, b, array);
               a++;
             }
           b++;
         }
       while (c >= b && (comp = array[c] - array[from]) >= 0)
         {
           if (comp == 0)
             {
               swap(lbl, c, d, array);
               d--;
             }
           c--;
         }
       if (b > c)
         break;
       swap(lbl, b, c, array);
       b++;
       c--;
     }
  
   // Swap pivot(s) back in place, the recurse on left and right sections.
   hi = from + count;
   int span;
   span = Math.min(a - from, b - a);
   vecswap(lbl, from, b - span, span, array);
  
   span = Math.min(d - c, hi - d - 1);
   vecswap(lbl, b, hi - span, span, array);
  
   span = b - a;
   if (span > 1)
     qsort(lbl, array, from, span);
  
   span = d - c;
   if (span > 1)
     qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the char array to sort
   */
  public static void sort{*lbl}(label lbl, char{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the char array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, char{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, char{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
    return (d[a] < d[b]
            ? (d[b] < d[c] ? b : d[a] < d[c] ? c : a)
            : (d[b] > d[c] ? b : d[a] > d[c] ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, char{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    char c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, char{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, char{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i; j > from && array[j - 1] > array[j]; j--)
            swap(lbl, j, j - 1, array);
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = array[b] - array[from]) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = array[c] - array[from]) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the short array to sort
   */
  public static void sort{*lbl}(label lbl, short{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the short array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, short{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, short{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
    return (d[a] < d[b]
            ? (d[b] < d[c] ? b : d[a] < d[c] ? c : a)
            : (d[b] > d[c] ? b : d[a] > d[c] ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, short{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    short c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, short{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, short{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i; j > from && array[j - 1] > array[j]; j--)
            swap(lbl, j, j - 1, array);
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = array[b] - array[from]) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = array[c] - array[from]) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the int array to sort
   */
  public static void sort{*lbl}(label lbl, int{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the int array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, int{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, int{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
    return (d[a] < d[b]
            ? (d[b] < d[c] ? b : d[a] < d[c] ? c : a)
            : (d[b] > d[c] ? b : d[a] > d[c] ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, int{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Compares two integers in natural order, since a - b is inadequate.
   *
   * @param a the first int
   * @param b the second int
   * @return &lt; 0, 0, or &gt; 0 accorting to the comparison
   */
  private static int{*lbl} compare{*lbl}(label lbl, int{*lbl} a, int{*lbl} b) throws (NullPointerException{*lbl})
  {
    return a < b ? -1 : a == b ? 0 : 1;
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, int{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i; j > from && array[j - 1] > array[j]; j--)
            swap(lbl, j, j - 1, array);
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = compare(lbl, array[b], array[from])) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = compare(lbl, array[c], array[from])) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the long array to sort
   */
  public static void sort{*lbl}(label lbl, long{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the long array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, long{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, long{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
    return (d[a] < d[b]
            ? (d[b] < d[c] ? b : d[a] < d[c] ? c : a)
            : (d[b] > d[c] ? b : d[a] > d[c] ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, long{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    long c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, long{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Compares two longs in natural order, since a - b is inadequate.
   *
   * @param a the first long
   * @param b the second long
   * @return &lt; 0, 0, or &gt; 0 accorting to the comparison
   */
  private static int{*lbl} compare{*lbl}(label lbl, long{*lbl} a, long{*lbl} b)
  {
    return a < b ? -1 : a == b ? 0 : 1;
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, long{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i; j > from && array[j - 1] > array[j]; j--)
            swap(lbl, j, j - 1, array);
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = compare(lbl, array[b], array[from])) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = compare(lbl, array[c], array[from])) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the float array to sort
   */
  public static void sort{*lbl}(label lbl, float{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the float array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, float{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)  
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, float{*lbl}[]{*lbl} d) throws (NullPointerException{*lbl})
  {
    return (Float.compare(d[a], d[b]) < 0
            ? (Float.compare(d[b], d[c]) < 0 ? b
               : Float.compare(d[a], d[c]) < 0 ? c : a)
            : (Float.compare(d[b], d[c]) > 0 ? b
               : Float.compare(d[a], d[c]) > 0 ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, float{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    float c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, float{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, float{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i;
               j > from && Float.compare(array[j - 1], array[j]) > 0;
               j--)
            {
              swap(lbl, j, j - 1, array);
            }
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = Float.compare(array[b], array[from])) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = Float.compare(array[c], array[from])) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the double array to sort
   */
  public static void sort{*lbl}(label lbl, double{*lbl}[]{*lbl} a)  throws (NullPointerException{*lbl})
  {
    qsort(lbl, a, 0, a.length);
  }

  /**
   * Performs a stable sort on the elements, arranging them according to their
   * natural order.
   *
   * @param a the double array to sort
   * @param fromIndex the first index to sort (inclusive)
   * @param toIndex the last index to sort (exclusive)
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws ArrayIndexOutOfBoundsException if fromIndex &lt; 0
   *         || toIndex &gt; a.length
   */
  public static void sort{*lbl}(label lbl, double{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex)
       throws (NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException();
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();
    qsort(lbl, a, fromIndex, toIndex - fromIndex);
  }

  /**
   * Finds the index of the median of three array elements.
   *
   * @param a the first index
   * @param b the second index
   * @param c the third index
   * @param d the array
   * @return the index (a, b, or c) which has the middle value of the three
   */
  private static int{*lbl} med3{*lbl}(label lbl, int{*lbl} a, int{*lbl} b, int{*lbl} c, double{*lbl}[]{*lbl} d)
  {
    return (Double.compare(d[a], d[b]) < 0
            ? (Double.compare(d[b], d[c]) < 0 ? b
               : Double.compare(d[a], d[c]) < 0 ? c : a)
            : (Double.compare(d[b], d[c]) > 0 ? b
               : Double.compare(d[a], d[c]) > 0 ? c : a));
  }

  /**
   * Swaps the elements at two locations of an array
   *
   * @param i the first index
   * @param j the second index
   * @param a the array
   */
  private static void swap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, double{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    double c = a[i];
    a[i] = a[j];
    a[j] = c;
  }

  /**
   * Swaps two ranges of an array.
   *
   * @param i the first range start
   * @param j the second range start
   * @param n the element count
   * @param a the array
   */
  private static void vecswap{*lbl}(label lbl, int{*lbl} i, int{*lbl} j, int{*lbl} n, double{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
  {
    int _i=i, _j=j, _n=n;
    for ( ; n > 0; _i++, _j++, _n--)
      swap(lbl, _i, _j, a);
  }

  /**
   * Performs a recursive modified quicksort.
   *
   * @param array the array to sort
   * @param from the start index (inclusive)
   * @param count the number of elements to sort
   */
  private static void qsort{*lbl}(label lbl, double{*lbl}[]{*lbl} array, int{*lbl} from, int{*lbl} count) throws (NullPointerException{*lbl})
  {
    // Use an insertion sort on small arrays.
    if (count <= 7)
      {
        for (int i = from + 1; i < from + count; i++)
          for (int j = i;
               j > from && Double.compare(array[j - 1], array[j]) > 0;
               j--)
            {
              swap(lbl, j, j - 1, array);
            }
        return;
      }

    // Determine a good median element.
    int mid = count / 2;
    int lo = from;
    int hi = from + count - 1;

    if (count > 40)
      { // big arrays, pseudomedian of 9
        int s = count / 8;
        lo = med3(lbl, lo, lo + s, lo + 2 * s, array);
        mid = med3(lbl, mid - s, mid, mid + s, array);
        hi = med3(lbl, hi - 2 * s, hi - s, hi, array);
      }
    mid = med3(lbl, lo, mid, hi, array);

    int a, b, c, d;
    int comp;

    // Pull the median element out of the fray, and use it as a pivot.
    swap(lbl, from, mid, array);
    a = b = from;
    c = d = from + count - 1;

    // Repeatedly move b and c to each other, swapping elements so
    // that all elements before index b are less than the pivot, and all
    // elements after index c are greater than the pivot. a and b track
    // the elements equal to the pivot.
    while (true)
      {
        while (b <= c && (comp = Double.compare(array[b], array[from])) <= 0)
          {
            if (comp == 0)
              {
                swap(lbl, a, b, array);
                a++;
              }
            b++;
          }
        while (c >= b && (comp = Double.compare(array[c], array[from])) >= 0)
          {
            if (comp == 0)
              {
                swap(lbl, c, d, array);
                d--;
              }
            c--;
          }
        if (b > c)
          break;
        swap(lbl, b, c, array);
        b++;
        c--;
      }

    // Swap pivot(s) back in place, the recurse on left and right sections.
    hi = from + count;
    int span;
    span = Math.min(a - from, b - a);
    vecswap(lbl, from, b - span, span, array);

    span = Math.min(d - c, hi - d - 1);
    vecswap(lbl, b, hi - span, span, array);

    span = b - a;
    if (span > 1)
      qsort(lbl, array, from, span);

    span = d - c;
    if (span > 1)
      qsort(lbl, array, hi - span, span);
  }

  /**
   * Sort an array of Objects according to their natural ordering. The sort is
   * guaranteed to be stable, that is, equal elements will not be reordered.
   * The sort algorithm is a mergesort with the merge omitted if the last
   * element of one half comes before the first element of the other half. This
   * algorithm gives guaranteed O(n*log(n)) time, at the expense of making a
   * copy of the array.
   *
   * @param a the array to be sorted
   * @throws ClassCastException if any two elements are not mutually
   *         comparable
   * @throws NullPointerException if an element is null (since
   *         null.compareTo cannot work)
   * @see Comparable
   */
  public static void sort{*lbl}(label lbl, Object{*lbl}[]{*lbl} a, Comparator[lbl]{*lbl} c) 
      throws (UnsupportedOperationException{*lbl}, NullPointerException{*lbl})
  {
    sort(lbl, a, 0, a.length, c);
  }

  /**
   * Sort an array of Objects according to a Comparator. The sort is
   * guaranteed to be stable, that is, equal elements will not be reordered.
   * The sort algorithm is a mergesort with the merge omitted if the last
   * element of one half comes before the first element of the other half. This
   * algorithm gives guaranteed O(n*log(n)) time, at the expense of making a
   * copy of the array.
   *
   * @param a the array to be sorted
   * @param fromIndex the index of the first element to be sorted
   * @param toIndex the index of the last element to be sorted plus one
   * @param c a Comparator to use in sorting the array; or null to indicate
   *        the elements' natural order
   * @throws ClassCastException if any two elements are not mutually
   *         comparable by the Comparator provided
   * @throws ArrayIndexOutOfBoundsException if fromIndex and toIndex
   *         are not in range.
   * @throws IllegalArgumentException if fromIndex &gt; toIndex
   * @throws NullPointerException if a null element is compared with natural
   *         ordering (only possible when c is null)
   */
  public static void sort{*lbl}(label lbl, Object{*lbl}[]{*lbl} a, int{*lbl} fromIndex, int{*lbl} toIndex, Comparator[lbl]{*lbl} c)
         throws (UnsupportedOperationException{*lbl}, NullPointerException{*lbl}, IllegalArgumentException{*lbl}, ArrayIndexOutOfBoundsException{*lbl})
  {
    if (fromIndex > toIndex)
      throw new IllegalArgumentException("fromIndex " + fromIndex
                                         + " > toIndex " + toIndex);
    if (fromIndex < 0)
      throw new ArrayIndexOutOfBoundsException();

    int _fromIndex = fromIndex, _toIndex = toIndex;
    // In general, the code attempts to be simple rather than fast, the
    // idea being that a good optimising JIT will be able to optimise it
    // better than I can, and if I try it will make it more confusing for
    // the JIT. First presort the array in chunks of length 6 with insertion
    // sort. A mergesort would give too much overhead for this length.
    for (int chunk = _fromIndex; chunk < _toIndex; chunk += 6)
      {
        int end = Math.min(chunk + 6, _toIndex);
        for (int i = chunk + 1; i < end; i++)
          {
            if (c.compare(a[i - 1], a[i]) > 0)
              {
                // not already sorted
                int j = i;
                Object elem = a[j];
                do
                  {
                    a[j] = a[j - 1];
                    j--;
                  }
                while (j > chunk
                       && c.compare(a[j - 1], elem) > 0);
                a[j] = elem;
              }
          }
      }

    int len = _toIndex - _fromIndex;
    // If length is smaller or equal 6 we are done.
    if (len <= 6)
      return;

    Object{*lbl}[] src = a;
    Object{*lbl}[] dest = new Object[len];
    Object{*lbl}[] t = null; // t is used for swapping src and dest

    // The difference of the _fromIndex of the src and dest array.
    int srcDestDiff = -_fromIndex;

    // The merges are done in this loop
    for (int size = 6; size < len; size <<= 1)
      {
        for (int start = _fromIndex; start < _toIndex; start += size << 1)
          {
            // mid is the start of the second sublist;
            // end the start of the next sublist (or end of array).
            int mid = start + size;
            int end = Math.min(_toIndex, mid + size);

            // The second list is empty or the elements are already in
            // order - no need to merge
            if (mid >= end
                || c.compare(src[mid - 1], src[mid]) <= 0)
              {
                arraycopy(lbl, src, start,
                                 dest, start + srcDestDiff, end - start);

                // The two halves just need swapping - no need to merge
              }
            else if (c.compare(src[start], src[end - 1]) > 0)
              {
                arraycopy(lbl, src, start,
                                 dest, end - size + srcDestDiff, size);
                arraycopy(lbl, src, mid,
                                 dest, start + srcDestDiff, end - mid);

              }
            else
              {
                // Declare a lot of variables to save repeating
                // calculations.  Hopefully a decent JIT will put these
                // in registers and make this fast
                int p1 = start;
                int p2 = mid;
                int i = start + srcDestDiff;

                // The main merge loop; terminates as soon as either
                // half is ended
                while (p1 < mid && p2 < end)
                  {
                    dest[i++] =
                      src[(c.compare(src[p1], src[p2]) <= 0
                           ? p1++ : p2++)];
                  }

                // Finish up by copying the remainder of whichever half
                // wasn't finished.
                if (p1 < mid)
                  arraycopy(lbl, src, p1, dest, i, mid - p1);
                else
                  arraycopy(lbl, src, p2, dest, i, end - p2);
              }
          }
        // swap src and dest ready for the next merge
        t = src;
        src = dest;
        dest = t;
        _fromIndex += srcDestDiff;
        _toIndex += srcDestDiff;
        srcDestDiff = -srcDestDiff;
      }

    // make sure the result ends up back in the right place.  Note
    // that src and dest may have been swapped above, so src
    // contains the sorted array.
    if (src != a)
      {
        // Note that _fromIndex == 0.
        arraycopy(lbl, src, 0, a, srcDestDiff, _toIndex);
      }
  }
  
  /**
  * Copy an array from src to dst. This method is used in place of System.arraycopy since the labels on
  * array elements must be part of the method signature.
  */
  public static void arraycopy{*lbl}(label lbl, byte{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      byte{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    byte{*lbl}[] tmp = new byte[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }

  public static void arraycopy{*lbl}(label lbl, char{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      char{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    char{*lbl}[] tmp = new char[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }

  public static void arraycopy{*lbl}(label lbl, short{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      short{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    short{*lbl}[] tmp = new short[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }

  public static void arraycopy{*lbl}(label lbl, int{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      int{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    int{*lbl}[] tmp = new int[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }
  
  public static void arraycopy{*lbl}(label lbl, long{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      long{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    long{*lbl}[] tmp = new long[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }
  
  public static void arraycopy{*lbl}(label lbl, float{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      float{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    float{*lbl}[] tmp = new float[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }
  
  public static void arraycopy{*lbl}(label lbl, double{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      double{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    double{*lbl}[] tmp = new double[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }
  
  public static void arraycopy{*lbl}(label lbl, Object{*lbl}[]{*lbl} src, int{*lbl} srcPos, 
      Object{*lbl}[]{*lbl} dst, int{*lbl} dstPos, int{*lbl} length) 
          throws (ArrayIndexOutOfBoundsException{*lbl}, NullPointerException{*lbl})
  {
    int _srcPos = srcPos, _dstPos = dstPos;
    Object{*lbl}[] tmp = new Object[length];
    
    if (dst == null || src == null)
      throw new NullPointerException();
    int i=0;
    while (i < length) {
      tmp[i++] = src[_srcPos++];
    }
    i=0;
    while (i < length) {
      src[_dstPos++] = tmp[i++];
    }
  }

  /**
   * Returns a list "view" of the specified array. This method is intended to
   * make it easy to use the Collections API with existing array-based APIs and
   * programs. Changes in the list or the array show up in both places. The
   * list does not support element addition or removal, but does permit
   * value modification. The returned list implements both Serializable and
   * RandomAccess.
   *
   * @param a the array to return a view of (<code>null</code> not permitted)
   * @return a fixed-size list, changes to which "write through" to the array
   * 
   * @throws NullPointerException if <code>a</code> is <code>null</code>.
   * @see Serializable
   * @see RandomAccess
   * @see Arrays.ArrayList
   */
//  public static List[lbl]{*lbl} asList{*lbl}(label lbl, Object{*lbl}[]{*lbl} a) throws (NullPointerException{*lbl})
//  {
//    return new ArraysArrayList(a);
//  }
//
}