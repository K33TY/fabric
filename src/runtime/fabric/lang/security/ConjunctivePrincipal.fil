package fabric.lang.security;

import fabric.lang.security.Principal;
import fabric.worker.Worker;
import fabric.worker.Store;
import fabric.util.*;
import fabric.lang.JifObject;
import fabric.lang.JifObjectWrapper;
import fabric.util.JifUtil;

/**
 * A conjunction of two or more (non-null) principals. This code is mostly
 * copied from Jif.
 */
public final class ConjunctivePrincipal extends Principal {
  final Set conjuncts;
  private Integer hashCode;
  public static final Store localStore = Worker.getWorker().getLocalStore();

  ConjunctivePrincipal(Set conjuncts) {
    this.conjuncts = conjuncts;
  }

  public String name() {
    StringBuffer sb = new StringBuffer@localStore();
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) JifUtil.unwrap(iter.next());
      sb.append(PrincipalUtil.toString(p));
      if (iter.hasNext()) sb.append("&");
    }
    return sb.toString();
  }

  public boolean delegatesTo(Principal p) {
    if (p instanceof ConjunctivePrincipal) {
      ConjunctivePrincipal cp = (ConjunctivePrincipal) p;
      return cp.conjuncts.containsAll(this.conjuncts);
    }
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal q = (Principal) JifUtil.unwrap(iter.next());
      if (!PrincipalUtil.delegatesTo(q, p)) return false;
    }
    // every conjuct delegates to p.
    return true;
  }

  public int hashCode() {
    if (hashCode == null) {
      hashCode = new Integer(conjuncts.hashCode());
    }
    return hashCode.intValue();
  }

  public boolean equals(Principal p) {
    if (p instanceof ConjunctivePrincipal) {
      ConjunctivePrincipal that = (ConjunctivePrincipal) p;
      return this.hashCode() == that.hashCode()
          && this.conjuncts.equals(that.conjuncts)
          && that.conjuncts.equals(this.conjuncts);
    }
    return false;
  }

  public boolean isAuthorized(java.lang.Object authPrf, Closure closure, Label lb,
      boolean executeNow) {
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) JifUtil.unwrap(iter.next());
      if (!p.isAuthorized(authPrf, closure, lb, executeNow)) return false;
    }
    // all conjuncts authorize the closure.
    return true;
  }

  public ActsForProof findProofUpto(Store store, Principal p, java.lang.Object searchState) {
	Label lbl = get$label();
	Map proofs = new HashMap@store(lbl,lbl);
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal q = (Principal) JifUtil.unwrap(iter.next());
      ActsForProof prf = PrincipalUtil.findActsForProof(store, p, q, searchState);
      if (prf == null) return null;

      JifObject _q = (new JifObjectWrapper(q.get$label()))
      	.fabric$lang$JifObjectWrapper$(q);
      JifObject _prf = (new JifObjectWrapper(prf.get$label()))
    	.fabric$lang$JifObjectWrapper$(prf);
      proofs.put(_q, _prf);
    }

    // proofs contains a proof for every conjunct,
    // which is sufficent for a proof to the conjunctive principal
    return new ToConjunctProof@store(p, this, proofs);

  }

  public ActsForProof findProofDownto(Store store, Principal q, java.lang.Object searchState) {
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal witness = (Principal) JifUtil.unwrap(iter.next());
      ActsForProof prf =
          PrincipalUtil.findActsForProof(store, witness, q, searchState);
      if (prf != null) {
        // have found a proof from witness to q
        DelegatesProof step = new DelegatesProof@store(this, witness);
        return new TransitiveProof@store(step, witness, prf);
      }
    }
    return null;
  }
}
