/**
 * Copyright (C) 2010 Fabric project group, Cornell University
 *
 * This file is part of Fabric.
 *
 * Fabric is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 * 
 * Fabric is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 */
package fabric.lang.security;

import fabric.worker.Worker;
import fabric.worker.Store;
import fabric.util.*;

/**
 * A conjunction of two or more (non-null) principals. This code is mostly
 * copied from Jif.
 */
public final class ConjunctivePrincipal extends Principal {
  final Set conjuncts;
  private Integer hashCode;
  public static final Store localStore = Worker.getWorker().getLocalStore();

  ConjunctivePrincipal(Set conjuncts) {
    this.conjuncts = conjuncts;
  }

  public String name() {
    StringBuffer sb = new StringBuffer@localStore();
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) iter.next();
      sb.append(PrincipalUtil.toString(p));
      if (iter.hasNext()) sb.append("&");
    }
    return sb.toString();
  }

  public boolean delegatesTo(Principal p) {
    if (p instanceof ConjunctivePrincipal) {
      ConjunctivePrincipal cp = (ConjunctivePrincipal) p;
      return cp.conjuncts.containsAll(this.conjuncts);
    }
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal q = (Principal) iter.next();
      if (!PrincipalUtil.delegatesTo(q, p)) return false;
    }
    // every conjuct delegates to p.
    return true;
  }

  public int hashCode() {
    if (hashCode == null) {
      hashCode = new Integer(conjuncts.hashCode());
    }
    return hashCode.intValue();
  }

  public boolean equals(Principal p) {
    if (p instanceof ConjunctivePrincipal) {
      ConjunctivePrincipal that = (ConjunctivePrincipal) p;
      return this.hashCode() == that.hashCode()
          && this.conjuncts.equals(that.conjuncts)
          && that.conjuncts.equals(this.conjuncts);
    }
    return false;
  }

  public boolean isAuthorized(java.lang.Object authPrf, Closure closure, Label lb,
      boolean executeNow) {
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) iter.next();
      if (!p.isAuthorized(authPrf, closure, lb, executeNow)) return false;
    }
    // all conjuncts authorize the closure.
    return true;
  }

  public ActsForProof findProofUpto(Store store, Principal p, java.lang.Object searchState) {
    Map proofs = new HashMap@store();
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal q = (Principal) iter.next();
      ActsForProof prf = PrincipalUtil.findActsForProof(store, p, q, searchState);
      if (prf == null) return null;
      proofs.put(q, prf);
    }

    // proofs contains a proof for every conjunct,
    // which is sufficent for a proof to the conjunctive principal
    return new ToConjunctProof@store(p, this, proofs);

  }

  public ActsForProof findProofDownto(Store store, Principal q, java.lang.Object searchState) {
    for (Iterator iter = conjuncts.iterator(); iter.hasNext();) {
      Principal witness = (Principal) iter.next();
      ActsForProof prf =
          PrincipalUtil.findActsForProof(store, witness, q, searchState);
      if (prf != null) {
        // have found a proof from witness to q
        DelegatesProof step = new DelegatesProof@store(this, witness);
        return new TransitiveProof@store(step, witness, prf);
      }
    }
    return null;
  }
}
