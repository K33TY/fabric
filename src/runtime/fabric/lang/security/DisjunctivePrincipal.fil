package fabric.lang.security;

import fabric.worker.Worker;
import fabric.worker.Store;
import fabric.util.*;
import fabric.lang.JifObject;
import fabric.lang.JifObjectWrapper;
import fabric.util.JifUtil;

/**
 * A disjunction of two (non-null) principals. This code is mostly copied from
 * Jif.
 */
public final class DisjunctivePrincipal extends Principal {
  final Set disjuncts;
  private Integer hashCode = null;
  public static final Store localStore = Worker.getWorker().getLocalStore();

  DisjunctivePrincipal(Set disjuncts) {
    this.disjuncts = disjuncts;
  }

  public String name() {
    StringBuffer sb = new StringBuffer@localStore();
    for (Iterator iter = disjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) JifUtil.unwrap(iter.next());
      sb.append(PrincipalUtil.toString(p));
      if (iter.hasNext()) sb.append(",");
    }
    return sb.toString();
  }

  public boolean delegatesTo(Principal p) {
    if (p instanceof DisjunctivePrincipal) {
      DisjunctivePrincipal dp = (DisjunctivePrincipal) p;
      return this.disjuncts.containsAll(dp.disjuncts);
    }
    for (Iterator iter = disjuncts.iterator(); iter.hasNext();) {
      Principal q = (Principal) JifUtil.unwrap(iter.next());
      if (PrincipalUtil.equals(q, p)) return true;
    }
    return false;
  }

  public int hashCode() {
    if (hashCode == null) {
      hashCode = new Integer(disjuncts.hashCode());
    }
    return hashCode.intValue();
  }

  public boolean equals(Principal p) {
    if (p instanceof DisjunctivePrincipal) {
      DisjunctivePrincipal that = (DisjunctivePrincipal) p;
      return this.hashCode() == that.hashCode()
          && this.disjuncts.equals(that.disjuncts)
          && that.disjuncts.equals(this.disjuncts);
    }
    return false;
  }

  public boolean isAuthorized(java.lang.Object authPrf, Closure closure, Label lb,
      boolean executeNow) {
    for (Iterator iter = disjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) JifUtil.unwrap(iter.next());
      if (p.isAuthorized(authPrf, closure, lb, executeNow)) return true;
    }
    return false;
  }

  public ActsForProof findProofUpto(Store store, Principal p, java.lang.Object searchState) {
    if (delegatesTo(p)) {
      return new DelegatesProof@store(p, this);
    }
    for (Iterator iter = disjuncts.iterator(); iter.hasNext();) {
      Principal witness = (Principal) JifUtil.unwrap(iter.next());
      ActsForProof prf =
          PrincipalUtil.findActsForProof(store, p, witness, searchState);
      if (prf != null) {
        // have found a proof from p to witness.
        DelegatesProof step = new DelegatesProof@store(witness, this);
        return new TransitiveProof@store(prf, witness, step);
      }
    }
    return null;
  }

  public ActsForProof findProofDownto(Store store, Principal q, java.lang.Object searchState) {
	Label lbl = get$label();
	Map proofs = new HashMap@store(lbl,lbl);
    for (Iterator iter = disjuncts.iterator(); iter.hasNext();) {
      Principal p = (Principal) JifUtil.unwrap(iter.next());
      ActsForProof prf = PrincipalUtil.findActsForProof(store, p, q, searchState);
      if (prf == null) return null;
      
      JifObject _p = (new JifObjectWrapper(p.get$label()))
    	.fabric$lang$JifObjectWrapper$(p);
      JifObject _prf = (new JifObjectWrapper(prf.get$label()))
  		.fabric$lang$JifObjectWrapper$(prf);
      proofs.put(_p, _prf);
    }

    // proofs contains a proof for every disjunct,
    // which is sufficent for a proof for the disjunctive principal
    return new FromDisjunctProof@store(this, q, proofs);
  }
}
