package fabric.lang.arrays;

import fabric.client.Core;

/**
 * author: kvikram This class implements a resizable array using ObjectArray as
 * a primitive The smaller array pieces are arranged as a tree so as to support
 * efficient indexing operations. This version of ResizableArray assumes
 * elements are Object instances. For primitive types, other versions may be
 * written. Possible optimizations: 1. convert the length to a base 128
 * representation will make it easier to take logs then. Bugs/Unintended
 * Features: 1. If the array is indeed of ObjectArray instance, then things
 * could get messed up. We're assuming for now that this case won't arise 2.
 * We've just created this for Object arrays. Still need to extend it to
 * primitive arrays.
 * 
 * XXX For simplicity the byte arrays are also of CHUNK_SIZE size
 */

public class ResizableByteArray {
    /**
     * The number of elements in each little array. Dependent on the MTU?
     * Analogous to a block in a file system. Also directly determines the fanout.
     */
    private int CHUNK_SIZE;

    /**
     * The height of the tree of little arrays. Depends on the chunk size
     * (determining the branching factor) and the number of expected elements in
     * the bigger array
     */
    private int height;

    /**
     * The number of expected elements in this big array Can be modified even
     * after an instance has been created
     */
    private int length;

    /**
     * The root of the tree of little arrays. The runtime type of root is a Fabric
     * array of Fabric Objects. Each object in the array is either a further array
     * of objects or is an array element if this array is at the leaf level
     */
    private Object root;

    /**
     * Creates a new object array at the given Core with the given length.
     * 
     * @param core
     *                The core on which to allocate the array.
     * @param length
     *                The length of the array.
     */
    public ResizableByteArray(int length) {
        this(length, 64);
    }

    public ResizableByteArray(int length, int CHUNK_SIZE) {
        this.CHUNK_SIZE = CHUNK_SIZE;
        this.length = length;
        this.height = (int) Math.ceil(Math.log(length) / Math.log(CHUNK_SIZE));
        if (height == 1)
            root = new byteArray(CHUNK_SIZE);
        else if(height == 2)
            root = new ObjectArray(byteArray.class, CHUNK_SIZE);
        else
            root = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
    }

    public int getLength() {
        return length;
    }

    public void setLength(int newSize) {
        int newHeight = (int) Math.ceil(Math.log(newSize) / Math.log(CHUNK_SIZE));
        int difference = newHeight - this.height;
        if (difference > 0) {
            // make sure the leaves are at the right level - push down the root
            if(this.height == 1) {
                ObjectArray newRoot = new ObjectArray(byteArray.class, CHUNK_SIZE);
                root = newRoot;
                difference--;
            }
            for (int count = 0; count < difference; count++) {
                ObjectArray newRoot = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
                newRoot.set(0, root);
                root = newRoot;
            }
        } else if (difference < 0){
            // Truncate the last so many array slots.
            if(newHeight == 1) difference++;
            for (int count = 0; count < -difference; count++) {
                ObjectArray rootArray = (ObjectArray)((ObjectArray)root).get(0);
                root = rootArray;
            }
            if(newHeight == 1) {
                byteArray rootArray = (byteArray) ((ObjectArray)root).get(0);
                root = rootArray;
            }

            if(newHeight != 1) {
                // Null out the part of the tree that shouldn't exist anymore.
                ObjectArray curNode = (ObjectArray)root;
                int curHeight = newHeight;
                while (curNode != null) {
                    int divider = (int) Math.pow(CHUNK_SIZE, curHeight - 1);
                    int firstDigit = newSize / divider;

                    for (int count = firstDigit+1; count < CHUNK_SIZE; count++)
                        curNode.set(count, null);

                    curHeight--;
                    if(curHeight == 1) break;
                    curNode = (ObjectArray) curNode.get(firstDigit);
                }
            }
        }

        this.height = newHeight;
        this.length = newSize;
    }

    public byte get(int i) {
        if (i < 0 || i >= length) throw new ArrayIndexOutOfBoundsException();
        return accessByLevel(root, height, i, true, (byte)0);
    }

    /**
     * Reads/writes an array element.
     * 
     * @param node
     *                the subtree being accessed.
     * @param level
     *                the height of the given node in the tree.
     * @param i
     *                the index of the element to read/write.
     * @param isRead
     *                true if the access is a read, false if the access is a
     *                write.
     * @param data
     *                the value to write, if the access is a write. This is unused
     *                if the access is a read.
     */
    private byte accessByLevel(Object node, int level, int i,
        boolean isRead, byte data) {

        if (level == 1) {
            byteArray array = (byteArray)node;
            return isRead ? array.get(i) : array.set(i, data);
        }
        
        // cast guaranteed to go through, since level >= 2 
        ObjectArray array = (ObjectArray)node;

        int divider = (int) Math.pow(CHUNK_SIZE, level - 1);
        int firstDigit = i / divider;
        int otherDigits = i % divider;

        Object nextObject = array.get(firstDigit);
        if (nextObject == null) {
            if (isRead) return 0;

            // Writing to a node that doesn't exist yet.  Time to create it.
            if (level == 2)
                nextObject = new byteArray(CHUNK_SIZE);
            else if (level == 3)
                nextObject = new ObjectArray(byteArray.class, CHUNK_SIZE);
            else
                nextObject = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
            array.set(firstDigit, nextObject);
        }

        return accessByLevel(nextObject, level - 1, otherDigits, isRead, data);
    }

    public byte set(int i, byte data) {
        if (i < 0 || i >= length) throw new ArrayIndexOutOfBoundsException();
        return accessByLevel(root, height, i, false, data);
    }
}
