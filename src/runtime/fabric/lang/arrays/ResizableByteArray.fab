package fabric.lang.arrays;

import fabric.client.Core;

/**
 * author: kvikram
 *  This class implements a resizable array using ObjectArray as
 * a primitive The smaller array pieces are arranged as a tree so as to support
 * efficient indexing operations. This version of ResizableArray assumes
 * elements are Object instances.
 * 
 * This is an array for bytes, and is adapted from ResizableObectArray
 * 
 * Optimizations:
 * 1. Remove the call to getProxy in the generated Java file
 *     
 * XXX For simplicity the byte arrays are also of CHUNK_SIZE size
 */

public class ResizableByteArray {
    /**
     * The number of elements in each little array. Dependent on the MTU?
     * Analogous to a block in a file system. Also directly determines the fanout.
     */
    private int CHUNK_SIZE;
    private final int CHUNK_SIZE_LOG2;


    /**
     * The height of the tree of little arrays. Depends on the chunk size
     * (determining the branching factor) and the number of expected elements in
     * the bigger array
     */
    private int height;

    /**
     * The number of expected elements in this big array Can be modified even
     * after an instance has been created
     */
    private int length;

    /**
     * The root of the tree of little arrays. The runtime type of root is a Fabric
     * array of Fabric Objects. Each object in the array is either a further array
     * of objects or is an array element if this array is at the leaf level
     */
    private Object root;

    /**
     * Creates a new object array at the given Core with the given length.
     * 
     * @param core
     *                The core on which to allocate the array.
     * @param length
     *                The length of the array.
     */
    public ResizableByteArray(int length) {
        /* default chunk size is 256 until further notice */
        this(length, 8);
    }
    
    /* Called when initial length is 0 */
    public ResizableByteArray() {
        /* default chunk size is 256 until further notice */
        this.CHUNK_SIZE_LOG2 = 8;
        this.CHUNK_SIZE = (1 << 8);
        this.length = 0;
        this.height = 1;
        root = new byteArray(CHUNK_SIZE);
    }

    public ResizableByteArray(int length, int CHUNK_SIZE_LOG2) {
        this.CHUNK_SIZE_LOG2 = CHUNK_SIZE_LOG2;
        this.CHUNK_SIZE = (1 << CHUNK_SIZE_LOG2);
        this.length = length;

        // compute required height (height starts at 1)
        this.height = getCounter(length - 1) + 1;

        switch(height) {
        case 1: root = new byteArray(CHUNK_SIZE);break;
        case 2: root = new ObjectArray(byteArray.class, CHUNK_SIZE);break;
        default: root = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
        }
    }

    private int getCounter(int i) {
        int counter = 0;
        while(i > 0) {
            i = (i >> this.CHUNK_SIZE_LOG2);
            counter++;
        }
        counter--;
        return counter;
    }

    public int getLength() {
        return length;
    }
    
    public void setZeroLength() {
        this.length = 0;
        this.height = 1;
        root = new byteArray(CHUNK_SIZE);
    }

    public void setLength(int newSize) {
        if(newSize <= 0) throw new ArrayIndexOutOfBoundsException();
        int counter = getCounter(newSize - 1);
        int newHeight = counter + 1;
        int oldHeight = this.height;
        int difference = newHeight - oldHeight;
        this.height = newHeight;
        this.length = newSize;                

        /* now set root and null out unnecessary stuff */
        if (difference > 0) {
            // make sure the leaves are at the right level - push down the root
            if(oldHeight == 1) {
                ObjectArray newRoot = new ObjectArray(byteArray.class, CHUNK_SIZE);
                newRoot.set(0, root);
                root = newRoot;
                difference--;
            }
            for (int count = 0; count < difference; count++) {
                ObjectArray newRoot = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
                newRoot.set(0, root);
                root = newRoot;
            }
        } else if (difference < 0){
            // Truncate the last so many array slots.
            if(newHeight == 1) difference++;
            for (int count = 0; count < -difference; count++) {
                ObjectArray rootArray = (ObjectArray)((ObjectArray)root).get(0);
                root = rootArray;
            }
            if(newHeight == 1) {
                byteArray rootArray = (byteArray) ((ObjectArray)root).get(0);
                root = rootArray;
            }

            if(newHeight != 1) {
                // Null out the part of the tree that shouldn't exist anymore.
                ObjectArray curNode = (ObjectArray)root;
                int curIndex = newSize - 1;
                int curHeight = newHeight;
                int firstDigit;
                while (curHeight > 1 && curNode != null) {
                    firstDigit = (curIndex >> (counter * this.CHUNK_SIZE_LOG2));
                    for (int count = firstDigit + 1; count < this.CHUNK_SIZE; count++) {
                        curNode.set(count, null);
                    }
                    curNode = (ObjectArray) curNode.get(firstDigit);
                    curIndex = ( curIndex & ((1 << counter*this.CHUNK_SIZE_LOG2) - 1) );
                    counter -= this.CHUNK_SIZE_LOG2;
                    curHeight--;
                }
            }
        }
    }

    public byte get(int i) {
        if (i >= length) throw new ArrayIndexOutOfBoundsException();
        Object node = root;
        int level = height;
        int c = this.CHUNK_SIZE_LOG2;
        int counter = (level - 1) * c;
        int firstDigit;
        while(level > 1) {
            firstDigit = (i >> counter);
            node = ((ObjectArray)node).get(firstDigit);
            if (node == null) {
                return 0;
            }
            i = ( i & ((1 << counter) - 1) );
            counter -= c;
            level--;
        }
        return ((byteArray)node).get(i);
    }
    
    /* This method really needs to be optimized */
    public int get(int i, fabric.io.FileByteArray barray) {
        for(int j = i; j < i + barray.length(); j++) {
            barray.set(j-i, get(j));
        }
        return barray.length();
    }

    public byte set(int i, byte data) {
        if (i >= length) throw new ArrayIndexOutOfBoundsException();
        Object node = root;
        int level = height;
        int c = this.CHUNK_SIZE_LOG2;
        int counter = (level - 1) * c;
        int firstDigit;
        Object nextObject;
        ObjectArray oArray;
        while(level > 1) {
            firstDigit = (i >> counter);
            oArray = (ObjectArray)node;
            nextObject = oArray.get(firstDigit);
            if (nextObject == null) {
                // Writing to a node that doesn't exist yet.  Time to create it.
                switch(level) {
                case 3: nextObject = new ObjectArray(byteArray.class, CHUNK_SIZE);break;
                case 2: nextObject = new byteArray(CHUNK_SIZE);break;
                default: nextObject = new ObjectArray(ObjectArray.class, CHUNK_SIZE);
                }
                oArray.set(firstDigit, nextObject);
            }
            node = nextObject;
            i = ( i & ((1 << counter) - 1) );
            counter -= c;
            level--;
        }
        return ((byteArray)node).set(i, data);        
    }
}
