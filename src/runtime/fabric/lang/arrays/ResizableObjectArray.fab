package fabric.lang.arrays;

import fabric.client.Core;

/**
 * author: kvikram This class implements a resizable array using ObjectArray as
 * a primitive The smaller array pieces are arranged as a tree so as to support
 * efficient indexing operations. This version of ResizableArray assumes
 * elements are Object instances. For primitive types, other versions may be
 * written. Possible optimizations: 1. convert the length to a base 128
 * representation will make it easier to take logs then. Bugs/Unintended
 * Features: 1. If the array is indeed of ObjectArray instance, then things
 * could get messed up. We're assuming for now that this case won't arise 2.
 * We've just created this for Object arrays. Still need to extend it to
 * primitive arrays.
 */

public class ResizableObjectArray {
  /**
   * The core at which to create new nodes in the tree.
   */
  private Core core;

  /**
   * The number of elements in each little array. Dependent on the MTU?
   * Analogous to a block in a file system. Also directly determines the fanout.
   */
  private static final int CHUNK_SIZE = 128;

  /**
   * The height of the tree of little arrays. Depends on the chunk size
   * (determining the branching factor) and the number of expected elements in
   * the bigger array
   */
  private int height;

  /**
   * The number of expected elements in this big array Can be modified even
   * after an instance has been created
   */
  private int length;

  /**
   * The class representing the proxy type for the array elements.
   */
  private final Class proxyType;

  /**
   * The root of the tree of little arrays. The runtime type of root is a Fabric
   * array of Fabric Objects. Each object in the array is either a further array
   * of objects or is an array element if this array is at the leaf level
   */
  private ObjectArray root;

  /**
   * Creates a new object array at the given Core with the given length.
   * 
   * @param core
   *                The core on which to allocate the array.
   * @param length
   *                The length of the array.
   */
  public ResizableObjectArray(Core core, Class proxyType, int length) {
    this.core = core;
    this.proxyType = proxyType;
    this.length = length;
    this.height = (int) Math.ceil(Math.log(length) / Math.log(CHUNK_SIZE));
    if (height == 1)
      root = new ObjectArray@core(proxyType, CHUNK_SIZE);
    else
      root = new ObjectArray@core(ObjectArray.class, CHUNK_SIZE);
  }

  public int getLength() {
    return length;
  }

  public void setLength(int newSize) {
    int newHeight = (int) Math.ceil(Math.log(newSize) / Math.log(CHUNK_SIZE));
    int difference = newHeight - this.height;
    if (difference > 0) {
      // make sure the leaves are at the right level - push down the root
      for (int count = 0; count < difference; count++) {
        ObjectArray newRoot = new ObjectArray@core(ObjectArray.class, CHUNK_SIZE);
        newRoot.set(0, root);
        root = newRoot;
      }
    } else if (difference < 0){
      // Truncate the last so many array slots.
      for (int count = 0; count < -difference; count++) {
        ObjectArray rootArray = (ObjectArray) root.get(0);
        root = rootArray;
      }
      
      // Null out the part of the tree that shouldn't exist anymore.
      ObjectArray curNode = root;
      int curHeight = newHeight;
      while (curHeight > 1 && curNode != null) {
        int divider = (int) Math.pow(CHUNK_SIZE, curHeight - 1);
        int firstDigit = newSize / divider;
        
        for (int count = firstDigit+1; count < CHUNK_SIZE; count++)
          curNode.set(count, null);
        
        curNode = (ObjectArray) curNode.get(firstDigit);
        curHeight--;
      }
    }
    
    this.height = newHeight;
    this.length = newSize;
  }

  public Object get(int i) {
    if (i < 0 || i >= length) throw new ArrayIndexOutOfBoundsException();
    return accessByLevel(root, height, i, true, null);
  }

  /**
   * Reads/writes an array element.
   * 
   * @param node
   *                the subtree being accessed.
   * @param level
   *                the height of the given node in the tree.
   * @param i
   *                the index of the element to read/write.
   * @param isRead
   *                true if the access is a read, false if the access is a
   *                write.
   * @param data
   *                the value to write, if the access is a write. This is unused
   *                if the access is a read.
   */
  private Object accessByLevel(ObjectArray node, int level, int i,
      boolean isRead, Object data) {
    
    if (level == 1) return isRead ? node.get(i) : node.set(i, data);

    int divider = (int) Math.pow(CHUNK_SIZE, level - 1);
    int firstDigit = i / divider;
    int otherDigits = i % divider;

    Object nextObject = node.get(firstDigit);
    if (nextObject == null) {
      if (isRead) return null;

      // Writing to a node that doesn't exist yet.  Time to create it.
      if (level == 2)
        nextObject = new ObjectArray@core(proxyType, CHUNK_SIZE);
      else
        nextObject = new ObjectArray@core(ObjectArray.class, CHUNK_SIZE);
      node.set(firstDigit, nextObject);
    }

    return accessByLevel((ObjectArray) nextObject, level - 1,
        otherDigits, isRead, data);
  }

  public Object set(int i, Object data) {
    if (i < 0 || i >= length) throw new ArrayIndexOutOfBoundsException();
    return accessByLevel(root, height, i, false, data);
  }
}
