package fabric.lang.arrays;

import fabric.client.Core;

/**
 * author: kvikram
 * This class implements a resizable array using ObjectArray as a primitive
 * The smaller array pieces are arranged as a tree so as to support efficient
 * indexing operations.
 * 
 * This version of ResizableArray assumes elements are Object instances.
 * For primitive types, other versions may be written.
 * 
 * Possible optimizations:
 * 1. convert the length to a base 128 representation
 *    will make it easier to take logs then.
 *    
 * Bugs/Unintended Features:
 * 1. If the array is indeed of ObjectArray instance, then things could get
 *    messed up.  We're assuming for now that this case won't arise
 * 2. We've just created this for Object arrays. Still need to extend it to
 *    primitive arrays.
 *
 **/

public class ResizableObjectArray {
  /**
   * The core at which to create new nodes in the tree.
   */
  private Core core;
  
  /**
   * The number of elements in each little array. Dependent on the MTU?
   * Analogous to a block in a file system. Also directly determines the fanout.
   */
  public static final int CHUNK_SIZE = 128;

  /**
   * The height of the tree of little arrays. Depends on the chunk size
   * (determining the branching factor) and the number of expected elements in
   * the bigger array
   */
  private int height;

  /**
   * The number of expected elements in this big array Can be modified even
   * after an instance has been created
   */
  private int length;

  /**
   * The class representing the proxy type for the array elements.
   */
  private final Class proxyType;

  /**
   * The root of the tree of little arrays. The runtime type of root is a Fabric
   * array of Fabric Objects. Each object in the array is either a further array
   * of objects or is an array element if this array is at the leaf level
   */
  private ObjectArray root;

  /**
   * Creates a new object array at the given Core with the given length.
   * 
   * @param core
   *                The core on which to allocate the array.
   * @param length
   *                The length of the array.
   */
  public ResizableObjectArray(Core core, Class proxyType, int length) {
    this.core = core;
    this.proxyType = proxyType;
    this.length = length;
    this.height = (int) Math.ceil(Math.log(length) / Math.log(CHUNK_SIZE));
    root = new ObjectArray@core(proxyType, CHUNK_SIZE);
  }

  public int getLength() {
    return length;
  }

  public void setLength(int newSize) {
    int newHeight = (int) Math.ceil(Math.log(newSize) / Math.log(CHUNK_SIZE));
    int difference = newHeight - this.height;
    if (difference == 0) return;

    if (difference > 0) {
      // make sure the leaves are at the right level - push down the root
      while (difference-- > 0) {
        ObjectArray newRoot = new ObjectArray@core(proxyType, CHUNK_SIZE);
        newRoot.set(0, root);
        root = newRoot;
      }
      return;
    }

    // difference > 0. Truncate the last so many array slots
    while (difference++ < 0) {
      ObjectArray rootArray = (ObjectArray) root.get(0);
      root = rootArray;
    }
    return;
  }

  public Object get(int i) {
    return accessByLevel(root, height, i, true, null);
  }

  /**
   * Reads/writes an array element.
   * 
   * @param node
   *                the subtree being accessed.
   * @param level
   *                the height of the given node in the tree.
   * @param i
   *                the index of the element to read/write.
   * @param isRead
   *                true if the access is a read, false if the access is a
   *                write.
   * @param data
   *                the value to write, if the access is a write. This is unused
   *                if the access is a read.
   */
  private Object accessByLevel(ObjectArray node, int level, int i,
      boolean isRead, Object data) {

    if (node == null) {
      if (isRead) return null;

      // we're boldly going where no one has gone before
      // XXX this new node needs to join the tree somehow.
      node = new ObjectArray@core(proxyType, CHUNK_SIZE);
    }

    int divider = (int) Math.pow(CHUNK_SIZE, level - 1);
    int firstDigit = i / divider;
    int otherDigits = i % divider;

    if (level == 1) return isRead ? node.get(i) : node.set(i, data);

    return accessByLevel((ObjectArray) node.get(firstDigit), level - 1,
        otherDigits, isRead, data);
  }

  public Object set(int i, Object data) {
    return accessByLevel(root, height, i, false, data);
  }
}
