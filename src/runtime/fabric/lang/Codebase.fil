package fabric.lang;

import java.io.IOException;
import java.util.Properties;
import fabric.util.Collections;
import fabric.util.HashMap;
import fabric.util.Map;
import fabric.util.MapEntry;
import fabric.util.Iterator;

/**
 * A codebase is a Fabric object that provides a mapping from fully qualified 
 * class names to Fabric class objects. 
 * 
 * @author Lucas Waye <lrw48@cornell.edu>
 */
public class Codebase {	
	
  /** All of the classes in the codebase **/
  private final Map/*String, FClass*/ classes;
  
  FClass resolveClassName(String name) {
	atomic {
		return (FClass)((JifWrappedObject)classes.get(name)).unwrap();
	}
  }

  public Class toJavaClass(String name) {
	  	FClass c = resolveClassName(name);
	  	if (c == null)
	  		return null;
	  	
	  	if (c.getCodebase().equals(this))
	  		return c.getCodebase().getClassLoader().getJavaClass(c);
	  	else
	  		return c.getCodebase().toJavaClass(name);
  }
  
  FabricClassLoader getClassLoader() {
    return FabricClassLoader.getClassLoader(this);
  }
  
  public Codebase(Map/*String, FClass*/ classes) {
	atomic {
	    this.classes = new HashMap(classes.jif$getfabric_util_Map_K(),
								classes.jif$getfabric_util_Map_V())
								.fabric$util$HashMap$(classes.size());
		for(Iterator i = classes.entrySet().iterator(); i.hasNext();) {
			MapEntry e = (MapEntry)i.next();
			this.classes.put(e.getKey(), e.getValue());
		}
	}
  }
  
  public Map/*String, FClass*/ getClasses() {
	atomic {
		//return Collections.unmodifiableMap(classes);
		return classes;
	}
  }
  
  public FClass getClass(String s) {
      return (FClass)((JifWrappedObject)classes.get(s)).unwrap();
  }
  
}
