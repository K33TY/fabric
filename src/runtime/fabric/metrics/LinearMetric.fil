package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.Arrays;
import fabric.util.HashMap;
import fabric.util.Iterator;
import fabric.util.List;
import fabric.util.Map;
import fabric.util.Set;
import fabric.util.TreeSet;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.DerivedMetricContract;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Matrix;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;

/**
 * A {@link Metric} for the entries of Cm⃗ where m⃗ is a {@link Metric} and C is
 * a {@link Matrix} of coefficients.
 */
public class LinearMetric extends DerivedMetric {
  /**
   * The {@link Matrix} that defines this {@link Metric} along with the terms.
   */
  protected /*final*/ Matrix matrix;
  protected /*final*/ Matrix varMatrix;

  /**
   * @param store
   *        the Store that holds this {@link Metric}
   * @param matrix
   *        The coefficients matrix as a double[][]
   * @param terms
   *        The {@link Metric}s this applies to
   */
  public LinearMetric fabric$metrics$LinearMetric$(Matrix matrix, Metric[] terms) {
    fabric$metrics$DerivedMetric$(terms);
    // Pretty sure this violates the constructor protocol, but I'm relying
    // on terms being initialized by this point.
    this.matrix = normalize(matrix);
    this.varMatrix = this.matrix.elementMultiply(this.matrix);

    if (matrix.rows() == 0)
      throw new IllegalArgumentException(
          "LinearMetric needs at least 1 coefficient row!");
    if (matrix.columns() != terms.length)
      throw new IllegalArgumentException(
          "LinearMetric coefficient columns size as the dimension of term: "
              + matrix.toString());
    initialize();
    return this;
  }

  /**
   * Utility to normalize the {@link Metric} terms and {@link Matrix}
   * associated with this {@link LinearMetric}.
   *
   * @param matrix
   *        the original matrix
   * @return the matrix rearranged for sorted terms, sorted rows, and
   *       deduplication of rows.
   */
  private Matrix normalize(Matrix matrix) {
    Metric[] normTerms = new Metric[terms.length];
    Arrays.arraycopy(terms, 0, normTerms, 0, terms.length);
    Arrays.sort(normTerms);
    Matrix colNormed = new Matrix().fabric$metrics$util$Matrix$(matrix.rows(), terms.length);
    for (int i = 0; i < terms.length; i++) {
      int oldIdx = Arrays.asList(terms).indexOf(normTerms[i]);
      colNormed.setColumn(i, matrix.getColumn(oldIdx));
    }
    this.terms = normTerms;
    return normalizeRows(colNormed, 0, colNormed.rows());
  }

  /**
   * Utility for normalizing a coefficients {@link Matrix} by sorting rows and
   * eliminating duplicates.
   *
   * @param m
   *        the {@link Matrix} being normalized
   * @return the normalized {@link Matrix}
   */
  private static Matrix normalizeRows(Matrix m, int start, int end) {
    if (end - start > 1) {
      int mid = start + (end - start) / 2;
      Matrix sub1 = normalizeRows(m, start, mid);
      Matrix sub2 = normalizeRows(m, mid, end);
      Matrix merged = new Matrix().fabric$metrics$util$Matrix$(end - start, m.columns());
      int idx1 = 0;
      int idx2 = 0;
      for (int i = 0; i < merged.rows(); i++) {
        int comp = rowCompare(sub1.getRow(idx1), sub2.getRow(idx2));
        if (comp < 0) {
          merged.setRow(i, sub1.getRow(idx1++));
        } else if (comp > 0) {
          merged.setRow(i, sub2.getRow(idx2++));
        } else {
          idx2++;
          merged.removeRow(i--);
        }
      }
      return merged;
    } else if (start == end) {
      return new Matrix().fabric$metrics$util$Matrix$(0, 0);
    }
    return Matrix.singleRow(m.getRow(start));
  }

  /**
   * Utility for comparing two rows of a {@link Matrix} during
   * {@link #normalizeRows(Matrix)}.
   *
   * @param r1
   *        the first row as a double[]
   * @param r2
   *        the second row as a double[]
   * @return 0 if r1 == r2, 1 if r1 > r2 (lexicographically), and -1
   *       otherwise.
   */
  private static int rowCompare(double[] r1, double[] r2) {
    for (int i = 0; i < r1.length; i++) {
      if (r1[i] < r2[i])
        return -1;
      if (r1[i] > r2[i])
        return 1;
    }
    return 0;
  }

  /*@Override*/
  public double value() {
    double[] values = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      values[i] = terms[i].value();
    }
    double[] results = matrix.multiply(values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  private double value(int i) {
    double[] values = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      values[j] = terms[j].value();
    }
    double[] results = matrix.multiply(values);
    return results[i];
  }

  /*@Override*/
  public double velocity() {
    double[] values = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      values[i] = terms[i].velocity();
    }
    double[] results = matrix.multiply(values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  private double velocity(int i) {
    double[] values = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      values[j] = terms[j].velocity();
    }
    double[] results = matrix.multiply(values);
    return results[i];
  }

  /*@Override*/
  public double noise() {
    double[] noises = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      noises[i] = terms[i].noise();
    }
    double[] resultNoises = varMatrix.multiply(noises);
    double noise = 0;
    for (int i = 0; i < resultNoises.length; i++) {
      noise = Math.max(noise, resultNoises[i]);
    }
    return noise;
  }

  private double noise(int i) {
    double[] noises = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      noises[j] = terms[j].noise();
    }
    double[] resultNoises = varMatrix.multiply(noises);
    return resultNoises[i];
  }

  /*@Override*/
  protected MetricContract createContract(Bound bound) {
    return new DerivedMetricContract().fabric$metrics$contracts$DerivedMetricContract$(this, bound);
  }

  /*@Override*/
  public String toString() {
    String str = "min(";
    boolean nonEmpty = false;
    for (int i = 0; i < matrix.rows(); i++) {
      boolean nonEmptyRow = false;
      for (int j = 0; j < terms.length; j++) {
        if (matrix.get(i, j) == 0)
          continue;
        if (nonEmptyRow) {
          str += " + ";
        } else if (nonEmpty) {
          str += ", ";
        }
        nonEmptyRow = true;
        str += "(" + terms[j] + " * " + matrix.get(i, j) + ")";
      }
      if (nonEmptyRow)
        nonEmpty = true;
    }
    return str + ")@" + $getStore().name();
  }

  /*@Override*/
  public DerivedMetric times(double scalar) {
    final Store s = $getStore();
    return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(matrix.multiply(scalar), terms)/*)*/;
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  public DerivedMetric plus(Metric other) {
    final Store s = $getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals($getStore())) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
      termsBag.addAll(Arrays.asList(this.terms));
      termsBag.addAll(Arrays.asList(that.terms));

      // Expand both matrices to account for terms that metric didn't
      // include.
      Matrix thisExpanded = new Matrix().fabric$metrics$util$Matrix$(this.matrix.rows(),
          termsBag.size());
      Matrix thatExpanded = new Matrix().fabric$metrics$util$Matrix$(that.matrix.rows(),
          termsBag.size());
      Metric[] newTerms = new Metric[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator iter = termsBag.iterator();
      while (iter.hasNext()) {
        Metric m = (Metric) iter.next();
        if (this.terms[thisIdx].equals(m)) {
          thisExpanded.setColumn(aggIdx,
              this.matrix.getColumn(thisIdx++));
        }
        if (that.terms[thatIdx].equals(m)) {
          thatExpanded.setColumn(aggIdx,
              that.matrix.getColumn(thatIdx++));
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      Matrix combined = new Matrix().fabric$metrics$util$Matrix$(
          thisExpanded.rows() * thatExpanded.rows(), newTerms.length);
      for (int i = 0; i < thisExpanded.rows(); i++) {
        for (int j = 0; j < thatExpanded.rows(); j++) {
          int row = i * thatExpanded.rows() + j;
          for (int k = 0; k < newTerms.length; k++) {
            combined.set(row, k, thisExpanded.get(i, k)
                + thatExpanded.get(j, k));
          }
        }
      }

      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms)/*)*/;
    } else if (Arrays.asList(terms).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms).indexOf(other);
      Matrix newCs = matrix.copy();
      for (int i = 0; i < newCs.rows(); i++) {
        newCs.set(i, idx, newCs.get(i, idx) + 1);
      }
      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, terms)/*)*/;
    } else if (isSingleStore() && !other.$getStore().equals($getStore())) {
      return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(
          Matrix.constant(1, 2, 1), new Metric[] { this, other })/*)*/;
    }

    Metric[] newTerms = new Metric[terms.length + 1];
    Arrays.arraycopy(terms, 0, newTerms, 0, terms.length);
    newTerms[terms.length] = other;
    Arrays.sort(newTerms, 0, newTerms.length);
    int idx = Arrays.asList(newTerms).indexOf(other);
    double[] newCol = new double[matrix.rows()];
    for (int i = 0; i < newCol.length; i++) {
      newCol[i] = 1;
    }
    Matrix newCs = matrix.copy();
    newCs.insertColumn(idx, newCol);
    return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms)/*)*/;
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  /*@Override*/
  public Metric min(Metric other) {
    final Store s = $getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals($getStore())) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
      termsBag.addAll(Arrays.asList(this.terms));
      termsBag.addAll(Arrays.asList(that.terms));

      // Expand both matrices to account for terms that metric didn't
      // include.
      Matrix thisExpanded = new Matrix().fabric$metrics$util$Matrix$(this.matrix.rows(),
          termsBag.size());
      Matrix thatExpanded = new Matrix().fabric$metrics$util$Matrix$(that.matrix.rows(),
          termsBag.size());
      Metric[] newTerms = new Metric[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator iter = termsBag.iterator();
      while (iter.hasNext()) {
        Metric m = (Metric) iter.next();
        if (this.terms[thisIdx].equals(m)) {
          thisExpanded.setColumn(aggIdx,
              this.matrix.getColumn(thisIdx++));
        }
        if (that.terms[thatIdx].equals(m)) {
          thatExpanded.setColumn(aggIdx,
              that.matrix.getColumn(thatIdx++));
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      Matrix combined = new Matrix().fabric$metrics$util$Matrix$(
          thisExpanded.rows() + thatExpanded.rows(), newTerms.length);
      for (int i = 0; i < thisExpanded.rows(); i++) {
        for (int j = 0; j < newTerms.length; j++) {
          combined.set(i, j, thisExpanded.get(i, j));
          combined.set(i + thisExpanded.rows(), j,
              thatExpanded.get(i, j));
        }
      }

      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms)/*)*/;
    } else if (Arrays.asList(terms).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms).indexOf(other);
      Matrix newCs = matrix.copy();
      double[] newRow = new double[terms.length];
      newRow[idx] = 1;
      newCs.addRow(newRow);
      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, terms)/*)*/;
    } else if (isSingleStore() && !other.$getStore().equals($getStore())) {
      return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(
          Matrix.identity(2), new Metric[] { this, other })/*)*/;
    }

    Metric[] newTerms = new Metric[terms.length + 1];
    Arrays.arraycopy(terms, 0, newTerms, 0, terms.length);
    newTerms[terms.length] = other;
    Arrays.sort(newTerms, 0, newTerms.length);
    int idx = Arrays.asList(newTerms).indexOf(other);
    Matrix newCs = matrix.copy();
    newCs.addColumn(new double[matrix.rows()]);
    double[] newRow = new double[terms.length + 1];
    newRow[idx] = 1;
    newCs.addRow(newRow);
    return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms)/*)*/;
  }

  /*@Override*/
  public DerivedMetric copyOn(final Store s) {
    return /*s.findDerivedMetric(*/new LinearMetric@s().fabric$metrics$LinearMetric$(matrix, terms)/*)*/;
  }

  /*@Override*/
  public EnforcementPolicy policyFor(Bound bound) {
    Map/*<Metric, MetricContract>*/ witnesses = new HashMap/*<>*/();

    long currentTime = System.currentTimeMillis();
    double base = bound.rate * (currentTime - bound.startTime) + bound.base;
    double rate = bound.rate;

    // Defend all rows against the bound individually, using the strictest
    // bounds across the rows for each term in this sum.
    for (int i = 0; i < matrix.rows(); i++) {
      double totalValue = value(i);
      double totalVelocity = velocity(i);
      double totalNoise = noise(i);
      double numTerms = terms.length;

      // For each term, update the associated bounds to be the tightest
      // bound set across the rows
      for (int j = 0; j < numTerms; j++) {
        double c = matrix.get(i, j);
        Metric m = term(j);
        double scaledX = m.value() * c;
        double scaledV = m.velocity() * c;
        double scaledN = m.noise() * c * c;

        // Corrected for the way this metric is shifting relative to the
        // rest of the sum
        double r = scaledV - ((totalVelocity - rate) / numTerms);
        // De-scaled
        r /= c;

        double b = scaledX - ((scaledN / totalNoise) * (totalValue - base));
        // De-scaled
        b /= c;

        if (c < 0) {
          m = m.times(-1);
          b = -b;
          r = -r;
          Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(r, b, currentTime);
          if (!witnesses.containsKey(m) || !((MetricContract) witnesses.get(m)).getBound().implies(witnessBound)) {
            witnesses.put(m, m.getContract(witnessBound));
          }
        } else {
          Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(r, b, currentTime);
          if (!witnesses.containsKey(m) || !((MetricContract) witnesses.get(m)).getBound().implies(witnessBound)) {
            witnesses.put(m, m.getContract(witnessBound));
          }
        }
      }
    }
    return new WitnessPolicy().fabric$metrics$contracts$enforcement$WitnessPolicy$(witnesses.values());
  }

  /*@Override*/
  public int hashCode() {
    List/*<Object>*/ l = new ArrayList/*<>*/().fabric$util$ArrayList$(terms.length + 2);
    l.add(matrix);
    l.add($getStore());
    l.addAll(Arrays.asList(terms));
    return l.hashCode();
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof LinearMetric) {
      LinearMetric that = (LinearMetric) other;
      return this.matrix.equals(that.matrix)
          && Arrays.deepEquals(this.terms, that.terms)
          && this.$getStore().equals(that.$getStore());
    }
    return false;
  }
}
