package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.Arrays;
import fabric.util.HashMap;
import fabric.util.Iterator;
import fabric.util.List;
import fabric.util.Map;
import fabric.util.Set;
import fabric.util.TreeSet;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.DerivedMetricContract;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

/**
 * A {@link Metric} for the entries of Cm⃗ where m⃗ is a {@link Metric} and C is
 * a {@link Matrix} of coefficients.
 */
public class LinearMetric extends DerivedMetric {
  /**
   * The {@link Matrix} that defines this {@link Metric} along with the terms.
   */
  protected /*final*/ double[][] matrix;

  /**
   * @param store
   *        the Store that holds this {@link Metric}
   * @param matrix
   *        The coefficients matrix as a double[][]
   * @param terms
   *        The {@link Metric}s this applies to
   */
  public LinearMetric fabric$metrics$LinearMetric$(double[][] matrix, Metric[] terms) {
    fabric$metrics$DerivedMetric$(terms);
    if (matrix.length == 0)
      throw new IllegalArgumentException(
          "LinearMetric needs at least 1 coefficient row!");
    if (matrix[0].length != terms.length)
      throw new IllegalArgumentException(
          "LinearMetric coefficient columns size as the dimension of term: "
              + matrix.toString());

    // XXX Technically not the right order for the FabIL constructor
    // protocol, but I'm not sure what I was doing here in Java ports
    // directly?
    this.matrix = normalize(matrix);
    initialize();
    return this;
  }

  /**
   * Utility to normalize the {@link Metric} terms and {@link Matrix}
   * associated with this {@link LinearMetric}.
   *
   * @param matrix
   *        the original matrix
   * @return the matrix rearranged for sorted terms, sorted rows, and
   *       deduplication of rows.
   */
  private double[][] normalize(double[][] matrix) {
    Metric[] normTerms = new Metric[terms.length];
    Arrays.arraycopy(terms, 0, normTerms, 0, terms.length);
    Arrays.sort(normTerms);
    double[][] colNormed = new double[matrix.length][terms.length];
    for (int i = 0; i < terms.length; i++) {
      int oldIdx = Arrays.asList(terms).indexOf(normTerms[i]);
      for (int j = 0; j < colNormed.length; j++) {
        colNormed[j][i] = matrix[j][oldIdx];
      }
    }
    this.terms = normTerms;
    return normalizeRows(colNormed, 0, colNormed.length);
  }

  /**
   * Utility for normalizing a coefficients {@link Matrix} by sorting rows and
   * eliminating duplicates.
   *
   * @param m
   *        the {@link Matrix} being normalized
   * @return the normalized {@link Matrix}
   */
  private static double[][] normalizeRows(double[][] m, int start, int end) {
    if (end - start > 1) {
      int mid = start + (end - start) / 2;
      double[][] sub1 = normalizeRows(m, start, mid);
      double[][] sub2 = normalizeRows(m, mid, end);
      double[][] merged = new double[end - start][m[start].length];
      int idx1 = 0;
      int idx2 = 0;
      for (int i = 0; i < merged.length; i++) {
        int comp = rowCompare(sub1[idx1], sub2[idx2]);
        if (comp < 0) {
          for (int j = 0; j < m[start + i].length; j++) {
            merged[i][j] = sub1[idx1][j];
          }
          idx1++;
        } else if (comp > 0) {
          for (int j = 0; j < m[start + i].length; j++) {
            merged[i][j] = sub2[idx2][j];
          }
          idx2++;
        } else {
          double[][] smaller = new double[merged.length
              - 1][merged[i].length];
          for (int j = 0; j < i; j++) {
            for (int k = 0; k < merged[j].length; k++) {
              smaller[j][k] = merged[j][k];
            }
          }
          merged = smaller;
          i--;
        }
      }
      return merged;
    } else if (start == end) {
      return new double[][] {};
    }
    return new double[][] { m[start] };
  }

  /**
   * Utility for comparing two rows of a {@link Matrix} during
   * {@link #normalizeRows(Matrix)}.
   *
   * @param r1
   *        the first row as a {@link Vector}
   * @param r2
   *        the second row as a {@link Vector}
   * @return 0 if r1 == r2, 1 if r1 > r2 (lexicographically), and -1
   *       otherwise.
   */
  private static int rowCompare(double[] r1, double[] r2) {
    for (int i = 0; i < r1.length; i++) {
      if (r1[i] < r2[i])
        return -1;
      if (r1[i] > r2[i])
        return 1;
    }
    return 0;
  }

  /**
   * Utility for matrix multiplication.
   */
  private double[] matMul(double[][] mat, double[] v) {
    double[] result = new double[mat.length];
    for (int i = 0; i < result.length; i++) {
      for (int k = 0; k < v.length; k++) {
        result[i] += mat[i][k] * v[k];
      }
    }
    return result;
  }

  /*@Override*/
  public double value() {
    double[] values = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      values[i] = terms[i].value();
    }
    double[] results = matMul(matrix, values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  private double value(int i) {
    double[] values = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      values[j] = terms[j].value();
    }
    double[] results = matMul(matrix, values);
    return results[i];
  }

  /*@Override*/
  public double velocity() {
    double[] values = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      values[i] = terms[i].velocity();
    }
    double[] results = matMul(matrix, values);
    double result = Double.MAX_VALUE;
    for (int i = 0; i < results.length; i++) {
      result = Math.min(result, results[i]);
    }
    return result;
  }

  private double velocity(int i) {
    double[] values = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      values[j] = terms[j].velocity();
    }
    double[] results = matMul(matrix, values);
    return results[i];
  }

  /*@Override*/
  public double noise() {
    double[] noises = new double[terms.length];
    for (int i = 0; i < terms.length; i++) {
      noises[i] = terms[i].noise();
    }
    double noise = 0;
    for (int i = 0; i < matrix.length; i++) {
      double subnoise = 0;
      for (int j = 0; j < noises.length; j++) {
        double c = matrix[i][j];
        subnoise += (c * c * noises[j]);
      }
      noise = Math.max(noise, subnoise);
    }
    return noise;
  }

  private double noise(int i) {
    double[] noises = new double[terms.length];
    for (int j = 0; j < terms.length; j++) {
      noises[j] = terms[j].noise();
    }
    double noise = 0;
    for (int j = 0; j < noises.length; j++) {
      double c = matrix[i][j];
      noise += (c * c * noises[j]);
    }
    return noise;
  }

  /*@Override*/
  protected MetricContract createContract(Bound bound) {
    return new DerivedMetricContract().fabric$metrics$contracts$DerivedMetricContract$(this, bound);
  }

  /*@Override*/
  public String toString() {
    String str = "min(";
    boolean nonEmpty = false;
    for (int i = 0; i < matrix.length; i++) {
      boolean nonEmptyRow = false;
      for (int j = 0; j < terms.length; j++) {
        if (matrix[i][j] == 0)
          continue;
        if (nonEmptyRow) {
          str += " + ";
        } else if (nonEmpty) {
          str += ", ";
        }
        nonEmptyRow = true;
        str += "(" + terms[j] + " * " + matrix[i][j] + ")";
      }
      if (nonEmptyRow)
        nonEmpty = true;
    }
    return str + ")@" + $getStore().name();
  }

  /*@Override*/
  public DerivedMetric times(double scalar) {
    final Store s = $getStore();
    double[][] scaled = new double[matrix.length][terms.length];
    for (int i = 0; i < matrix.length; i++) {
      for (int j = 0; j < matrix[i].length; j++) {
        scaled[i][j] = matrix[i][j] * scalar;
      }
    }
    return /*getStore().findDerivedMetric(*/
      new LinearMetric@s().fabric$metrics$LinearMetric$(scaled, terms)/*)*/;
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  public DerivedMetric plus(Metric other) {
    final Store s = $getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals($getStore())) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
      termsBag.addAll(Arrays.asList(this.terms));
      termsBag.addAll(Arrays.asList(that.terms));

      // Expand both matrices to account for terms that metric didn't
      // include.
      double[][] thisExpanded = new double[this.matrix.length][termsBag
          .size()];
      double[][] thatExpanded = new double[that.matrix.length][termsBag
          .size()];
      Metric[] newTerms = new Metric[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator iter = termsBag.iterator();
      while (iter.hasNext()) {
        Metric m = (Metric) iter.next();
        if (this.terms[thisIdx].equals(m)) {
          for (int i = 0; i < this.matrix.length; i++) {
            thisExpanded[i][aggIdx] = this.matrix[i][thisIdx];
          }
          thisIdx++;
        }
        if (that.terms[thatIdx].equals(m)) {
          for (int i = 0; i < that.matrix.length; i++) {
            thatExpanded[i][aggIdx] = that.matrix[i][thatIdx];
          }
          thatIdx++;
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      double[][] combined = new double[thisExpanded.length * thatExpanded.length][newTerms.length];
      for (int i = 0; i < thisExpanded.length; i++) {
        for (int j = 0; j < thatExpanded.length; j++) {
          int row = i * thatExpanded.length + j;
          for (int k = 0; k < combined[row].length; k++) {
            combined[row][k] = thisExpanded[i][k]
                + thatExpanded[j][k];
          }
        }
      }

      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms)/*)*/;
    } else if (Arrays.asList(terms).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms).indexOf(other);
      double[][] newCs = new double[matrix.length][terms.length];
      for (int i = 0; i < newCs.length; i++) {
        for (int j = 0; j < newCs[i].length; j++) {
          newCs[i][j] = matrix[i][j];
          if (j == idx)
            newCs[i][j]++;
        }
      }
      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, terms)/*)*/;
    } else if (isSingleStore() && !other.$getStore().equals($getStore())) {
      return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(
          new double[][] { new double[]{ 1, 1 } }, new Metric[]{this, other})/*)*/;
    }

    Metric[] newTerms = new Metric[terms.length + 1];
    System.arraycopy(terms, 0, newTerms, 0, terms.length);
    newTerms[terms.length] = other;
    Arrays.sort(newTerms, 0, newTerms.length);
    int idx = Arrays.asList(newTerms).indexOf(other);
    double[][] newCs = new double[matrix.length][terms.length + 1];
    for (int i = 0; i < newCs.length; i++) {
      for (int j = 0; j < newCs[i].length; j++) {
        if (j == idx) {
          newCs[i][j] = 1;
        } else if (j > idx) {
          newCs[i][j] = matrix[i][j - 1];
        } else {
          newCs[i][j] = matrix[i][j];
        }
      }
    }
    return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms)/*)*/;
  }

  /**
   * {@inheritDoc}
   * <p>
   * {@link LinearMetric}s try to consolidate local computations so that there
   * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
   * {@link #handleUpdates()}.
   */
  /*@Override*/
  public Metric min(Metric other) {
    final Store s = $getStore();
    if (other instanceof LinearMetric
        && other.$getStore().equals($getStore())) {
      LinearMetric that = (LinearMetric) other;

      // Get the combined sorted set of terms.
      Set/*<Metric>*/ termsBag = new TreeSet/*<>*/().fabric$util$TreeSet$();
      termsBag.addAll(Arrays.asList(this.terms));
      termsBag.addAll(Arrays.asList(that.terms));

      // Expand both matrices to account for terms that metric didn't
      // include.
      double[][] thisExpanded = new double[this.matrix.length][termsBag .size()];
      double[][] thatExpanded = new double[that.matrix.length][termsBag .size()];
      Metric[] newTerms = new Metric[termsBag.size()];
      int aggIdx = 0;
      int thisIdx = 0;
      int thatIdx = 0;
      Iterator iter = termsBag.iterator();
      while (iter.hasNext()) {
        Metric m = (Metric) iter.next();
        if (this.terms[thisIdx].equals(m)) {
          for (int i = 0; i < this.matrix[thisIdx].length; i++) {
            thisExpanded[aggIdx][i] = this.matrix[thisIdx][i];
          }
          thisIdx++;
        }
        if (that.terms[thatIdx].equals(m)) {
          for (int i = 0; i < that.matrix[thatIdx].length; i++) {
            thatExpanded[aggIdx][i] = that.matrix[thatIdx][i];
          }
          thatIdx++;
        }
        newTerms[aggIdx++] = m;
      }

      // Combined to include the sum of all pairs of rows between the two
      // expanded matrices
      double[][] combined = new double[thisExpanded.length
          + thatExpanded.length][newTerms.length];
      for (int i = 0; i < thisExpanded.length; i++) {
        for (int j = 0; j < combined[i].length; j++) {
          combined[i][j] = thisExpanded[i][j];
        }
      }
      for (int i = 0; i < thatExpanded.length; i++) {
        for (int j = 0; j < combined[i].length; j++) {
          combined[i + thisExpanded.length][j] = thatExpanded[i][j];
        }
      }

      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(combined, newTerms)/*)*/;
    } else if (Arrays.asList(terms).indexOf(other) >= 0) {
      int idx = Arrays.asList(terms).indexOf(other);
      double[][] newCs = new double[matrix.length + 1][terms.length];
      for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[i].length; j++) {
          newCs[i][j] = matrix[i][j];
        }
      }
      for (int j = 0; j < terms.length; j++) {
        newCs[matrix.length][j] = j == idx ? 1 : 0;
      }
      return /*getStore().findDerivedMetric(*/
          new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, terms)/*)*/;
    } else if (isSingleStore() && !other.$getStore().equals($getStore())) {
      return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(
          new double[][] { new double[]{ 1, 0 }, new double[]{ 0, 1 } }, new Metric[] { this, other })/*)*/;
    }

    Metric[] newTerms = new Metric[terms.length + 1];
    System.arraycopy(terms, 0, newTerms, 0, terms.length);
    newTerms[terms.length] = other;
    Arrays.sort(newTerms, 0, newTerms.length);
    int idx = Arrays.asList(newTerms).indexOf(other);
    double[][] newCs = new double[matrix.length + 1][terms.length + 1];
    for (int i = 0; i < newCs.length; i++) {
      for (int j = 0; j < newCs[i].length; j++) {
        if (j == idx) {
          newCs[i][j] = i < matrix.length ? 0 : 1;
        } else if (j > idx) {
          newCs[i][j] = i < matrix.length ? matrix[i][j - 1] : 0;
        } else {
          newCs[i][j] = i < matrix.length ? matrix[i][j] : 0;
        }
      }
    }
    return /*getStore().findDerivedMetric(*/
        new LinearMetric@s().fabric$metrics$LinearMetric$(newCs, newTerms)/*)*/;
  }

  /*@Override*/
  public DerivedMetric copyOn(Store s) {
    return /*s.findDerivedMetric(*/new LinearMetric@s().fabric$metrics$LinearMetric$(matrix, terms)/*)*/;
  }

  /*@Override*/
  public EnforcementPolicy policyFor(Bound bound) {
    Map/*<Metric, MetricContract>*/ witnesses = new HashMap/*<>*/();

    long currentTime = System.currentTimeMillis();
    double base = bound.rate * (currentTime - bound.startTime) + bound.base;
    double rate = bound.rate;

    // Defend all rows against the bound individually, using the strictest
    // bounds across the rows for each term in this sum.
    for (int i = 0; i < matrix.length; i++) {
      double totalValue = value(i);
      double totalVelocity = velocity(i);
      double totalNoise = noise(i);
      double numTerms = terms.length;

      // For each term, update the associated bounds to be the tightest
      // bound set across the rows
      for (int j = 0; j < numTerms; j++) {
        double c = matrix[i][j];
        Metric m = term(j);
        double scaledX = m.value() * c;
        double scaledV = m.velocity() * c;
        double scaledN = m.noise() * c * c;

        // Corrected for the way this metric is shifting relative to the
        // rest of the sum
        double r = scaledV - ((totalVelocity - rate) / numTerms);
        // De-scaled
        r /= c;

        double b = scaledX - ((scaledN / totalNoise) * (totalValue - base));
        // De-scaled
        b /= c;

        if (c < 0) {
          m = m.times(-1);
          b = -b;
          r = -r;
          Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(r, b, currentTime);
          if (!witnesses.containsKey(m) || !((MetricContract) witnesses.get(m)).getBound().implies(witnessBound)) {
            witnesses.put(m, m.getContract(witnessBound));
          }
        } else {
          Bound witnessBound = new Bound().fabric$metrics$contracts$Bound$(r, b, currentTime);
          if (!witnesses.containsKey(m) || !((MetricContract) witnesses.get(m)).getBound().implies(witnessBound)) {
            witnesses.put(m, m.getContract(witnessBound));
          }
        }
      }
    }
    return new WitnessPolicy().fabric$metrics$contracts$enforcement$WitnessPolicy$(witnesses.values());
  }

  /*@Override*/
  public int hashCode() {
    List/*<Object>*/ l = new ArrayList/*<>*/().fabric$util$ArrayList$(terms.length + 1);
    l.add($getStore());
    l.addAll(Arrays.asList(terms));
    return l.hashCode() * 32 + Arrays.deepHashCode(matrix);
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof LinearMetric) {
      LinearMetric that = (LinearMetric) other;
      return Arrays.deepEquals(this.matrix, that.matrix)
          && Arrays.deepEquals(this.terms, that.terms)
          && this.$getStore().equals(that.$getStore());
    }
    return false;
  }
}
