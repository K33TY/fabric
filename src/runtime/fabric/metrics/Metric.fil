package fabric.metrics;

import fabric.util.Collections;
import fabric.util.HashSet;
import fabric.util.Iterator;
import fabric.util.Set;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.util.Subject;
import fabric.metrics.util.Matrix;
import fabric.worker.Store;

/**
 * Represents an observable quantity that changes over time. Internally, this
 * class estimates the velocity of the observed quantity, and the interval
 * between updates. Instances of this class can be observed by
 * {@link LinearMetric}s and {@link MetricContract}s.
 */
public abstract class Metric extends Subject implements Comparable/*<Metric>*/ {

  protected Metric fabric$metrics$Metric$() {
    fabric$metrics$util$Subject$();
    return this;
  }

  private Set/*<MetricContract>*/ contracts = new HashSet/*<>*/();

  /** @return the current value of the quantity being measured. */
  public abstract double value();

  /** @return the estimated value of the measured quantity's velocity */
  public abstract double velocity();

  /**
   * @return the estimated value of the measured quantity's noise (the
   *       variance of the velocity estimate)
   */
  public abstract double noise();

  /**
   * @return true iff all the sampling and transformations on this metric are
   *       stored on a single store.
   */
  public abstract boolean isSingleStore();

  /**
   * @param bound
   *        a {@link Bound} we're checking the expected time to hit with
   *        this metric.
   * @return the time we expect to hit the bound, given the current velocity
   *       estimated.
   */
  public long expectedTimeToHit(Bound bound, long time) {
    double curVelocity = velocity();
    double adjustedRate = bound.rate - curVelocity;
    return (new Bound()).fabric$metrics$contracts$Bound$(adjustedRate, bound.base, bound.startTime).trueExpiry(this, time);
  }

  /**
   * @param bound
   *        the {@link Bound} that the contract will enforce on this
   *        {@link Metric}
   * @return a {@link MetricContract} asserting this metric satisfies the
   *       given {@link Bound}.
   */
  protected abstract MetricContract createContract(Bound bound);

  /**
   * @param time
   *        the time we're searching for {@link MetricContract}s for this
   *        {@link Metric}
   * @return a {@link Set} of {@link MetricContract}s that are currently
   *       enforced for this {@link Metric}
   */
  protected Set/*<MetricContract>*/ getContracts(long time) {
    Iterator cIter = (new HashSet/*<>*/()).fabric$util$HashSet$(contracts).iterator();
    while (cIter.hasNext()) {
      MetricContract c = (MetricContract) cIter.next();
      if (!c.valid(time) || !c.isObserved() || !c.isActive())
        contracts.remove(c);
    }
    return contracts;
  }

  /**
   * @param bound
   *        the {@link Bound} that the returned {@link MetricContract}
   *        will enforce on this {@link Metric}
   * @return a {@link MetricContract} which enforces that the metric satisfies
   *       a {@link Bound} that enforces the given {@link Bound}
   */
  public MetricContract getContract(Bound bound) {
    Iterator cIter = getContracts(System.currentTimeMillis()).iterator();
    while (cIter.hasNext()) {
      MetricContract existing = (MetricContract) cIter.next();
      if (existing.enforces(this, bound)) {
        return existing;
      }
    }
    MetricContract mc = createContract(bound);
    return mc;
  }

  /**
   * @param rate
   *        the rate parameter for the {@link Bound} on the resuling
   *        {@link MetricContract}
   * @param base
   *        the base parameter for the {@link Bound} on the resuling
   *        {@link MetricContract}
   * @param time
   *        the startTime parameter of the {@link Bound} on the resulting
   *        {@link MetricContract}
   * @return a {@link MetricContract} which enforces that the metric satisfies
   *       a {@link Bound} that enforces a {@link Bound} with the given
   *       parameters at the given time.
   */
  public MetricContract getContract(double rate, double base, long time) {
    return getContract((new Bound()).fabric$metrics$contracts$Bound$(rate, base, time));
  }

  /**
   * @param rate
   *        the rate parameter for the {@link Bound} on the resuling
   *        {@link MetricContract}
   * @param base
   *        the base parameter for the {@link Bound} on the resuling
   *        {@link MetricContract}
   * @return a {@link MetricContract} which enforces that the metric satisfies
   *       a {@link Bound} that enforces a {@link Bound} with the given
   *       parameters at the current time.
   */
  public MetricContract getContract(double rate, double base) {
    return getContract((new Bound()).fabric$metrics$contracts$Bound$(rate, base, System.currentTimeMillis()));
  }

  /**
   * @param contract
   *        a {@link MetricContract} to store with this {@link Metric}
   * @throws IllegalArgumentException
   *         if contract isn't defined on this {@link Metric}
   */
  public void addContract(MetricContract contract) {
    if (!contract.getMetric().equals(this))
      throw new IllegalArgumentException(
          "Adding a contract for a different metric!");
    contracts.add(contract);
  }

  /**
   * Dumb hack to allow us to get at a map on the store for avoiding duplicated
   * (inconsistent) metric computations being distributed.
   */
  public static DerivedMetric findDerivedMetric(Store s, DerivedMetric m) {
    if (s.derivedMap().get(m.toString()) == null)
      s.derivedMap().put(m.toString(), m);
    else
      m.cleanup();
    return (DerivedMetric) s.derivedMap().get(m.toString());
  }

  /**
   * @param scalar
   *        a double scalar to scale this metric by
   * @return A {@link LinearMetric} that tracks the scaled value of this
   *       {@link Metric}
   */
  public Metric times(double scalar) {
    final Store thisStore = $getStore();
    return findDerivedMetric($getStore(),
        new LinearMetric@thisStore().fabric$metrics$LinearMetric$(
          Matrix.constant(1, 1, scalar), new Metric[] { this }));
  }

  /**
   * @param other
   *        another {@link Metric} to add with this {@link Metric},
   *        element wise.
   * @return a {@link LinearMetric} that tracks the value of the sum of other
   *       and this
   */
  public Metric plus(Metric other) {
    // Ugh dumb hack
    if (other instanceof DerivedMetric)
      return other.plus(this);
    final Store thisStore = $getStore();
    return findDerivedMetric($getStore(),
        new LinearMetric@thisStore().fabric$metrics$LinearMetric$(
          Matrix.constant(1, 2, 1), new Metric[]{ this, other}));
  }

  /**
   * @param other
   *        another {@link Metric} to take the minimum of along with this
   *        {@link Metric}
   * @return a {@link LinearMetric} that tracks the value of the minimum of
   *       other and this's entries.
   */
  public Metric min(Metric other) {
    // Ugh dumb hack
    // XXX: TODO: What's the difference between min and and?
    if (other instanceof DerivedMetric)
      return other.min(this);
    if (this.equals(other))
      return this;
    final Store thisStore = $getStore();
    return findDerivedMetric($getStore(),
        new LinearMetric@thisStore().fabric$metrics$LinearMetric$(
          Matrix.identity(2), new Metric[]{ this, other }));
  }

  public static Metric scaleAtStore(final Store s, double a, Metric m) {
    if (m.$getStore().equals(s))
      return m.times(a);
    return findDerivedMetric(s, new LinearMetric@s().fabric$metrics$LinearMetric$(
          Matrix.constant(1, 1, a), new Metric[] { m }));
  }

  public static Metric addAtStore(final Store s, Metric[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Need at least one metric to sum!");
    if (terms.length == 1)
      return scaleAtStore(s, 1, terms[0]);
    return findDerivedMetric(s, new LinearMetric@s().fabric$metrics$LinearMetric$(
          Matrix.constant(1, terms.length, 1), terms));
  }

  public static Metric minAtStore(final Store s, Metric[] terms) {
    if (terms.length == 0)
      throw new IllegalArgumentException("Need at least one metric to min!");
    if (terms.length == 1)
      return scaleAtStore(s, 1, terms[0]);
    return findDerivedMetric(s, new LinearMetric@s().fabric$metrics$LinearMetric$(
          Matrix.identity(terms.length), terms));
  }

  /**
   * @param other
   *        another {@link Metric} to take the maximum of along with this
   *        {@link Metric}
   * @return a {@link LinearMetric} that tracks the value of the maximum of
   *       other and this's entries.
   */
  public Metric max(Metric other) {
    return (this.times(-1).min(other.times(-1))).times(-1);
  }

  /**
   * Allows for sorting {@link Metric}s to help with normalizing
   * {@link DerivedMetric}s.
   */
  /*@Override*/
  public int compareTo(/*Metric*/ java.lang.Object other) {
    return toString().compareTo(other.toString());
  }
}
