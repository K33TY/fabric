package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.List;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.util.Observer;
import fabric.metrics.util.RunningStats;
import fabric.worker.Store;

import fabric.worker.transaction.TransactionManager;

/**
 * Takes measurements of a persistent value of the parameter type T. When
 * constructed, the programmer provides a custom function for converting the
 * value to a double (the measurement) as well as a pointer to the value being
 * tracked.
 * <p>
 * In a transaction which has written the value being measured,
 * {@link #takeSample(double,long)} must be called to ensure that
 * {@link Observer}s of this {@link Metric} are aware of the change and the
 * transaction context performs the proper book-keeping.
 */
public class SampledMetric extends AbstractMetric {

  private final String name;

  /**
   * @param store
   *        the Store that holds this {@link Metric}
   * @param name
   *        the name the store associates with this {@link SampledMetric}
   * @param init
   *        the initial value of this {@link Metric}
   */
  public SampledMetric fabric$metrics$SampledMetric$(String name, double init) {
    this.name = name;
    fabric$metrics$AbstractMetric$();
    this.valueCell = new double[] { init };
    this.lastUpdate = new long[] { -1l };
    this.biasStats = new RunningStats().fabric$metrics$util$RunningStats$(0);
    this.updateIntervalStats = new RunningStats().fabric$metrics$util$RunningStats$(1.0);
    this.allStats = new RunningStats().fabric$metrics$util$RunningStats$(0);
    return this;
  }

  /**
   * Update to a new value of the metric.
   *
   * @param sample
   *        the value the metric is updating to.
   * @param time
   *        the time the sample occurred.
   */
  public void takeSample(double sample, long time) {
    if (valueCell[0] != sample) {
      updateEstimates(sample, time);
      valueCell[0] = sample;
      TransactionManager.getInstance().registerSample(this);
    }
  }

  /*@Override*/
  public double value() {
    return valueCell[0];
  }

  /*@Override*/
  public double velocity() {
    return biasStats.getMean() / updateIntervalStats.getMean();
    // return allStats.getMean();
  }

  /*@Override*/
  public double noise() {
    // Based on ratio estimator approach and assuming that there's 0
    // covariance between update intervals and update values
    double tSqrd = updateIntervalStats.getMean()
        * updateIntervalStats.getMean();
    double bSqrd = biasStats.getMean() * biasStats.getMean();
    // We're assuming exponential distribution of the times and here we get
    // the variance of the product of independent poisson (1/exp) and
    // normally distributed variables.
    return (1 / updateIntervalStats.getMean() + biasStats.getVar() / tSqrd);
    // Commented out: Just use the directly measured variance.
    // return allStats.getVar();
  }

  /*@Override*/
  public String toString() {
    return "SampledMetric(" + name + ")@" + getStore().name();
  }

  /*@Override*/
  public boolean isSingleStore() {
    return true;
  }

  /**
   * The current measurement.
   *
   * In Fabric we're using an array so that updates don't create write locks on
   * the SampledMetric itself, but instead on the value cell.  This avoids
   * unnecessary aborts when reading this object to create a derived metric
   * (without computing the value for it).
   */
  protected final double[] valueCell;

  /**
   * The time of the last update to this measure, in milliseconds since the
   * UNIX epoch.
   *
   * In Fabric we're using an array so that updates don't create write locks on
   * the SampledMetric itself, but instead on the last update cell.  This avoids
   * unnecessary aborts when reading this object to create a derived metric
   * (without computing the value for it).
   */
  protected final long[] lastUpdate;

  /**
   * The statistics of update magnitudes for this measure. This is computed as
   * an exponentially weighted moving average.
   */
  protected final RunningStats biasStats;

  /**
   * The estimated time interval between updates, in milliseconds. This is
   * computed as an exponentially weighted moving average.
   */
  protected final RunningStats updateIntervalStats;

  /**
   * Directly measured stats.
   */
  protected final RunningStats allStats;

  /**
   * Updates the velocity and interval estimates with the given observation.
   *
   * @param newVal
   *        the new value of the measured quantity
   * @param eventTime
   *        the time, in milliseconds, this update happened
   */
  protected void updateEstimates(double newVal, long eventTime) {
    biasStats.update(newVal - valueCell[0]);
    updateIntervalStats.update(eventTime - lastUpdate[0]);
    allStats.update((newVal - valueCell[0]) / (eventTime - lastUpdate[0]));
    lastUpdate[0] = eventTime;
  }

  /*@Override*/
  public int hashCode() {
    return getStore().hashCode() * 32 + name.hashCode();
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof SampledMetric) {
      SampledMetric that = (SampledMetric) other;
      return this.name.equals(that.name)
          && this.getStore().equals(that.getStore());
    }
    return false;
  }
}
