package fabric.metrics;

import fabric.util.ArrayList;
import fabric.util.List;

import fabric.metrics.util.Observer;
import fabric.metrics.util.RunningStats;

import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;

/**
 * A {@link Metric} that is directly updated by applications with new sample
 * values to use for its value.
 * <p>
 * In a transaction which has written the value being measured,
 * {@link #takeSample(double,long)} must be called to ensure that
 * {@link Observer}s of this {@link Metric} are aware of the change and the
 * transaction context performs the proper book-keeping.
 */
public class SampledMetric extends Metric {

  private final String name;

  /**
   * @param store
   *            the {@link Store} that holds this {@link Metric}
   * @param name
   *            the name the {@link Store} associates with this
   *            {@link SampledMetric}, so it can be easily retrieved later
   * @param init
   *        the initial value of this {@link Metric}
   */
  public SampledMetric fabric$metrics$SampledMetric$(String name, double init) {
    Label lbl = LabelUtil.noComponents();
    Store s = $getStore();
    this.name = name;
    this.value = new double[1] ~lbl @s;
    this.value[0] = init;
    this.lastUpdate = new long[1] ~lbl @s;
    this.lastUpdate[0] = -1l;
    this.biasStats = new RunningStats().fabric$metrics$util$RunningStats$(0);
    this.updateIntervalStats = new RunningStats().fabric$metrics$util$RunningStats$(1.0);
    this.allStats = new RunningStats().fabric$metrics$util$RunningStats$(0);
    fabric$metrics$Metric$();
    return this;
  }

  /**
   * Update to a new value of the metric. The sample is assumed to be taken at
   * the time of the call.
   *
   * @param sample
   *        the value the metric is updating to.
   */
  public void takeSample(double sample) {
    takeSample(sample, System.currentTimeMillis());
  }

  /**
   * Update to a new value of the metric.
   *
   * @param sample
   *        the value the metric is updating to.
   * @param time
   *        the time the sample occurred.
   */
  public void takeSample(double sample, long time) {
    if (value[0] != sample) {
      updateEstimates(sample, time);
      value[0] = sample;
      TransactionManager.getInstance().registerSample(this);
    }
  }

  /*@Override*/
  public double value(boolean useWeakCache) {
    return value[0];
  }

  /*@Override*/
  public double velocity(boolean useWeakCache) {
    return biasStats.getMean() / updateIntervalStats.getMean();
    // return allStats.getMean();
  }

  /*@Override*/
  public double noise(boolean useWeakCache) {
    // Based on ratio estimator approach and assuming that there's 0
    // covariance between update intervals and update values
    double tSqrd = updateIntervalStats.getMean()
        * updateIntervalStats.getMean();
    // double bSqrd = biasStats.getMean() * biasStats.getMean();
    // We're assuming exponential distribution of the times and here we get
    // the variance of the product of independent poisson (1/exp) and
    // normally distributed variables.
    return (1 / updateIntervalStats.getMean() + biasStats.getVar() / tSqrd);
    // Commented out: Just use the directly measured variance.
    // return allStats.getVar();
  }

  /*@Override*/
  public String toString() {
    return "SampledMetric(" + name + ")@" + getStore().name();
  }

  /*@Override*/
  public boolean isSingleStore() {
    return true;
  }

  /**
   * The current measurement. (Stored as an array to avoid unnecessary
   * conflicts.)
   */
  protected final double[] value;

  /**
   * The time of the last update to this measure, in milliseconds since the
   * UNIX epoch. (Stored as an array to avoid unnecessary conflicts.)
   */
  protected final long[] lastUpdate;

  /**
   * The statistics of update magnitudes for this measure. This is computed as
   * an exponentially weighted moving average.
   */
  protected final RunningStats biasStats;

  /**
   * The estimated time interval between updates, in milliseconds. This is
   * computed as an exponentially weighted moving average.
   */
  protected final RunningStats updateIntervalStats;

  /**
   * Directly measured stats.
   */
  protected final RunningStats allStats;

  /**
   * Updates the velocity and interval estimates with the given observation.
   *
   * @param newVal
   *        the new value of the measured quantity
   * @param eventTime
   *        the time, in milliseconds, this update happened
   */
  protected void updateEstimates(double newVal, long eventTime) {
    biasStats.update(newVal - value[0]);
    updateIntervalStats.update(eventTime - lastUpdate[0]);
    allStats.update((newVal - value[0]) / (eventTime - lastUpdate[0]));
    lastUpdate[0] = eventTime;
  }

  /*@Override*/
  public int hashCode() {
    return getStore().hashCode() * 32 + name.hashCode();
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof SampledMetric) {
      SampledMetric that = (SampledMetric) other;
      return this.name.equals(that.name)
          && this.getStore().equals(that.getStore());
    }
    return false;
  }

  /*@Override*/
  protected double computeValue(boolean useWeakCache) {
    return value();
  }

  /*@Override*/
  protected double computeVelocity(boolean useWeakCache) {
    return velocity();
  }

  /*@Override*/
  protected double computeNoise(boolean useWeakCache) {
    return noise();
  }
}
