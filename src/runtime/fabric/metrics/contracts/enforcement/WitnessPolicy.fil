package fabric.metrics.contracts.enforcement;

import fabric.util.Arrays;

import fabric.metrics.contracts.Contract;
import fabric.metrics.contracts.MetricContract;
import fabric.worker.transaction.TransactionManager;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

/**
 * An {@link EnforcementPolicy} which enforces a {@link MetricContract} by
 * relying on a set of <em>witnesses</em>, other {@link MetricContract}s that in
 * conjunction imply the enforced {@link MetricContract}.
 */
public class WitnessPolicy extends EnforcementPolicy {

  /** The set of {@link MetricContract}s used to enforce this policy. */
  public final MetricContract[] witnesses;

  /** The currently associated expiration based on the witnesses. */
  private long expiry;

  /** Is this currently actively enforced? */
  private boolean activated;

  /**
   * @param witnesses
   *        the array of {@link MetricContract}s used to enforce this
   *        policy. If any of the witnesses weren't already active, they
   *        are {@link Contract#activate() activated} here.
   */
  public WitnessPolicy fabric$metrics$contracts$enforcement$WitnessPolicy$(MetricContract[] witnesses) {
    fabric$metrics$contracts$enforcement$EnforcementPolicy$();
    this.witnesses = new MetricContract[witnesses.length];
    Arrays.arraycopy(witnesses, 0, this.witnesses, 0, witnesses.length);
    this.expiry = -1;
    this.activated = false;
    return this;
  }

  /*@Override*/
  public void activate() {
    atomic {
      if (activated)
        return;
    }
    refresh();
  }

  private class Activator implements Callable {
    final MetricContract w;

    public Activator fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(MetricContract w) {
      this.w = w;
      fabric$lang$Object$();
      return this;
    }

    public java.lang.Object call() {
      w.activate();
      return null;
    }
  }

  /*@Override*/
  public void refresh() {
    boolean atLeastOnce = false;
    if (TransactionManager.getInstance().getCurrentLog() != null) {
      for (int i = 0; i < witnesses.length; i++) {
        witnesses[i].activate();
      }
    } else {
      ExecutorService service = Executors.newFixedThreadPool(witnesses.length);
      Future native[] futures = new Future native[witnesses.length];
      // First, refresh the subterm stats.
      for (int i = 0; i < futures.length; i++) {
          // TODO: Add remote worker to call
          final MetricContract w = witnesses[i];
          Callable c = null;
          atomic {
            c = new Activator().fabric$metrics$contracts$enforcement$WitnessPolicy$Activator$(w);
          }
          futures[i] = service.submit(c);
      }
      service.shutdown();
      for (int i = 0; i < futures.length; i++) {
        try {
          futures[i].get();
        } catch (ExecutionException e) {
          // TODO: Log this if it happens.
        } catch (InterruptedException e) {
          // TODO: Log this if it happens.
        }
      }
    }
    atomic {
      for (int i = 0; i < witnesses.length; i++) {
        if (!atLeastOnce || witnesses[i].getExpiry() < expiry) {
          atLeastOnce = true;
          expiry = witnesses[i].getExpiry();
        }
      }
      activated = true;
    }
  }

  /*@Override*/
  public long expiry() {
    return expiry;
  }

  /*@Override*/
  public void apply(MetricContract mc) {
    if (!activated)
      activate();
    for (int i = 0; i < witnesses.length; i++) {
      witnesses[i].addObserver((fabric.metrics.util.Observer) mc.fetch());
    }
  }

  /*@Override*/
  public void unapply(MetricContract mc) {
    for (int i = 0; i < witnesses.length; i++) {
      witnesses[i].removeObserver(mc);
    }
  }

  /*@Override*/
  public String toString() {
    return Arrays.deepToString(witnesses);
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (!(other instanceof WitnessPolicy))
      return false;
    WitnessPolicy that = (WitnessPolicy) other;
    return this.witnesses.equals(that.witnesses);
  }
}
