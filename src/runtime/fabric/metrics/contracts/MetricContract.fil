package fabric.metrics.contracts;

import fabric.util.Collections;
import fabric.util.Set;

import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.DerivedMetric;
import fabric.metrics.Metric;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;

/**
 * A contract asserting that a {@link Metric}'s value is above or below a
 * vectorized boundary expression <code>r⃗ * (t - startTime) + b⃗</code> until
 * the associated expriation time.
 * <p>
 * This class follows the subject-observer pattern. An instance is an observer
 * of either a {@link Metric} or a set of {@link MetricContract}s and can be
 * observed by other {@link Contract}s.
 */
public abstract class MetricContract extends Contract {

  protected /*final*/ Metric metric;
  protected /*final*/ Bound bound;
  protected EnforcementPolicy currentPolicy;

  /**
   * @param metric
   *        the {@link Metric} this contract asserts a bound on
   * @param bound
   *        the {@link Bound} this {@link MetricContract} asserts on
   *        metric.
   */
  public MetricContract fabric$metrics$contracts$MetricContract$(Metric metric, Bound bound) {
    this.metric = metric;
    this.bound = new Bound().fabric$metrics$contracts$Bound$(bound.rate, bound.base, 0);
    fabric$metrics$contracts$Contract$();
    return this;
  }

  /** @return the {@link Metric} that this contract observes. */
  public Metric getMetric() {
    return metric;
  }

  /** @return the {@link Bound} that this contract observes. */
  public Bound getBound() {
    return bound;
  }

  /**
   * @return the expected lifetime of this {@link MetricContract} given the
   *       associated {@link Metric}s current velocity.
   */
  public long getExpectedLifetime() {
    return getMetric().expectedTimeToHit(getBound(), System.currentTimeMillis());
  }

  /*@Override*/
  public void activate() {
    fabric.common.Logging.METRICS_LOGGER.fine("ASDF ACTIVATING MC " + $getOnum());
    atomic {
      if (isActive())
        return;
    }

    EnforcementPolicy startPol = null;
    // Determine children
    atomic {
      fabric.common.Logging.METRICS_LOGGER.fine("ASDF POLICY FOR MC " + $getOnum());
      if (metric.isSingleStore()) {
        // Doesn't matter what it is, if it's on a single store, just go
        // with a direct enforcement policy.
        startPol = directStrategy();
      } else {
        // Otherwise use whatever's the best way to split things up.
        startPol = enforcementStrategy();
      }
    }

    // Activate new children
    startPol.activate();

    // Set the expiry and free it up
    atomic {
      fabric.common.Logging.METRICS_LOGGER.fine("ASDF DONE ACTIVATING MC " + $getOnum());
      currentPolicy = startPol;
      $expiry = currentPolicy.expiry();
      super.activate();
      currentPolicy.apply(this);
      getMetric().addContract(this);
    }
    fabric.common.Logging.METRICS_LOGGER.fine("ASDF FINISHED ACTIVATING MC " + $getOnum());
  }

  /**
   * Update this contract's expiration time to stay valid in response to a
   * change in the value of the {@link Subject}s used for enforcing this
   * {@link Contract}. Revokes, extends, and updates the enforcement strategy
   * as needed.
   */
  /*@Override*/
  protected boolean refresh(boolean force) {
    // If we haven't activated yet, this is a bad operation.  Stop.
    if (!isActive()) {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT INACTIVE");
      return false;
    }

    // If we're forcing this or couldn't make the old policy work, check the
    // actual bound and if it's up to date find a fresh policy
    long currentTime = System.currentTimeMillis();
    EnforcementPolicy oldPolicy = currentPolicy;
    if (bound.test(metric, currentTime)) {
      // Refresh the current policy and update to the new expiration time
      // if it's long enough.
      if (currentPolicy != null) {
        currentPolicy.refresh();
        if (currentPolicy.expiry() >= currentTime) {
          fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT REFRESHED");
          return update(currentPolicy.expiry());
        }
      }

      // Otherwise find a new one.
      EnforcementPolicy newPolicy;
      if (metric.isSingleStore()) {
        // Doesn't matter what it is, if it's on a single store, just go
        // with a direct enforcement policy.
        newPolicy = directStrategy();
      } else {
        // Otherwise use whatever's the best way to split things up.
        newPolicy = enforcementStrategy();
      }

      // Wait to unapply so that metric is still tracked if this was
      // directly enforced previously
      if (oldPolicy != null && !oldPolicy.equals(newPolicy))
        oldPolicy.unapply(this);
      currentPolicy = newPolicy;
      currentPolicy.activate();
      currentPolicy.apply(this);
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT TRUE");
      return update(currentPolicy.expiry());
    } else {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT FALSE");
      if (oldPolicy != null)
        oldPolicy.unapply(this);
      return update(0);
    }
  }

  /**
   * Check if this implies another {@link MetricContract} being considered.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link MetricContract} would
   *        assert a bound on
   * @param otherBound
   *        the {@link Bound} that would be used by the other
   *        {@link MetricContract}
   * @return true iff this would imply (and therefore) can enforce another
   *       {@link MetricContract} with the given metric and bound.
   */
  public boolean implies(Metric otherMetric, Bound otherBound) {
    if (!getMetric().equals(otherMetric) || !bound.implies(otherBound))
      return false;
    return valid(System.currentTimeMillis());
  }

  /**
   * Check if this implies the other {@link MetricContract}.
   *
   * @param other
   *        the other {@link MetricContract} this is being compared with
   * @return true iff this would imply (and therefore) can enforce other for
   *       the entire duration of other.
   */
  public boolean implies(MetricContract other) {
    return valid(other.getExpiry())
        && implies(other.getMetric(), other.getBound());
  }

  /**
   * Check if this enforces the <strong>same</strong> bound as another
   * {@link MetricContract} being considered. Attempts to refresh this
   * contract if it's gone stale and would otherwise enforce the bound.
   *
   * @param otherMetric
   *        the {@link Metric} the other {@link MetricContract} would
   *        assert a bound on
   * @param otherBound
   *        the {@link Bound} that would be used by the other
   *        {@link MetricContract}
   * @return true iff this enforces another {@link MetricContract} with the
   *       given parameters.
   */
  public boolean enforces(Metric otherMetric, Bound otherBound) {
    if (!getMetric().equals(otherMetric) || !bound.equals(otherBound))
      return false;
    return valid(System.currentTimeMillis());
  }

  /*@Override*/
  public String toString() {
    return getMetric().toString() + " " + bound + " until " + getExpiry();
  }

  /**
   * Given the current transaction context's view of the system state, return
   * a new {@link EnforcementPolicy} to enforce this {@link MetricContract}.
   *
   * @return The {@link EnforcementPolicy} to use for this
   *       {@link MetricContract} after the call completes.
   */
  protected abstract EnforcementPolicy enforcementStrategy();

  protected EnforcementPolicy directStrategy() {
    final Store s = getStore();
    return new DirectPolicy@s().fabric$metrics$contracts$enforcement$DirectPolicy$(this);
  }

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    Metric m = getMetric();
    if (m instanceof SampledMetric) {
      return Collections.singleton((SampledMetric) m);
    } else if (m instanceof DerivedMetric) {
      return ((DerivedMetric) m).getLeafSubjects();
    } else {
      throw new IllegalStateException(
          "All metrics should be either sampled or derived!");
    }
  }

  /*@Override*/
  public void deactivate() {
    atomic {
      if (!isObserved()) {
        if (currentPolicy != null)
          currentPolicy.unapply(this);
      }
      super.deactivate();
    }
  }
}
