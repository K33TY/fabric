package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.util.NodeTime;

import fabric.worker.Store;

/**
 * A Bound is a linear time-varying bound compared with a {@link Metric} for a
 * {@link MetricContract} of <code>r⃗ * (t - startTime) + b⃗</code>.
 */
public class Bound {

  public /*final*/ double rate;
  public /*final*/ double base;
  public /*final*/ NodeTime startTime;

  /**
   * @param rate
   *        the rate the value changes with time
   * @param base
   *        the value of the bound associated with startTime
   * @param startTime
   *        the time this bound's value is computed relative to
   */
  public Bound fabric$metrics$contracts$Bound$(double rate, double base, NodeTime startTime) {
    this.rate = rate;
    this.base = base;
    this.startTime = startTime;
    fabric$lang$Object$();
    return this;
  }

  /**
   * @param rate
   *        the rate the value changes with time
   * @param base
   *        the value of the bound associated with startTime
   * @param startTime
   *        the time this bound's value is computed relative to
   */
  public Bound fabric$metrics$contracts$Bound$(double rate, double base, long startTime) {
    this.rate = rate;
    this.base = base;
    this.startTime = new NodeTime().fabric$metrics$util$NodeTime$(startTime);
    fabric$lang$Object$();
    return this;
  }

  /**
   * @param time
   *        the time we're computing the bound value for
   * @return the value of the bound at the given time
   */
  public double value(NodeTime time) {
    return rate * (time.time - startTime.lowerBound()) + base;
  }

  /**
   * @param time
   *        the time we're computing the bound value for
   * @return the value of the bound at the given time
   */
  public double value(long time) {
    return value(new NodeTime().fabric$metrics$util$NodeTime$(time));
  }

  /**
   * @param m
   *        a {@link Metric} we're testing this bound on
   * @param time
   *        the time this bound is being applied to m
   * @return true iff m's current value satisfies the bound at the given time.
   */
  public boolean test(Metric m, long time) {
    return test(m.value(), time);
  }

  /**
   * @param x
   *        a vector of doubles we're testing this bound on
   * @param time
   *        the time this bound is being applied to m
   * @return true iff x satisfies the bound at the given time.
   */
  public boolean test(double x, long time) {
    return x >= value(time);
  }

  /**
   * @param metric
   *        the {@link Metric} we're finding the true expiry for
   * @param time
   *        the time we're running this calculation relative to
   * @return the "true expiry" of this bound for the given {@link Metric}, the
   *       time at which point the bound would no longer be satisfied by the
   *       {@link Metric}'s current value.
   */
  public long trueExpiry(Metric metric, long time) {
    return trueExpiry(metric.value(), time);
  }

  /**
   * @param value
   *        the current value we're finding the true expiry for
   * @param time
   *        the time we're running this calculation relative to
   * @return the "true expiry" of this bound for the given value, the time at
   *       which point the bound would no longer be satisfied by the value.
   */
  public long trueExpiry(double value, long time) {
    if (rate > 0) {
      return (long) (time + (value - value(time)) / rate);
    } else if (value < value(time)) {
      return 0;
    }
    return Long.MAX_VALUE;
  }

  /**
   * @param other
   *        another {@link Bound}
   * @return true iff this is at least as strong of a bound as other
   */
  public boolean implies(Bound other) {
    return rate >= other.rate && value(other.startTime) >= other.base;
  }

  /**
   * @param newStartTime
   *        a new time to use as a startTime in the returned {@link Bound}
   * @return an equivalent {@link Bound} with the startTime set to
   *       newStartTime
   */
  public Bound shifted(long newStartTime) {
    final Store s = $getStore();
    return (new Bound@s()).fabric$metrics$contracts$Bound$(rate, value(newStartTime), newStartTime);
  }

  /*@Override*/
  public boolean equals(Object o) {
    if (o instanceof Bound) {
      Bound other = (Bound) o;
      return rate == other.rate && value(other.startTime) == other.base;
    }
    return false;
  }

  /*@Override*/
  public String toString() {
    return ">= " + rate + " * (t - " + startTime + ") + " + base;
  }
}
