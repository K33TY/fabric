package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.util.AbstractSubject;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;
import fabric.util.Iterator;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;

/**
 * A {@link Contract} consists of an assertion and an expiration time. If the
 * current time is earlier than the expiration time, then the contract is
 * <i>valid</i>: the enforcement protocol will ensure the assertion holds.
 * <p>
 * This class follows the subject-observer pattern. An instance can be an
 * observer of a {@link Metric} or other {@link Contract}s, and can be observed
 * by other {@link Contract}s.
 */
public abstract class Contract extends AbstractSubject implements Observer {

  protected Contract fabric$metrics$contracts$Contract$() {
    fabric$metrics$util$AbstractSubject$();
    this.$expiry = -1;
    return this;
  }

  // The proportional amount of time an extension has to improve over the
  // current expiry for us to bother advertising it.
  // Note: larger value => less aggressive extensions => lower overhead
  // Note: smaller value => more aggressive extensions => less chance of a
  // warranty going stale unecessarily.
  public static final double MIN_EXTENSION_FACTOR = 1;
  //public static final double MIN_EXTENSION_FACTOR = 1.05;
  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  public static final long DRIFT_FACTOR = 100;

  /**
   * Extends the expiration time.
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry) {
    TransactionManager tm = TransactionManager.getInstance();
    long currentTime = System.currentTimeMillis();
    // Only bother advertising if it's better than our current expiry
    // by the buffer amount or if we're close to the current expiration.
    if (newExpiry > currentTime
            + (MIN_EXTENSION_FACTOR * (getExpiry() - currentTime))) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        Observer parent = (Observer) iter.next();
        if (parent instanceof MetricContract) {
          tm.registerDelayedExtension((Contract) parent);
        }
      }
      fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "SYNCH EXTENSION");
      tm.registerExtension(this);
      $expiry = newExpiry;
    } else {
      // Wait until later to extend, we don't want to get too eager.
      fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "DELAYED EXTENSION");
      tm.registerDelayedExtension(this);
    }
  }

  private boolean activated = false;

  /**
   * @return true if this contract is currently active (enforced).
   */
  public boolean isActivated() {
    return activated;
  }

  /**
   * Activate and start enforcing this {@link Contract}.
   */
  public void activate() {
    atomic {
      if (!activated) {
        fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT ACTIVATE");
        activated = true;
      }
    }
  }

  /**
   * {@inheritDoc}
   *
   * Make stale and stop observing any evidence if this is no longer observed.
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
      atomic {
        super.removeObserver(obs);
        if (!isObserved()) {
            $expiry = -1;
        }
      }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * revoking as needed.
   *
   * @param newExpiry
   *        the new expiration time associated with this {@link Contract}.
   * @return true iff the contract was retracted by this update.
   */
  public boolean update(long newExpiry) {
    Worker localW = Worker.getWorker();
    // Account for possible drift between current location and the store.
    if (!localW.getStore(localW.getName()).equals(getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    if (getExpiry() < newExpiry - DRIFT_FACTOR) {
      // Only extend if everyone will see something better.
      extendTo(newExpiry);
      fabric.common.Logging.METRICS_LOGGER.fine("EXPIRY OF " + this + " IS NOW " + $expiry);
    } else if (getExpiry() > newExpiry) {
      // Revoke if doing worse than what anyone else would see.
      retract(newExpiry);
      fabric.common.Logging.METRICS_LOGGER.fine("EXPIRY OF " + this + " IS NOW " + $expiry);
      return true;
    }
    return false;
  }

  /**
   * Called to retract this contract's expiry in the current transaction
   * context.
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void retract(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "REVOCATION");
    TransactionManager.getInstance().registerRetraction(this);
    $expiry = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    return isActivated() && getExpiry() >= time;
  }

  /**
   * @return true iff the contract is valid at the given time in the current
   *         transaction context.
   */
  public boolean valid() {
    return isActivated() && getExpiry() >= System.currentTimeMillis();
  }

  /**
   * @param time
   *            the time we're checking against.
   * @return true iff the contract is stale according to the local time.
   */
  public boolean stale(long time) {
    return isActivated() && getExpiry() < time;
  }

  /**
   * @return true iff the contract is stale according to the local time.
   */
  public boolean stale() {
    return isActivated() && getExpiry() < System.currentTimeMillis();
  }

  public long getExpiry() {
    return $expiry - DRIFT_FACTOR;
  }

  /**
   * Update this contract's expiration time to stay valid in response to a
   * change in the value of the {@link Subject}s used for enforcing this
   * {@link Contract}. Revokes, extends, and updates the enforcement strategy
   * as needed.
   *
   * @param force
   *        flag indicating if a new policy should be found if the old one
   *        has expired.
   *
   * @return true iff the contract was retracted as a result of this
   *         operation.
   */
  protected abstract boolean refresh(boolean force);

  /*@Override*/
  public boolean handleUpdates() {
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CHECKING CONTRACT CHANGE");
    // Funny implication of this is that if something goes stale before it's
    // checked, it stays stale. Probably the right behavior?
    if (valid())
      return refresh(true);
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CONTRACT INVALID");
    return false;
  }

  public void attemptExtension_remote(fabric.lang.security.Principal caller) {
    atomic {
      // Ugh, need to add _remote suffix because it's expected by remote call
      // messages and is added by the fabric compiler.
      this.attemptExtension();
    }
  }

  public void attemptExtension() {
    fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "ASYNC EXTENSION");
    refresh(false);
  }
}
