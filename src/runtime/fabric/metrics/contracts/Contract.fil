package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;

/**
 * A {@link Contract} consists of an assertion and an expiration time. If the
 * current time is earlier than the expiration time, then the contract is
 * <i>valid</i>: the enforcement protocol will ensure the assertion holds.
 * <p>
 * This class follows the subject-observer pattern. An instance can be an
 * observer of a {@link Metric} or other {@link Contract}s, and can be observed
 * by other {@link Contract}s.
 */
public abstract class Contract extends Subject implements Observer {

  protected Contract fabric$metrics$contracts$Contract$() {
    fabric$metrics$util$Subject$();
    this.$expiry = -1;
    return this;
  }

  // The proportional amount of time an extension has to improve over the
  // current expiry for us to bother advertising it.
  // Note: larger value => less aggressive extensions => lower overhead
  // Note: smaller value => more aggressive extensions => less chance of a
  // warranty going stale unecessarily.
  public static final double MIN_EXTENSION_FACTOR = 1.5;
  // The maximum amount of time into the future to extend the expiry
  // Note: smaller value => less aggressive extensions => lower revocations
  // Note: larger value => longer extensions => less chatter
  public static final long MAX_EXTENSION = 1000;
  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  public static final long DRIFT_FACTOR = 50;

  /**
   * Extends the expiration time.
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry) {
    long currentTime = System.currentTimeMillis();
    long adjustedNewExpiry = Math.min(newExpiry, currentTime + MAX_EXTENSION);
    // Only bother advertising if it's better than our current expiry
    // by the buffer amount.
    if (adjustedNewExpiry > currentTime
        + (MIN_EXTENSION_FACTOR * (getExpiry() - currentTime))) {
      TransactionManager.getInstance().registerExtension(this);
    }
    final Store s = $getStore();
    $expiry = adjustedNewExpiry;
  }

  private boolean active = false;

  /**
   * @return true if this contract is currently active (enforced).
   */
  public boolean isActive() {
    return active;
  }

  /**
   * Activate and start enforcing this {@link Contract}.
   */
  public void activate() {
    if (!active) {
      fabric.common.Logging.METRICS_LOGGER.info("ACTIVATING " + this + " IN " + TransactionManager.getInstance().getCurrentTid());
      active = true;
      refresh();
    }
  }

  /**
   * Deactivate and stop observing any evidence.
   */
  public void deactivate() {
    if (!isObserved()) {
      fabric.common.Logging.METRICS_LOGGER.info("DEACTIVATING " + this + " IN " + TransactionManager.getInstance().getCurrentTid());
      active = false;
      $expiry = -1;
    }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * revoking as needed.
   *
   * @param newExpiry
   *        the new expiration time associated with this {@link Contract}.
   */
  public void update(long newExpiry) {
    Worker localW = Worker.getWorker();
    if (!localW.getStore(localW.getName()).equals($getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    if (getExpiry() < newExpiry) {
      // Only bother extending if we know everyone will see something
      // better.
      extendTo(newExpiry);
    } else if (getExpiry() > newExpiry) {
      // Only revoke if we're doing worse than whatever anyone else will
      // see.
      revoke(newExpiry);
    }
  }

  /**
   * Called to revoke this contract in the current transaction context.
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void revoke(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    markModified();
    fabric.common.Logging.METRICS_LOGGER.info("REVOKING " + this + " IN " + TransactionManager.getInstance().getCurrentTid());
    $expiry = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    if (!isActive())
      return false;
    //if (time > getExpiry().lowerBound())
    //  refresh();
    return getExpiry() > time;
  }

  public long getExpiry() {
    return $expiry;
  }

  /**
   * Update this contract's expiration time to stay valid in
   * response to a change in the value of the {@link Subject}s used
   * for enforcing this {@link Contract}. Revokes, extends, and
   * updates the enforcement strategy as needed.
   */
  protected abstract void refresh();

  /*@Override*/
  public void handleUpdates() {
    refresh();
  }
}
