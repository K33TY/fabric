package fabric.metrics.contracts;

import fabric.metrics.Metric;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;
import fabric.util.Iterator;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;

/**
 * A {@link Contract} consists of an assertion and an expiration time. If the
 * current time is earlier than the expiration time, then the contract is
 * <i>valid</i>: the enforcement protocol will ensure the assertion holds.
 * <p>
 * This class follows the subject-observer pattern. An instance can be an
 * observer of a {@link Metric} or other {@link Contract}s, and can be observed
 * by other {@link Contract}s.
 */
public abstract class Contract extends Subject implements Observer {

  private long lastAdvertised;

  protected Contract fabric$metrics$contracts$Contract$() {
    fabric$metrics$util$Subject$();
    this.$expiry = -1;
    this.lastAdvertised = -1;
    return this;
  }

  // The proportional amount of time an extension has to improve over the
  // current expiry for us to bother advertising it.
  // Note: larger value => less aggressive extensions => lower overhead
  // Note: smaller value => more aggressive extensions => less chance of a
  // warranty going stale unecessarily.
  public static final double MIN_EXTENSION_FACTOR = 2;
  // The maximum amount of time into the future to extend the expiry
  // Note: smaller value => less aggressive extensions => lower revocations
  // Note: larger value => longer extensions => less chatter
  public static final long MAX_EXTENSION = 5000;
  // The drift tolerance factor we'll subtract from times we advertise to
  // others.
  public static final long DRIFT_FACTOR = 100;

  /**
   * Extends the expiration time.
   *
   * @param newExpiry
   *        the new expiration time (computed at the current node) for
   *        this {@link Contract} given in milliseconds.
   */
  protected void extendTo(long newExpiry) {
    long currentTime = System.currentTimeMillis();
    // Only bother advertising if it's better than our current expiry
    // by the buffer amount.
    if (newExpiry > currentTime + (MIN_EXTENSION_FACTOR * (lastAdvertised - currentTime))) {
      for (Iterator iter = getObservers().iterator(); iter.hasNext();) {
        Observer o = (Observer) iter.next();
        if (o instanceof MetricContract) {
          TransactionManager.getInstance().registerExtension((Contract) o);
        }
      }
      lastAdvertised = newExpiry;
    }
    fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "SYNCH EXTENSION");
    $expiry = newExpiry;
  }

  private boolean active = false;

  /**
   * @return true if this contract is currently active (enforced).
   */
  public boolean isActive() {
    return active;
  }

  /**
   * Activate and start enforcing this {@link Contract}.
   */
  public void activate() {
    if (!active) {
      active = true;
      refresh();
    }
  }

  /**
   * Deactivate and stop observing any evidence.
   */
  public void deactivate() {
    if (!isObserved()) {
      active = false;
      $expiry = -1;
    }
  }

  /**
   * Updates the expiration time of this contract, either extending or
   * revoking as needed.
   *
   * @param newExpiry
   *        the new expiration time associated with this {@link Contract}.
   * @return true iff this contract was revoked.
   */
  public boolean update(long newExpiry) {
    Worker localW = Worker.getWorker();
    if (!localW.getStore(localW.getName()).equals(getStore()))
      newExpiry = newExpiry - DRIFT_FACTOR;
    long currentTime = System.currentTimeMillis();
    newExpiry = Math.min(newExpiry, currentTime + MAX_EXTENSION);
    if (getExpiry() < newExpiry) {
      // Only bother extending if we know everyone will see something
      // better.
      extendTo(newExpiry);
    } else if (getExpiry() > newExpiry) {
      // Only revoke if we're doing worse than whatever anyone else will
      // see.
      revoke(newExpiry);
      return true;
    }
    return false;
  }

  /**
   * Called to revoke this contract in the current transaction context.
   *
   * @param newExpiry
   *        time to set the expiry back to.
   */
  protected void revoke(long newExpiry) {
    // Mark this as modified, which needs to be resolved in this
    // transaction.
    fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "REVOCATION");
    $expiry = newExpiry;
    lastAdvertised = newExpiry;
  }

  /**
   * @param time
   *        the time we're checking validity against.
   * @return true iff the contract is valid at the given time in the current
   *       transaction context.
   */
  public boolean valid(long time) {
    if (!isActive())
      return false;
    //if (time > getExpiry().lowerBound())
    //  refresh();
    return getExpiry() > time;
  }

  public long getExpiry() {
    return $expiry - DRIFT_FACTOR;
  }

  /**
   * Update this contract's expiration time to stay valid in
   * response to a change in the value of the {@link Subject}s used
   * for enforcing this {@link Contract}. Revokes, extends, and
   * updates the enforcement strategy as needed.
   *
   * @return true iff the contract was retracted.
   */
  protected abstract boolean refresh();

  /*@Override*/
  public boolean handleUpdates() {
    if (isActive())
      return refresh();
    return false;
  }

  public void attemptExtension_remote(fabric.lang.security.Principal caller) {
    atomic {
      // Ugh, need to add _remote suffix because it's expected by remote call
      // messages and is added by the fabric compiler.
      this.attemptExtension();
    }
  }

  public void attemptExtension() {
    // Ugh, need to add _remote suffix because it's expected by remote call
    // messages and is added by the fabric compiler.
    fabric.common.Logging.METRICS_LOGGER.log(Level.INFO, "ASYNC EXTENSION");
    this.refresh();
  }
}
