package fabric.metrics.contracts.warranties;

import fabric.util.HashSet;
import fabric.util.Set;

import fabric.metrics.Metric;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.Observer;
import java.util.logging.Level;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  private final WarrantyValue/*<T>*/ curVal;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue/*<T>*/ updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   * @return A {@link WarrantyValue} which holds the return value and the
   * contract associated with it (guaranteed active when returned) that asserts
   * that the return value is consistent.
   */
  /*@Override*/
  public WarrantyValue/*T*/ apply(long time) {
    return static_apply(this, time);
  }

  private static WarrantyValue/*T*/ static_apply(WarrantyComp tmp, long time) {
    // TODO recompute but don't replace if current one is pending and we
    // compute the same value
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Starting " + tmp);
    boolean loop = false;
    atomic {
      loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
    }
    while (loop) {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Iterating " + tmp);

      WarrantyValue newVal = tmp.updatedVal(System.currentTimeMillis());
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Updating " + tmp + " to " + newVal);

      // If newVal's contract is null, this indicates that the programmer
      // doesn't want to memoize the result with a treaty.
      if (newVal.contract == null)
        return newVal;

      /* Commented out because API now expectes updatedVal to have run
       * refreshWeakEstimates before returning.
       *
       * Estimated here so that we don't repeat work on activations of sub
       * treaties.
       */
      //fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Estimating " + this);
      //curVal.contract.getMetric().refreshWeakEstimates();

      fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Activating " + newVal + " for " + tmp);
      RemoteWorker w = Worker.getWorker().getWorker(newVal.contract.$getStore().name());
      newVal.contract.activate_remote@w(null);

      fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Setting " + tmp + " to " + newVal + " and Observing");
      atomic {
        // Need to double check we weren't scooped by another caller.  If we
        // were, don't bother with our new value and go with the existing value.
        if (tmp.curVal.contract == null || !tmp.curVal.contract.valid()) {
          tmp.curVal.value = newVal.value;
          if (tmp.curVal.contract != newVal.contract) {
            if (tmp.curVal.contract != null) {
              tmp.curVal.contract.removeObserver(tmp);
            }
            tmp.curVal.contract = newVal.contract;
            tmp.curVal.contract.addObserver(tmp);
          }
        }
      }
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Updated to " + tmp.curVal);

      atomic {
        loop = tmp.curVal.contract == null || !tmp.curVal.contract.valid();
      }
    }
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINER, "Finished " + tmp + " with " + tmp.curVal);
    return tmp.curVal;
  }

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    // TODO: Is this right?
    if (curVal != null)
      return curVal.contract.getLeafSubjects();
    return new HashSet().fabric$util$HashSet$();
  }

  /*@Override*/
  public boolean handleUpdates() {
    // TODO: Is this right?
    long time = System.currentTimeMillis();
    return (curVal.contract == null || !curVal.contract.valid(time));
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    fabric$lang$Object$();
    this.curVal = new WarrantyValue().fabric$metrics$contracts$warranties$WarrantyValue$(null, null);
    return this;
  }
}
