package fabric.metrics.contracts.warranties;

import fabric.util.HashSet;
import fabric.util.Set;

import fabric.metrics.Metric;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.SampledMetric;
import fabric.metrics.util.Observer;
import java.util.logging.Level;

/**
 * A computation that uses {@link Contract}s to cache and reuse results.
 * <p>
 * Acts as an {@link Observer} of the currently associated {@link Contract}.
 * This helps to ensure that the {@link Contract} implying the currently cached
 * result is correct doesn't get deactivated prematurely by the API
 * implementation.
 */
public abstract class WarrantyComp/*<T>*/ implements /*LongFunction<T>,*/ Observer {

  /** The currently cached result. */
  private WarrantyValue/*<T>*/ curVal;

  /**
   * Create a new updated result paired with a contract that would enforce it
   * after this call.
   *
   * @param time
   *            the current time we're running a new update at.
   */
  protected abstract WarrantyValue/*<T>*/ updatedVal(long time);

  /**
   * Run this warranty computation at the given time.
   *
   * @param time
   *            the current time we're applying this computation at
   */
  /*@Override*/
  public Object/*T*/ apply(long time) {
    // TODO recompute but don't replace if current one is pending and we
    // compute the same value
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Starting " + this);
    boolean loop = false;
    atomic {
      loop = curVal == null || !curVal.contract.isActivated()
          || curVal.contract.stale(time);
    }
    while (loop) {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Iterating " + this);
      if (curVal != null) {
        curVal.contract.removeObserver(this);
      }

      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Updating " + this);
      WarrantyValue newVal = updatedVal(time);
      atomic {
        curVal = newVal;
      }

      // Estimated here so that we don't repeat work on activations of sub
      // treaties.
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Estimating " + this);
      curVal.contract.getMetric().refreshWeakEstimates();

      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Activating " + this);
      curVal.contract.activate();

      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Observing " + this);
      curVal.contract.addObserver(this);
      atomic {
        loop = curVal == null || !curVal.contract.isActivated()
            || curVal.contract.stale(time);
      }
    }
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "Finished " + this);
    return curVal.value;
  }

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    // TODO: Is this right?
    if (curVal != null)
      return curVal.contract.getLeafSubjects();
    return new HashSet().fabric$util$HashSet$();
  }

  /*@Override*/
  public boolean handleUpdates() {
    // TODO: Is this right?
    long time = System.currentTimeMillis();
    return (curVal != null && curVal.contract.valid(time)
          && curVal.value != apply(time));
  }

  protected WarrantyComp fabric$metrics$contracts$warranties$WarrantyComp$() {
    fabric$lang$Object$();
    return this;
  }
}
