package fabric.metrics.contracts.warranties;

import fabric.util.Collections;
import fabric.util.HashSet;
import fabric.util.Set;
import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;
import fabric.metrics.contracts.MetricContract;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;

/**
 * A Warranty (also known as a General Contract) is a time-limited assertion of
 * the form <code>f(...) = y</code> and is enforced by an associated metric
 * contract.
 */
public class Warranty/*<T>*/ extends Contract {

  public /*final*/ WarrantyComp/*<T>*/ computation;
  protected /*T*/ Object value;
  protected MetricContract witness;

  /**
   * @param computation
   *        the computation being warrantied.
   */
  public Warranty fabric$metrics$contracts$warranties$Warranty$(WarrantyComp/*<T>*/ computation) {
    this.computation = computation;
    fabric$metrics$contracts$Contract$();
    return this;
  }

  /*@Override*/
  protected boolean refresh(boolean force) {
    if (!force && witness != null && witness.valid(System.currentTimeMillis()))
      return false;
    // Policy is always to use the last returned witness while it's valid.
    // If we're forcing or don't have a witness (XXX does this happen?) or
    // the witness has since gone stale, recompute and update.
    long currentTime = System.currentTimeMillis();
    if (witness == null || !witness.valid(currentTime)) {
      WarrantyValue/*<T>*/ curVal = computation.apply(currentTime);
      if ((curVal.value == null && value != null)
              || (curVal.value != null && !curVal.value.equals(value))) {
        this.value = curVal.value;
      }
      if (witness != null && witness != curVal.contract) {
        witness.removeObserver(this);
        witness.deactivate();
      }
      witness = curVal.contract;
      witness.activate();
      witness.addObserver(this);
      return true;
    }
    return false;
  }

  /*@Override*/
  public long getExpiry() {
    if (witness != null && isActive())
      return witness.getExpiry();
    return -1;
  }

  /**
   * @return the current value of the computation this enforces (assuming the
   *       {@link Warranty} is currently valid).
   */
  public /*T*/ Object value() {
    TransactionManager.getInstance().resolveObservations();
    return this.value;
  }

  /*@Override*/
  public String toString() {
    return "Warranty " + computation + " = " + value + " until "
      + getExpiry();
  }

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    if (witness != null)
      return witness.getLeafSubjects();
    else
      //return Collections.EMPTY_SET;
      // Ugh if this works, I think we have a bug in EMPTY_SET/EMPTY_LIST etc.
      return new HashSet().fabric$util$HashSet$();
  }

  /*@Override*/
  public void activate() {
    atomic {
      if (isActive())
        return;
    }
    WarrantyValue/*<T>*/ curVal = null;
    MetricContract w = null;
    atomic {
      fabric.common.Logging.METRICS_LOGGER.fine("ASDF TRYING TO COMPUTE");
      long currentTime = System.currentTimeMillis();
      curVal = computation.apply(currentTime);
      w = curVal.contract;
    }
    fabric.common.Logging.METRICS_LOGGER.fine("ASDF ACTIVATING");
    w.activate();
    atomic {
      fabric.common.Logging.METRICS_LOGGER.fine("ASDF OBSERVING");
      this.value = curVal.value;
      witness = curVal.contract;
      witness.addObserver(this);
      super.activate();
    }
    fabric.common.Logging.METRICS_LOGGER.fine("ASDF ACTIVATE");
  }

  /*@Override*/
  public void deactivate() {
    atomic {
      if (!isObserved()) {
        if (witness != null) {
          witness.removeObserver(this);
          witness.deactivate();
        }
        value = null;
      }
      super.deactivate();
    }
  }
}
