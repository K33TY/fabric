package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Collections;
import fabric.util.Set;
import fabric.util.TreeSet;
import fabric.util.HashSet;
import fabric.util.Iterator;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

/**
 * General base class for {@link Metric}s built by computing over other
 * {@link Metrics}. Each {@link DerivedMetric} implementation is responsible for
 * defining how to
 * <ul>
 * <li>construct the {@link #value()}, {@link #velocity()}, and {@link #noise()}
 * from its terms</li>
 * <li>provide a {@link EnforcementPolicy} to enforce a
 * {@link DerivedMetricContract} on it given the {@link Bound}, typically using
 * a {@link WitnessPolicy} using {@link MetricContract}s on the terms it is
 * derived from.</li>
 * </ul>
 */
public abstract class DerivedMetric extends Metric implements Observer {
  /** Last computed value, velocity, and noise of the {@link DerivedMetric} */
  protected final double lastStats[];

  /**
   * The {@link Metric} terms that this {@link DerivedMetric} is computed
   * from.
   */
  protected final Metric[] terms;

  private final Set/*<SampledMetric>*/ leafMetrics;
  private final boolean singleStore;

  /**
   * @param s
   *        the {@link Store} this {@link DerivedMetric} will be stored on
   * @param terms
   *        the {@link Metric}s that this {@link DerivedMetric} is
   *        computed from
   */
  public DerivedMetric fabric$metrics$DerivedMetric$(Metric[] terms) {
    if (new TreeSet/*<>*/().fabric$util$TreeSet$(Arrays.asList(terms)).size() != terms.length)
      throw new IllegalArgumentException(
              "DerivedMetric terms must not contain duplicates: "
                      + Arrays.deepToString(terms));
    this.leafMetrics = new HashSet/*<>*/().fabric$util$HashSet$();
    boolean single = true;
    for (int i = 0; i < terms.length; i++) {
      if (!terms[i].isSingleStore()
            || !terms[i].$getStore().equals($getStore())) {
        single = false;
        break;
      }
    }
    this.singleStore = single;
    Label lbl = LabelUtil.noComponents();
    Store s = $getStore();
    this.terms = new Metric[terms.length] ~lbl @s;
    Arrays.arraycopy(terms, 0, this.terms, 0, terms.length);
    this.lastStats = new double[3] ~lbl @s;
    fabric$metrics$Metric$();
    return this;
  }

  /**
   * Method to be called at the end of a constructor for any subclass of
   * {@link DerivedMetric}. Ensures that the {@link getLeafSubjects()} result
   * is precomputed after the representation has been normalized.
   */
  protected void initialize() {
    for (int i = 0; i < terms.length; i++) {
      if (terms[i] instanceof SampledMetric) {
        leafMetrics.add(/*(SampledMetric)*/ terms[i]);
      } else if (terms[i] instanceof DerivedMetric) {
        leafMetrics.addAll(((DerivedMetric) terms[i]).getLeafSubjects());
      } else {
        throw new IllegalStateException(
            "This shouldn't happen, all metrics should either be a SampledMetric or a DerivedMetric!");
      }
    }
  }

  /*@Override*/
  public boolean handleUpdates() {
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CHECKING FOR UPDATE ON DERIVED METRIC");
    double newValue = computeValue(false);
    if (newValue != lastStats[0]) {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "UPDATE ON DERIVED METRIC");
      lastStats[0] = newValue;
      lastStats[1] = computeVelocity(false);
      lastStats[2] = computeNoise(false);
      return true;
    }
    return false;
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double value(boolean useWeakCache) {
    if (useWeakCache) {
      atomic {
        return weakStats[0];
      }
    } else if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastStats[0] = computeValue(false);
    }
    return lastStats[0];
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double velocity(boolean useWeakCache) {
    if (useWeakCache) {
      atomic {
        return weakStats[1];
      }
    } else if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastStats[1] = computeVelocity(false);
    }
    return lastStats[1];
  }

  // XXX: note that the below assumes that if we're not using weakly cached
  // items, we're called from a transactional context!
  /*@Override*/
  public double noise(boolean useWeakCache) {
    if (useWeakCache) {
      atomic {
        return weakStats[2];
      }
    } else if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastStats[2] = computeNoise(false);
    }
    return lastStats[2];
  }

  /*@Override*/
  public boolean isSingleStore() {
    return singleStore;
  }

  /**
   * {@inheritDoc}
   *
   * If this is the first observer, then this metric is being monitored for
   * changes and so it stops computing on demand and instead caches the last
   * updated value (computed on checks). This metric then becomes an observer
   * of its terms.
   */
  /*@Override*/
  public void addObserver(Observer obs) {
    if (!isObserved()) {
      // Start tracking terms if this is now used by a contract directly.
      for (int i = 0; i < terms.length; i++) {
        terms[i].addObserver(this);
      }
      lastStats[0] = computeValue(false);
      lastStats[1] = computeVelocity(false);
      lastStats[2] = computeNoise(false);
    }
    super.addObserver(obs);
  }

  /**
   * {@inheritDoc}
   *
   * If there are no observers after removing the given one, this metric stops
   * acting as an observer of its terms (and goes back to computing on demand
   * rather than caching the last updated value).
   */
  /*@Override*/
  public void removeObserver(Observer obs) {
    super.removeObserver(obs);
    if (!isObserved()) {
      // Don't observe subterms unless it's being tracked directly.
      for (int i = 0; i < terms.length; i++) {
        terms[i].removeObserver(this);
      }
    }
  }

  /**
   * @return the terms this {@link DerivedMetric} is defined over
   */
  protected Metric[] terms() {
    Metric[] copy = new Metric[terms.length];
    Arrays.arraycopy(terms, 0, copy, 0, terms.length);
    return copy;
  }

  /**
   * @param i
   *        an index into the terms array
   * @return the ith term this {@link DerivedMetric} is defined over
   */
  protected Metric term(int i) {
    return terms[i];
  }

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    return Collections.unmodifiableSet(Worker.getWorker().getLocalStore(), leafMetrics);
  }

  private class Refresher implements Callable {
    final Metric t;

    public Refresher fabric$metrics$DerivedMetric$Refresher$(Metric t) {
      this.t = t;
      fabric$lang$Object$();
      return this;
    }

    public java.lang.Object call() {
      t.refreshWeakEstimates();
      return null;
    }
  }

  private static final int POOL_SIZE = 32;
  private static final ExecutorService service = Executors.newFixedThreadPool(POOL_SIZE);

  /*@Override*/
  public void refreshWeakEstimates() {
      if (TransactionManager.getInstance().getCurrentLog() == null) {
        Future native[] futures = new Future native[terms.length];
        // First, refresh the subterm stats.
        for (int i = 0; i < terms.length; i++) {
            // TODO: Add remote worker to call
            final Metric t = terms[i];
            Callable c = null;
            atomic {
              c = new Refresher().fabric$metrics$DerivedMetric$Refresher$(t);
            }
            futures[i] = service.submit(c);
        }
        for (int i = 0; i < terms.length; i++) {
          try {
            futures[i].get();
          } catch (ExecutionException e) {
            // TODO: Log this if it happens.
          } catch (InterruptedException e) {
            // TODO: Log this if it happens.
          }
        }
      } else {
        for (int i = 0; i < terms.length; i++) {
            // TODO: Add remote worker to call
            terms[i].refreshWeakEstimates();
        }
      }
      // Then update locally.
      super.refreshWeakEstimates();
  }
}
