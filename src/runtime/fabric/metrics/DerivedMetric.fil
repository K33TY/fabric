package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Collections;
import fabric.util.HashSet;
import fabric.util.Iterator;
import fabric.util.Set;
import fabric.util.TreeSet;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.DerivedMetricContract;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;

import fabric.worker.Store;
import fabric.worker.Worker;
import fabric.worker.transaction.TransactionManager;
import java.util.logging.Level;

/**
 * General base class for {@link Metric}s built by computing over other
 * {@link Metrics}. Each {@link DerivedMetric} implementation is responsible for
 * defining how to
 * <ul>
 * <li>construct the {@link #value()}, {@link #velocity()}, and {@link #noise()}
 * from its terms</li>
 * <li>provide a {@link EnforcementPolicy} to enforce a
 * {@link DerivedMetricContract} on it given the {@link Bound}, typically using
 * a {@link WitnessPolicy} using {@link MetricContract}s on the terms it is
 * derived from.</li>
 * </ul>
 */
public abstract class DerivedMetric extends Metric implements Observer {
  protected double lastValue;
  protected double lastVelocity;
  protected double lastNoise;

  protected Metric[] terms;

  private Set/*<SampledMetric>*/ leafMetrics;

  /**
   * @param s
   *        the {@link Store} this {@link DerivedMetric} will be stored on
   * @param terms
   *        the {@link Metric}s that this {@link DerivedMetric} is
   *        computed from
   */
  public DerivedMetric fabric$metrics$DerivedMetric$(Metric[] terms) {
    fabric$metrics$Metric$();
    this.terms = new Metric[terms.length];
    Arrays.arraycopy(terms, 0, this.terms, 0, terms.length);
    if (new TreeSet/*<>*/().fabric$util$TreeSet$(Arrays.asList(terms)).size() != terms.length)
      throw new IllegalArgumentException(
          "DerivedMetric terms must not contain duplicates!");
    this.leafMetrics = new HashSet/*<>*/().fabric$util$HashSet$();
    return this;
  }

  /**
   * Method to be called at the end of a constructor for any subclass of
   * {@link DerivedMetric}. Ensures that the {@link DerivedMetric} is added as
   * an {@link Observer} of its terms as well as caches the initial value of
   * the {@link Metric}.
   */
  public void initialize() {
    for (int i = 0; i < terms.length; i++) {
      if (terms[i] instanceof SampledMetric) {
        leafMetrics.add(/*(SampledMetric)*/ terms[i]);
      } else if (terms[i] instanceof DerivedMetric) {
        leafMetrics.addAll(((DerivedMetric) terms[i]).getLeafSubjects());
      } else {
        throw new IllegalStateException(
            "This shouldn't happen, all metrics should either be a SampledMetric or a DerivedMetric!");
      }
    }

    lastValue = computeValue();
    lastVelocity = computeVelocity();
    lastNoise = computeNoise();
  }

  /*@Override*/
  public boolean handleUpdates() {
    fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "CHECKING FOR UPDATE ON DERIVED METRIC");
    double newValue = computeValue();
    if (newValue != lastValue) {
      fabric.common.Logging.METRICS_LOGGER.log(Level.FINE, "UPDATE ON DERIVED METRIC");
      lastValue = newValue;
      lastVelocity = computeVelocity();
      lastNoise = computeNoise();
      return true;
    }
    return false;
  }

  /*@Override*/
  public double value() {
    if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastValue = computeValue();
    }
    return lastValue;
  }

  public abstract double computeValue();

  /*@Override*/
  public double velocity() {
    if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastVelocity = computeVelocity();
    }
    return lastVelocity;
  }

  public abstract double computeVelocity();

  /*@Override*/
  public double noise() {
    if (isObserved()) {
      // Make sure any related updates are accounted for
      fabric.worker.transaction.TransactionManager.getInstance().resolveObservations();
    } else {
      // Not getting updated proactively, so compute it
      lastNoise = computeNoise();
    }
    return lastNoise;
  }

  public abstract double computeNoise();

  /*@Override*/
  public boolean isSingleStore() {
    for (int i = 0; i < terms.length; i++) {
      if (!terms[i].getStore().equals(getStore()) || !terms[i].isSingleStore())
        return false;
    }
    return true;
  }

  /*@Override*/
  public void startTracking(MetricContract mc) {
    if (!isObserved()) {
      // Start tracking terms if this is now used by a contract directly.
      for (int i = 0; i < terms.length; i++) {
        terms[i].addObserver(this);
      }
      lastValue = computeValue();
      lastVelocity = computeVelocity();
      lastNoise = computeNoise();
    }
    addObserver(mc);
  }

  /*@Override*/
  public void stopTracking(MetricContract mc) {
    removeObserver(mc);
    if (!isObserved()) {
      // Don't observe subterms unless it's being tracked directly.
      for (int i = 0; i < terms.length; i++) {
        terms[i].removeObserver(this);
      }
    }
  }

  /**
   * Method to be called when a {@link DerivedMetric} is no longer stored.
   * Removes itself from the {@link Observer}s of its terms.
   */
  public void cleanup() {
    Iterator iter = getContracts(System.currentTimeMillis()).iterator();
    while (iter.hasNext()) {
      ((MetricContract) iter.next()).deactivate();
    }
  }

  /**
   * @return the terms this {@link DerivedMetric} is defined over
   */
  public Metric[] terms() {
    Metric[] copy = new Metric[terms.length];
    Arrays.arraycopy(terms, 0, copy, 0, terms.length);
    return copy;
  }

  /**
   * @param i
   *        an index into the terms array
   * @return the ith term this {@link DerivedMetric} is defined over
   */
  public Metric term(int i) {
    return terms[i];
  }

  /*@Override*/
  protected MetricContract createContract(Bound bound) {
    final Store s = getStore();
    return new DerivedMetricContract@s().fabric$metrics$contracts$DerivedMetricContract$(this, bound);
  }

  /**
   * @param s
   *        a {@link Store} that will hold the copy of this
   *        {@link DerivedMetric}
   * @return a copy of this {@link DerivedMetric} that is stored on s
   */
  public abstract Metric copyOn(Store s);

  /**
   * @param bound
   *        a {@link Bound} that the returned policy enforces.
   * @return a {@link EnforcementPolicy} that enforces this {@link Metric}
   *       being above bound.
   */
  public abstract EnforcementPolicy policyFor(Bound bound);

  /*@Override*/
  public Set/*<SampledMetric>*/ getLeafSubjects() {
    return Collections.unmodifiableSet(Worker.getWorker().getLocalStore(), leafMetrics);
  }
}
