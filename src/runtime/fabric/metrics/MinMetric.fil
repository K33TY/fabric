package fabric.metrics;

import fabric.util.Arrays;
import fabric.util.Set;
import fabric.util.TreeSet;
import fabric.util.Iterator;
import fabric.util.LinkedHashMap;
import fabric.util.Map;

import fabric.metrics.contracts.Bound;
import fabric.metrics.contracts.MetricContract;
import fabric.metrics.contracts.enforcement.DirectPolicy;
import fabric.metrics.contracts.enforcement.EnforcementPolicy;
import fabric.metrics.contracts.enforcement.WitnessPolicy;
import fabric.metrics.util.Observer;
import fabric.metrics.util.Subject;

import fabric.worker.Store;

/**
 * A {@link DerivedMetric} for the minimum of a group of other {@link Metric}s.
 */
public class MinMetric extends DerivedMetric {

    /**
     * @param store
     *            the {@link Store} that holds this {@link Metric}
     * @param terms
     *            The {@link Metric}s this applies to
     */
    public MinMetric fabric$metrics$MinMetric$(Metric[] terms) {
        fabric$metrics$DerivedMetric$(terms);
        Set/*<Metric>*/ termsBag = new TreeSet/*<Metric>*/().fabric$util$TreeSet$(Arrays.asList(terms));
        this.terms = (Metric[]) termsBag.toArray(new Metric[termsBag.size()]);
        Arrays.sort(this.terms);
        initialize();
        return this;
    }

    /*@Override*/
    protected double computeValue(boolean useWeakCache) {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length; i++) {
            result = Math.min(result, terms[i].value(useWeakCache));
        }
        return result;
    }

    /*@Override*/
    protected double computeVelocity(boolean useWeakCache) {
        double result = Double.MAX_VALUE;
        for (int i = 0; i < terms.length; i++) {
            result = Math.min(result, terms[i].velocity(useWeakCache));
        }
        return result;
    }

    /*@Override*/
    protected double computeNoise(boolean useWeakCache) {
        double noise = 0;
        for (int i = 0; i < terms.length; i++) {
            noise = Math.max(noise, terms[i].noise(useWeakCache));
        }
        return noise;
    }

    /*@Override*/
    public String toString() {
      String str = "min(";
      boolean nonEmpty = false;
      for (int i = 0; i < terms.length; i++) {
        if (nonEmpty) {
            str += ", ";
        }
        nonEmpty = true;
        str += terms[i];
      }
      return str + ")@" + $getStore();
    }

    /*@Override*/
    public DerivedMetric times(double scalar) {
        Metric[] newTerms = new Metric[terms.length];
        Arrays.arraycopy(terms, 0, newTerms, 0, terms.length);
        for (int i = 0; i < newTerms.length; i++) {
            newTerms[i] = newTerms[i].times(scalar);
        }
        final Store s = $getStore();
        return Metric.findDerivedMetric(s,
                new MinMetric@s().fabric$metrics$MinMetric$(terms));
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link MinMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public DerivedMetric plus(Metric other) {
        Metric[] newTerms = new Metric[terms.length];
        Arrays.arraycopy(terms, 0, newTerms, 0, terms.length);
        for (int i = 0; i < newTerms.length; i++) {
            newTerms[i] = other.plus(newTerms[i]);
        }
        final Store s = $getStore();
        return Metric.findDerivedMetric(s,
                new MinMetric@s().fabric$metrics$MinMetric$(terms));
    }

    /**
     * {@inheritDoc}
     * <p>
     * {@link MinMetric}s try to consolidate local computations so that there
     * isn't unnecessary nodes in the {@link Subject}-{@link Observer} tree for
     * {@link #handleUpdates()}.
     */
    /*@Override*/
    public Metric min(Metric other) {
        final Store s = $getStore();
        if (other instanceof MinMetric && other.$getStore().equals(s)) {
            MinMetric that = (MinMetric) other;

            // Get the combined sorted set of terms.
            Set/*<Metric>*/ termsBag = new TreeSet/*<>*/();
            termsBag.addAll(Arrays.asList(this.terms));
            termsBag.addAll(Arrays.asList(that.terms));

            Metric[] newTerms = new Metric[termsBag.size()];
            int aggIdx = 0;
            for (Iterator iter = termsBag.iterator(); iter.hasNext();) {
                Metric m = (Metric) iter.next();
                newTerms[aggIdx++] = m;
            }

            return Metric.findDerivedMetric(s,
                    new MinMetric@s().fabric$metrics$MinMetric$(newTerms));
        } else if (Arrays.asList(terms).indexOf(other) >= 0) {
            return this;
        }

        Metric[] newTerms = new Metric[terms.length + 1];
        System.arraycopy(terms, 0, newTerms, 0, terms.length);
        newTerms[terms.length] = other;
        Arrays.sort(newTerms, 0, newTerms.length);
        return Metric.findDerivedMetric(s,
                new MinMetric@s().fabric$metrics$MinMetric$(newTerms));
    }

    /*@Override*/
    public EnforcementPolicy policy(Bound bound, boolean useWeakCache) {
        if (isSingleStore())
            return new DirectPolicy().fabric$metrics$contracts$enforcement$DirectPolicy$(this, bound);
        MetricContract[] witnesses = new MetricContract[terms.length];
        // Defend all rows against the bound individually, using the strictest
        // bounds across the rows for each term in this sum.
        for (int i = 0; i < terms.length; i++) {
            witnesses[i] = term(i).getContract(bound);
        }
        final Store bndStore = bound.getStore();
        return new WitnessPolicy@bndStore().fabric$metrics$contracts$enforcement$WitnessPolicy$(witnesses);
    }

    /*@Override*/
    public int hashCode() {
        return Arrays.hashCode(terms) * 32 + $getStore().hashCode();
    }

    /*@Override*/
    public boolean equals(Object other) {
        if (other instanceof MinMetric) {
            MinMetric that = (MinMetric) other;
            return Arrays.deepEquals(this.terms, that.terms)
                    && this.$getStore().equals(that.$getStore());
        }
        return false;
    }
}
