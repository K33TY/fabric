package fabric.metrics.util;

import fabric.util.ArrayList;

//import fabric.metrics.LinearMetric;

import fabric.worker.Worker;

/**
 * Utility class for matrix representation in {@link LinearMetric}.
 */
public class Matrix {
  private int rows;
  private int columns;
  private ArrayList/*<double[]>*/ data;

  /**
   * @param rows
   *        the number of rows in the blank {@link Matrix} produced.
   * @param columns
   *        the number of columns in the blank {@link Matrix} produced.
   */
  public Matrix fabric$metrics$util$Matrix$(int rows, int columns) {
    fabric$lang$Object$();
    this.rows = rows;
    this.columns = columns;
    data = new ArrayList/*<>*/().fabric$util$ArrayList$(rows);
    for (int i = 0; i < rows; i++) {
      data.add(new double[columns]);
    }
    return this;
  }

  /** @return the number of rows in this {@link Matrix} */
  public int rows() {
    return rows;
  }

  /** @return the number of columns in this {@link Matrix} */
  public int columns() {
    return columns;
  }

  /**
   * @param i
   *        a row index into this {@link Matrix}
   * @return a copy of row i
   */
  public double[] getRow(int i) {
    double[] row = (double[]) data.get(i);
    double[] copy = new double[columns];
    for (int j = 0; j < row.length; j++) {
      copy[j] = row[j];
    }
    return copy;
  }

  /**
   * @param i
   *        a column index into this {@link Matrix}
   * @return a copy of column i
   */
  public double[] getColumn(int i) {
    double[] copy = new double[rows];
    for (int j = 0; j < rows; j++) {
      copy[j] = ((double[]) data.get(j))[i];
    }
    return copy;
  }

  /**
   * @param i
   *        a row index into this {@link Matrix}
   * @param j
   *        a column index into this {@link Matrix}
   * @return the entry at (i, j)
   */
  public double get(int i, int j) {
    return ((double[]) data.get(i))[j];
  }

  /**
   * @param i
   *        a row index into this {@link Matrix}
   * @param newRow
   *        the row to replace with at index i in this {@link Matrix}
   */
  public void setRow(int i, double[] newRow) {
    if (newRow.length != columns)
      throw new IllegalArgumentException(
          "Row of wrong size (" + columns + "): " + newRow.length);
    if (i >= rows)
      throw new IllegalArgumentException(
          "Row index out of bounds (" + rows + "): " + i);
    double[] row = (double[]) data.get(i);
    for (int j = 0; j < columns; j++) {
      row[j] = newRow[j];
    }
  }

  /**
   * @param i
   *        a column index into this {@link Matrix}
   * @param newColumn
   *        the column to replace with at index i in this {@link Matrix}
   */
  public void setColumn(int i, double[] newColumn) {
    if (newColumn.length != rows)
      throw new IllegalArgumentException(
          "Column of wrong size (" + rows + "): " + newColumn.length);
    if (i >= columns)
      throw new IllegalArgumentException(
          "Row index out of bounds (" + columns + "): " + i);
    for (int j = 0; j < rows; j++) {
      ((double[]) data.get(j))[i] = newColumn[j];
    }
  }

  /**
   * @param i
   *        a row index into this {@link Matrix}
   * @param j
   *        a column index into this {@link Matrix}
   * @param v
   *        the value to place at (i, j)
   */
  public void set(int i, int j, double v) {
    ((double[]) data.get(i))[j] = v;
  }

  /**
   * @param i
   *        a row index
   * @param newRow
   *        a row to insert (shifting rows over if necessar) at index i in
   *        this {@link Matrix}
   */
  public void insertRow(int i, double[] newRow) {
    if (newRow.length != columns)
      throw new IllegalArgumentException(
          "Row of wrong size (" + columns + "): " + newRow.length);
    if (i > rows)
      throw new IllegalArgumentException("Bad row index: " + i);
    data.add(i, newRow);
    rows++;
  }

  /**
   * @param newRow
   *        the row to append to this {@link Matrix}
   */
  public void addRow(double[] newRow) {
    insertRow(rows, newRow);
  }

  /**
   * @param i
   *        a column index
   * @param newCol
   *        a column to insert (shifting columns over if necessar) at
   *        index i in this {@link Matrix}
   */
  public void insertColumn(int i, double[] newCol) {
    if (newCol.length != rows)
      throw new IllegalArgumentException(
          "Column of wrong size (" + rows + "): " + newCol.length);
    if (i > columns)
      throw new IllegalArgumentException("Bad column index: " + i);
    for (int j = 0; j < rows; j++) {
      double[] oldRow = (double[]) data.get(j);
      double[] newRow = new double[columns + 1];
      for (int k = 0; k < columns + 1; k++) {
        if (k == i) {
          newRow[k] = newCol[j];
        } else if (k > i) {
          newRow[k] = oldRow[k - 1];
        } else {
          newRow[k] = oldRow[k];
        }
      }
      data.set(i, newRow);
    }
    columns++;
  }

  /**
   * @param newCol
   *        the column to append to this {@link Matrix}
   */
  public void addColumn(double[] newCol) {
    insertColumn(columns, newCol);
  }

  /**
   * @param i
   *        the row index to remove from this {@link Matrix} (shifting
   *        back other rows, if necessary).
   */
  public void removeRow(int i) {
    if (i >= rows)
      throw new IllegalArgumentException("Bad row index: " + i);
    data.remove(i);
    rows--;
  }

  /**
   * @param i
   *        the column index to remove from this {@link Matrix} (shifting
   *        back other columns, if necessary).
   */
  public void removeColumn(int i) {
    if (i >= columns)
      throw new IllegalArgumentException("Bad column index: " + i);
    for (int j = 0; j < rows; j++) {
      double[] newRow = new double[columns - 1];
      double[] oldRow = (double[]) data.get(j);
      for (int k = 0; k < columns; k++) {
        if (k == i) {
          continue;
        } else if (k > i) {
          newRow[k - 1] = oldRow[k];
        } else {
          newRow[k] = oldRow[k];
        }
      }
      data.set(j, newRow);
    }
    columns--;
  }

  /**
   * @param v
   *        a vector (given as a double[])
   * @return the result of multiplying this {@link Matrix} with v
   */
  public double[] multiply(double[] v) {
    if (v.length != columns)
      throw new IllegalArgumentException("Bad vector length: " + v.length);
    double[] result = new double[rows];
    for (int row = 0; row < rows; row++) {
      for (int col = 0; col < columns; col++) {
        result[row] += get(row, col) * v[col];
      }
    }
    return result;
  }

  /**
   * @param m
   *        another {@link Matrix} to multiply with
   * @return the result of multiplying this {@link Matrix} with v
   */
  public Matrix multiply(Matrix m) {
    if (m.rows() != columns)
      throw new IllegalArgumentException(
          "Bad matrix size: " + m.rows() + "x" + m.columns());
    Matrix result = new Matrix().fabric$metrics$util$Matrix$(0, m.columns);
    for (int row = 0; row < m.columns(); row++) {
      result.addRow(multiply(m.getColumn(row)));
    }
    return result;
  }

  /**
   * @param a
   *        a scalar to multiply the entries of this {@link Matrix} by
   * @return the result of multiplying this {@link Matrix}'s entries by a
   */
  public Matrix multiply(double a) {
    Matrix result = new Matrix().fabric$metrics$util$Matrix$(rows, columns);
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        result.set(i, j, get(i, j) * a);
      }
    }
    return result;
  }

  /**
   * @param m
   *        another {@link Matrix} to multiply with element-wise
   * @return the element-wise product of this and m
   */
  public Matrix elementMultiply(Matrix m) {
    if (m.rows() != rows || m.columns() != columns)
      throw new IllegalArgumentException(
          "Bad matrix size: " + m.rows() + "x" + m.columns());
    Matrix result = new Matrix().fabric$metrics$util$Matrix$(rows, columns);
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        result.set(i, j, get(i, j) * m.get(i, j));
      }
    }
    return result;
  }

  /**
   * @return a copy of this {@link Matrix}
   */
  public Matrix copy() {
    return copy(Worker.getWorker().getLocalStore());
  }

  /**
   * @return a copy of this {@link Matrix}
   */
  public Matrix copy(final Store s) {
    Matrix result = new Matrix@s().fabric$metrics$util$Matrix$(rows, columns);
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        result.set(i, j, get(i, j));
      }
    }
    return result;
  }

  /**
   * @param size
   *        the size of the identity {@link Matrix} to create
   * @return an identity {@link Matrix} of the given size
   */
  public static Matrix identity(int size) {
    Matrix m = new Matrix().fabric$metrics$util$Matrix$(size, size);
    for (int i = 0; i < size; i++) {
      m.set(i, i, 1);
    }
    return m;
  }

  /**
   * @param row
   *        the single row to put in the created {@link Matrix}
   * @return a {@link Matrix} with a single row with the given contents
   */
  public static Matrix singleRow(double[] row) {
    Matrix m = new Matrix().fabric$metrics$util$Matrix$(1, row.length);
    m.setRow(0, row);
    return m;
  }

  /**
   * @param column
   *        the single column to put in the created {@link Matrix}
   * @return a {@link Matrix} with a single column with the given contents
   */
  public static Matrix singleColumn(double[] column) {
    Matrix m = new Matrix().fabric$metrics$util$Matrix$(column.length, 1);
    m.setColumn(0, column);
    return m;
  }

  /**
   * @param rows
   *        the number of rows in the returned {@link Matrix}
   * @param columns
   *        the number of columns in the returned {@link Matrix}
   * @param c
   *        a constant to initialize all entries with
   * @return a {@link Matrix} with all entries initialized to c
   */
  public static Matrix constant(int rows, int columns, double c) {
    Matrix m = new Matrix().fabric$metrics$util$Matrix$(rows, columns);
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        m.set(i, j, c);
      }
    }
    return m;
  }

  /*@Override*/
  public boolean equals(Object other) {
    if (other instanceof Matrix) {
      Matrix that = (Matrix) other;
      if (this.rows() != that.rows() || this.columns() != that.columns())
        return false;
      for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
          if (this.get(i, j) != that.get(i, j))
            return false;
        }
      }
      return true;
    }
    return false;
  }

  /*@Override*/
  public int hashCode() {
    int code = 31 * rows + columns;
    // Using List hashCode procedure;
    for (int i = 0; i < rows; i++) {
      for (int j = 0; j < columns; j++) {
        // Using Double hashCode procedure;
        code = 31 * code + Double.hashCode(get(i, j));
      }
    }
    return code;
  }

  /*@Override*/
  public String toString() {
    String str = "[";
    for (int i = 0; i < rows; i++) {
      if (i > 0)
        str += ", ";
      str += "[";
      for (int j = 0; j < columns; j++) {
        if (i > 0)
          str += ", ";
        str += get(i, j);
      }
      str += "]";
    }
    return str + "]";
  }
}
