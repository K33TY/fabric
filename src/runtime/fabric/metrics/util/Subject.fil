package fabric.metrics.util;

import fabric.util.Collections;
import fabric.util.HashSet;
import fabric.util.Iterator;
import fabric.util.LinkedHashSet;
import fabric.util.Set;

import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;

import fabric.worker.transaction.TransactionManager;
import fabric.worker.Store;

import java.util.logging.Level;

/**
 * Represents an observable object having a set of {@link Observer}s. After an
 * observable object changes, an application can call
 * {@link #getObserversCopy()} to get the current set of {@link Observer}s.
 * {@link Observer}s are then notified of a change via a call to
 * {@link Observer#handleUpdates()}.
 */
public abstract class Subject {

  // Ugh, avoid getting a surrogate's store.
  public Store getStore() {
    return $getStore();
  }

  protected Subject fabric$metrics$util$Subject$() {
    fabric$lang$Object$();
    return this;
  }

  // Using a weak map as the backing for this set so that observers aren't
  // pinned by their subjects.
  private Set/*<Observer>*/ observers = new HashSet/*<>*/().fabric$util$HashSet$();

  /**
   * Adds an observer to the set of observers for this object. Nothing is done
   * if the given observer {@link #equals(Object) equals} an existing
   * observer.
   *
   * @param o
   *        {@link Observer} to add
   */
  public void addObserver(Observer o) {
    observers.add(o);
  }

  /**
   * Removes an observer from the set of observers of this object.
   *
   * @param o
   *        {@link Observer} to remove
   */
  public void removeObserver(Observer o) {
    observers.remove(o);
  }

  /**
   * @param o
   *        an observer that might observe this subject.
   * @return true iff o observes this subject.
   */
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /**
   * @return true iff there are any observers of this subject, currently.
   */
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /**
   * @return a copy of the set of the current observers of this subject.
   */
  public Set/*<Observer>*/ getObserversCopy() {
    return new LinkedHashSet/*<>*/().fabric$util$LinkedHashSet$(observers);
  }

  /**
   * @return the set of the current observers of this subject.
   */
  public Set/*<Observer>*/ getObservers() {
    return observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   */
  public static void processSamples(java.util.LinkedList unobserved, java.util.List extensions) {
    atomic {
      java.util.LinkedList/*<Observer>*/ queue = new java.util.LinkedList/*<>*/();
      while (!unobserved.isEmpty()) {
        SampledMetric sm = (SampledMetric) unobserved.poll();
        //queue.addAll(sm.getObservers());
        Iterator obsIter = sm.getObservers().iterator();
        while (obsIter.hasNext()) {
          queue.add(obsIter.next());
        }

        while (!queue.isEmpty()) {
          Observer unhandled = (Observer) queue.poll();
          boolean needToWait = false;
          Iterator leavesIter = unhandled.getLeafSubjects().iterator();
          while (leavesIter.hasNext()) {
            if (unobserved.contains(leavesIter.next())) {
              needToWait = true;
              break;
            }
          }
          // If this has no other pending sampled events, process it.
          if (!needToWait) {
            if (unhandled instanceof Contract) {
              // This contract is handled *now*
              extensions.remove(/*(Contract)*/ unhandled);
            }
            boolean modified = unhandled.handleUpdates();
            if (unhandled instanceof Subject && modified) {
              //queue.addAll(parents);
              Iterator parentIter = ((Subject) unhandled).getObservers().iterator();
              while (parentIter.hasNext()) {
                queue.add(parentIter.next());
              }
            }
          }
        }
      }
    }
  }
}
