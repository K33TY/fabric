package fabric.metrics.util;

import fabric.util.Collections;
import fabric.util.HashSet;
import fabric.util.Iterator;
import fabric.util.LinkedHashSet;
import fabric.util.Set;

import fabric.metrics.SampledMetric;
import fabric.metrics.contracts.Contract;

/**
 * Represents an observable object having a set of {@link Observer}s. After an
 * observable object changes, an application can call
 * {@link #getObserversCopy()} to get the current set of {@link Observer}s.
 * {@link Observer}s are then notified of a change via a call to
 * {@link Observer#handleUpdates()}.  */
public abstract class Subject {

  protected Subject fabric$metrics$util$Subject$() {
    fabric$lang$Object$();
    return this;
  }

  // Using a weak map as the backing for this set so that observers aren't
  // pinned by their subjects.
  private Set/*<Observer>*/ observers = new HashSet/*<>*/().fabric$util$HashSet$();

  private boolean modified = false;

  /**
   * Adds an observer to the set of observers for this object. Nothing is done
   * if the given observer {@link #equals(Object) equals} an existing
   * observer.
   *
   * @param o
   *        {@link Observer} to add
   */
  public void addObserver(Observer o) {
    observers.add(o);
  }

  /**
   * Removes an observer from the set of observers of this object.
   *
   * @param o
   *        {@link Observer} to remove
   */
  public void removeObserver(Observer o) {
    observers.remove(o);
  }

  /**
   * @param o
   *        an observer that might observe this subject.
   * @return true iff o observes this subject.
   */
  public boolean observedBy(Observer o) {
    return observers.contains(o);
  }

  /**
   * @return true iff there are any observers of this subject, currently.
   */
  public boolean isObserved() {
    return !observers.isEmpty();
  }

  /**
   * @return a copy of the set of the current observers of this subject.
   */
  public Set/*<Observer>*/ getObserversCopy() {
    return (new HashSet/*<>*/()).fabric$util$HashSet$(observers);
  }

  /**
   * Mark this subject as modified.
   */
  public void markModified() {
    this.modified = true;
  }

  /**
   * Clear the modified flag on this subject.
   */
  public void clearModified() {
    this.modified = false;
  }

  /**
   * @return true iff the modified flag is set.
   */
  public boolean isModified() {
    return this.modified;
  }

  /**
   * @return the set of the current observers of this subject.
   */
  public Set/*<Observer>*/ getObservers() {
    return observers;
  }

  /**
   * Utility for processing a batch of samples for the transaction manager.
   */
  public static void processSamples(java.util.LinkedList unobserved, java.util.List extensions) {
    while (!unobserved.isEmpty()) {
      SampledMetric sm = (SampledMetric) unobserved.poll();
      sm.clearModified();
      java.util.LinkedList/*<Observer>*/ queue = new java.util.LinkedList/*<>*/();
      //queue.addAll(sm.getObserversCopy());
      Iterator obsIter = sm.getObservers().iterator();
      while (obsIter.hasNext()) {
        queue.add(obsIter.next());
      }

      while (!queue.isEmpty()) {
        Observer unhandled = (Observer) queue.poll();
        boolean needToWait = false;
        Iterator leavesIter = unhandled.getLeafSubjects().iterator();
        while (leavesIter.hasNext()) {
          if (unobserved.contains(leavesIter.next())) {
            needToWait = true;
            break;
          }
        }
        // If this has no other pending sampled events, process it.
        if (!needToWait) {
          Set/*<Observer>*/ parents = Collections.EMPTY_SET;
          if (unhandled instanceof Subject) {
            parents = ((Subject) unhandled).getObserversCopy();
          }
          unhandled.handleUpdates();
          if (unhandled instanceof Subject && ((Subject) unhandled).isModified()) {
            Subject s = (Subject) unhandled;
            if (s instanceof Contract) {
              // This contract isn't being extended now.
              extensions.remove(s);
            }
            Iterator parentIter = parents.iterator();
            while (parentIter.hasNext()) {
              queue.add(parentIter.next());
            }
            s.clearModified();
          }
          if (unhandled instanceof Contract && ((Contract) unhandled).extended()) {
            Contract curContract = (Contract) unhandled;
            curContract.clearExtended();
            if (!extensions.contains(curContract))
              extensions.add(curContract);
          }
        }
      }
    }
  }
}
