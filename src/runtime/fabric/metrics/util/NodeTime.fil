package fabric.metrics.util;

import fabric.worker.Worker;
import fabric.worker.Store;

/**
 * Utility for describing a timestamp and getting bounds specific to the system
 * node asking for it.
 */
public class NodeTime {

  /**
   * Maximum amount of drift we'll tolerate between two nodes in the system.
   *
   * For now a bit easier than trying to compute specific latencies. Worth
   * reconsidering later.
   */
  public static final long MAX_DRIFT = 50;

  /** The node specifying the expiry. */
  public /*final*/ Store store;
  /** The expiry time specified. */
  public /*final*/ long time;

  /**
   * @param store
   *        the node specifying the expiry
   * @param time
   *        the expiry time specified
   */
  public NodeTime fabric$metrics$util$NodeTime$(Store store, long time) {
    this.store = store;
    this.time = time;
    fabric$lang$Object$();
    return this;
  }

  /**
   * Create a NodeTime on the current store.
   *
   * @param time
   *        the expiry time specified
   */
  public NodeTime fabric$metrics$util$NodeTime$(long time) {
    Worker w = Worker.getWorker();
    this.store = w.getStore(w.getName());
    this.time = time;
    fabric$lang$Object$();
    return this;
  }

  /**
   * @return the lower bound on this time relative to the node running the
   *       current transaction
   */
  public long lowerBound() {
    Worker w = Worker.getWorker();
    Store store = w.getStore(w.getName());
    return lowerBoundAt(store);
  }

  /**
   * @param other
   *        a store we're computing relative to
   * @return the lower bound on this time relative to other
   */
  public long lowerBoundAt(Store other) {
    return store.equals(other) ? time : time - MAX_DRIFT;
  }

  /**
   * @return the upper bound on this time relative to the node running the
   *       current transaction
   */
  public long upperBound() {
    Worker w = Worker.getWorker();
    Store store = w.getStore(w.getName());
    return upperBoundAt(store);
  }

  /**
   * @param other
   *        a store we're computing relative to
   * @return the upper bound on this time relative to other
   */
  public long upperBoundAt(Store other) {
    return time;
  }

  /*@Override*/
  public String toString() {
    return "(" + time + "@" + store + ")";
  }

  /*@Override*/
  public boolean equals(Object o) {
    if (!(o instanceof NodeTime)) return false;
    NodeTime that = (NodeTime) o;
    return that.store.equals(store) && that.time == time;
  }

  /*@Override*/
  public int hashCode() {
    return Long.hashCode(time) * 32 + store.hashCode();
  }
}
