package jif.lang;

import jif.lang.IntegPolicy;
import jif.lang.WriterPolicy;
import fabric.client.Client;
import fabric.client.Core;
import fabric.util.ArrayList;
import fabric.util.Collection;
import fabric.util.Map;
import fabric.util.Set;
import fabric.util.HashMap;
import fabric.util.HashSet;
import fabric.util.Iterator;
import fabric.util.LinkedHashSet;

/**
 * Utility methods for principals. This code is mostly copied from Jif.
 */
public class PrincipalUtil {
  // Need to figure out how to properly cache things.  -MJL

//  caches
//  private static final Map/* <ActsForPair, ActsForProof> */cacheActsFor =
//    new HashMap/* <ActsForPair, ActsForProof> */();
//  private static final Set/* <ActsForPair, ActsForPair> */cacheNotActsFor =
//    new HashSet/* <ActsForPair, ActsForPair> */();
//
//  // map from DelegationPairs to sets of ActsForPairs. If (p, q) is
//  // in the set of the map of delegation d, then p actsfor q, and the
//  // proof depends on the delegation d
//  private static final Map/* <DelegationPair, Set<ActsForPair>> */cacheActsForDependencies =
//    new HashMap/* <DelegationPair, Set<ActsForPair>> */();

  /**
   * Returns true if and only if the principal p acts for the principal q. A
   * synonym for the <code>actsFor</code> method.
   */
  public static boolean acts_for(Principal p, Principal q) {
    try {
      LabelUtil.enterTiming();
      return actsFor(p, q);
    } finally {
      LabelUtil.exitTiming();
    }
  }

  /**
   * Returns true if and only if the principal p acts for the principal q.
   */
  public static boolean actsFor(Principal p, Principal q) {
    final Core localCore = Client.getClient().getLocalCore();
    return actsForProof(localCore, p, q) != null;
  }

  /**
   * Returns an actsfor proof if and only if the principal p acts for the
   * principal q.
   */
  public static ActsForProof actsForProof(Core core, Principal p, Principal q) {
    final Core localCore = Client.getClient().getLocalCore();
    try {
      LabelUtil.enterTiming();
      // try cache
      ActsForPair pair = new ActsForPair@localCore(p, q);
//      if (LabelUtil.USE_CACHING) {
//        if (cacheActsFor.containsKey(pair)) {
//          return (ActsForProof) cacheActsFor.get(pair);
//        }
//        if (cacheNotActsFor.contains(pair)) return null;
//      }

      if (delegatesTo(q, p)) return new DelegatesProof@core(p, q);

      // if the two principals are ==-equal, or if they
      // both agree that they are equal to each other, then
      // we return true (since the acts-for relation is
      // reflexive).
      if (eq(p, q)) return new ReflexiveProof@core(p, q);

      // try searching
      ActsForProof prf = findActsForProof(core, p, q, null);
      if (prf != null && (verifyProof(prf, p, q))) {
//        if (LabelUtil.USE_CACHING) {
//          cacheActsFor.put(pair, prf);
//        }
        // add dependencies that this actsfor replies on.
        Set s = new HashSet@localCore();
        prf.gatherDelegationDependencies(s);
        // for each DelegationPair in s, if that delegation is removed, the
        // proof is no longer valid.
//        if (LabelUtil.USE_CACHING) {
//          for (Iterator iter = s.iterator(); iter.hasNext();) {
//            DelegationPair del = (DelegationPair) iter.next();
//            Set/* <ActsForPair> */deps = (Set) cacheActsForDependencies.get(del);
//            if (deps == null) {
//              deps = new HashSet/* <ActsForPair> */();
//              cacheActsForDependencies.put(del, deps);
//            }
//            deps.add(pair);
//          }
//        }
        return prf;
      }

//      if (LabelUtil.USE_CACHING) {
//        cacheNotActsFor.add(pair);
//      }
      return null;
    } finally {
      LabelUtil.exitTiming();
    }
  }

  /**
   * Notification that a new delegation has been created.
   */
  public static void notifyNewDelegation(Principal granter, Principal superior) {
    // double check that the delegation occured
    if (!delegatesTo(granter, superior)) return;

    // XXX for the moment, just clear out all cached negative results
//    if (LabelUtil.USE_CACHING) {
//      cacheNotActsFor.clear();
//    }

    // need to notify the label cache too
    LabelUtil.notifyNewDelegation(granter, superior);
  }

  /**
   * Notification that an existing delegation has been revoked.
   */
  public static void notifyRevokeDelegation(Principal granter,
      Principal superior) {
    final Core localCore = Client.getClient().getLocalCore();
//    if (LabelUtil.USE_CACHING) {
//      DelegationPair del = new DelegationPair@localCore(superior, granter);
//      Set deps = (Set) cacheActsForDependencies.remove(del);
//      if (deps != null) {
//        for (Iterator iter = deps.iterator(); iter.hasNext();) {
//          ActsForPair afp = (ActsForPair) iter.next();
//          cacheActsFor.remove(afp);
//        }
//      }
//    }
    // need to notify the label cache too
    LabelUtil.notifyRevokeDelegation(granter, superior);
  }

  /**
   * Search for an ActsForProof between p and q. An ActsForProof between p and q
   * is a a checkable proof object.
   * 
   * @param p
   * @param q
   * @param searchState
   *                records the goals that we are in the middle of attempting
   * @return An ActsForPoorf between p and q, or null if none can be found.
   */
  public static ActsForProof findActsForProof(Core core, Principal p, Principal q,
      java.lang.Object searchState) {
    final Core localCore = Client.getClient().getLocalCore();
    try {
      LabelUtil.enterTiming();
      // try the dumb things first.
      if (q == null) {
        return new DelegatesProof@core(p, q);
      }
      if (eq(p, q)) {
        return new ReflexiveProof@core(p, q);
      }

      // check the search state
      ProofSearchState newss;
      if (searchState instanceof ProofSearchState) {
        ProofSearchState ss = (ProofSearchState)searchState;
        if (ss.contains(p, q)) {
          // p and q are already on the goal stack. Prevent an infinite recursion.
          return null;
        }
        newss = new ProofSearchState@localCore(ss, p, q);                                        
      } else {
        newss = new ProofSearchState@localCore(p, q);
      }

      // if we're going from a dis/conjunctive principal, try finding a
      // downwards
      // proof first
      ActsForProof prf;
      boolean doneDownTo = false;
      if (p instanceof ConjunctivePrincipal
          || p instanceof DisjunctivePrincipal) {
        prf = p.findProofDownto(core, q, newss);
        if (prf != null) return prf;
        doneDownTo = true;
      }

      // try searching upwards from q.
      prf = q.findProofUpto(core, p, newss);
      if (prf != null) return prf;

      // try searching downards from p.
      if (!doneDownTo && p != null) {
        prf = p.findProofDownto(core, q, newss);
        if (prf != null) return prf;
      }

      // have failed!
      return null;
    } finally {
      LabelUtil.exitTiming();
    }

  }

  private static class ProofSearchState {
    private ActsForPair[] goalstack;

    public ProofSearchState(Principal p, Principal q) {
      goalstack = new ActsForPair[1];
      goalstack[0] = new ActsForPair(p, q);
    }
    private ProofSearchState(ProofSearchState ss, Principal p, Principal q) {
      int len = ss.goalstack.length + 1;
      goalstack = new ActsForPair[len];
      for (int i = 0; i < len-1; i++)
        goalstack[i] = ss.goalstack[i];
      goalstack[len-1] = new ActsForPair(p, q);
    }
    public boolean contains(Principal p, Principal q) {
      for (int i = 0; i < goalstack.length; i++) {
        if (goalstack[i] != null) {
          if (eq(goalstack[i].p, p) && eq(goalstack[i].q, q)) {
            return true;
          }
        }
      }
      return false;
    }

  }

  /**
   * Return whether principals p and q are equal. p and q must either be
   * references to the same object, both be null, or agree that they are equal
   * to the other.
   */
  private static boolean eq(Principal p, Principal q) {
    return p == q || (p != null && q != null && p.equals(q) && q.equals(p));
  }

  /**
   * Verify that the chain is a valid delegates-chain between p and q. That is,
   * q == chain[n], chain[n] delegates to chain[n-1], ..., chain[0] == p, i.e.,
   * p acts for q.
   */
  public static boolean verifyProof(ActsForProof prf, Principal actor,
      Principal granter) {
    try {
      LabelUtil.enterTiming();
      if (prf == null) return false;
      if (prf.getActor() != actor || prf.getGranter() != granter) return false;

      if (prf instanceof DelegatesProof) {
        return delegatesTo(granter, actor);
      } else if (prf instanceof ReflexiveProof) {
        return eq(actor, granter);
      } else if (prf instanceof TransitiveProof) {
        TransitiveProof proof = (TransitiveProof) prf;
        return verifyProof(proof.getActorToP(), proof.getActor(), proof.getP())
        && verifyProof(proof.getPToGranter(), proof.getP(), proof
            .getGranter());
      } else if (prf instanceof FromDisjunctProof) {
        FromDisjunctProof proof = (FromDisjunctProof) prf;
        if (actor instanceof DisjunctivePrincipal) {
          DisjunctivePrincipal dp = (DisjunctivePrincipal) actor;
          // go though each disjunct, and make sure there is a proof
          // from the disjunct to the granter
          for (Iterator iter = dp.disjuncts.iterator(); iter.hasNext();) {
            Principal disjunct = (Principal) iter.next();
            ActsForProof pr =
              (ActsForProof) proof.getDisjunctProofs().get(disjunct);
            if (!verifyProof(pr, disjunct, granter)) return false;
          }
          // we have verified a proof from each disjunct to the granter
          return true;
        }

      } else if (prf instanceof ToConjunctProof) {
        ToConjunctProof proof = (ToConjunctProof) prf;
        if (granter instanceof ConjunctivePrincipal) {
          ConjunctivePrincipal cp = (ConjunctivePrincipal) granter;
          // go though each conjunct, and make sure there is a proof
          // from actor to the conjunct
          for (Iterator iter = cp.conjuncts.iterator(); iter.hasNext();) {
            Principal conjunct = (Principal) iter.next();
            ActsForProof pr =
              (ActsForProof) proof.getConjunctProofs().get(conjunct);
            if (!verifyProof(pr, actor, conjunct)) return false;
          }
          // we have verified a proof from actor to each conjunct.
          return true;
        }

      }

      // unknown proof!
      return false;
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static boolean delegatesTo(Principal granter, Principal superior) {
    try {
      LabelUtil.enterTiming();
      if (granter == null) return true;
      if (isTopPrincipal(superior)) return true;
      if (superior instanceof ConjunctivePrincipal) {
        ConjunctivePrincipal cp = (ConjunctivePrincipal) superior;
        for (Iterator iter = cp.conjuncts.iterator(); iter.hasNext();) {
          Principal conjunct = (Principal) iter.next();
          if (equals(conjunct, granter)) return true;
        }
      }
      return granter.delegatesTo(superior);
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static boolean equivalentTo(Principal p, Principal q) {
//    try {
//      LabelUtil.enterTiming();
      boolean eq = false;
      atomic {
          eq = actsFor(p, q) && actsFor(q, p);
      }
      return eq;
//    } finally {
//      LabelUtil.exitTiming();
//    }
  }

  public static boolean equals(Principal p, Principal q) {
    try {
      LabelUtil.enterTiming();
      return eq(p, q);
    } finally {
      LabelUtil.exitTiming();
    }

  }

  /**
   * Execute the given closure, if the principal agrees.
   */
  public static java.lang.Object execute(Principal p, java.lang.Object authPrf, Closure c, Label lb) {
    final Core localCore = Client.getClient().getLocalCore();
    Capability cap = authorize(localCore, p, authPrf, c, lb, true);
    if (cap != null) {
      return cap.invoke();
    }
    return null;
  }

  /**
   * Obtain a Capability for the given principal and closure.
   */
  public static Capability authorize(Core core, Principal p, java.lang.Object authPrf,
      Closure c, Label lb) {
    return authorize(core, p, authPrf, c, lb, false);
  }

  public static Capability authorize(Principal p, java.lang.Object authPrf,
      Closure c, Label lb) {
    final Core localCore = Client.getClient().getLocalCore();
    return authorize(localCore, p, authPrf, c, lb, false);
  }

  private static Capability authorize(Core core, Principal p, java.lang.Object authPrf,
      Closure c, Label lb, boolean executeNow) {
    try {
      LabelUtil.enterTiming();
      Principal closureP = c.jif$getjif_lang_Closure_P();
      Label closureL = c.jif$getjif_lang_Closure_L();
      if (closureP == p
          || (p != null && closureP != null && p.equals(closureP) && closureP
              .equals(p))) {
        // The principals agree.
        if (LabelUtil.equivalentTo(closureL, lb)) {
          // the labels agree
          if (p == null || p.isAuthorized(authPrf, c, lb, executeNow)) {
            // either p is null (and the "null" principal always
            // gives authority!) or p grants authority to execute the
            // closure.
            return new Capability@core(closureP, closureL, c);
          }
        }
      }
      return null;
    } finally {
      LabelUtil.exitTiming();
    }

  }

  /**
   * returns the null principal, the principal that every other principal can
   * act for.
   */
  public static Principal nullPrincipal() {
    return null;
  }

  public static Principal bottomPrincipal() {
    try {
      LabelUtil.enterTiming();
      return nullPrincipal();
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static Principal topPrincipal() {
    final LocalCore localCore = Client.getClient().getLocalCore();
    return localCore.getTopPrincipal();
  }

  public static Principal topPrincipal(Core core) {
    final LocalCore localCore = Client.getClient().getLocalCore();
    return localCore.getTopPrincipal();
  }

  static boolean isTopPrincipal(Principal p) {
    return p instanceof TopPrincipal;
  }

        public static ConfPolicy readableByPrinPolicy(Principal p) {
          final LocalCore localCore = Client.getClient().getLocalCore();
          return readableByPrinPolicy(localCore, p);
        }

  public static ConfPolicy readableByPrinPolicy(Core core, Principal p) {
    try {
      LabelUtil.enterTiming();
      return new ReaderPolicy@core(topPrincipal(), p);
    } finally {
      LabelUtil.exitTiming();
    }

  }

        public static IntegPolicy writableByPrinPolicy(Principal p) {
          final LocalCore localCore = Client.getClient().getLocalCore();
          return writableByPrinPolicy(localCore, p);
        }

  public static IntegPolicy writableByPrinPolicy(Core core, Principal p) {
    try {
      LabelUtil.enterTiming();
      return new WriterPolicy@core(topPrincipal(), p);
    } finally {
      LabelUtil.exitTiming();
    }
  }

  public static Principal disjunction(Principal left, Principal right) {
    final LocalCore core = Client.getClient().getLocalCore();
          return disjunction(core, left, right);
        }

        public static Principal disjunction(Core core, Principal left, Principal right) {
    try {
      LabelUtil.enterTiming();
      if (left == null || right == null) return null;
      if (actsFor(left, right)) return right;
      if (actsFor(right, left)) return left;
      Collection/* <Principal> */c = new ArrayList/* <Principal> */@core(2);
      c.add(left);
      c.add(right);
      return disjunction(core, c);
    } finally {
      LabelUtil.exitTiming();
    }

  }

        public static Principal conjunction(Principal left, Principal right) {
          final LocalCore core = Client.getClient().getLocalCore();
          return conjunction(core, left, right);
        }

  public static Principal conjunction(Core core, Principal left, Principal right) {
    try {
      LabelUtil.enterTiming();
      if (left == null) return right;
      if (right == null) return left;
      if (actsFor(left, right)) return left;
      if (actsFor(right, left)) return right;
      Collection/* <Principal> */c = new ArrayList/* <Principal> */@core(2);
      c.add(left);
      c.add(right);
      return conjunction(core, c);
    } finally {
      LabelUtil.exitTiming();
    }

  }

        public static Principal disjunction(Collection/*Principal*/ principals) {
          final Core core = Client.getClient().getLocalCore();
          return disjunction(core, principals);
        }

  public static Principal disjunction(Core core, Collection/* <Principal> */principals) {
    try {
      LabelUtil.enterTiming();
      if (principals == null || principals.isEmpty()) {
        return topPrincipal();
      }
      final Core localCore = Client.getClient().getLocalCore();
      if (principals.size() == 1) {
        Object o = principals.iterator(localCore).next();
        if (o == null || o instanceof Principal) return (Principal) o;
        return topPrincipal();
      }

      // go through the collection of principals, and flatten them
      Set/* <Principal> */needed = new LinkedHashSet/* <Principal> */@core();
      for (Iterator/* <Principal> */iter = principals.iterator(localCore); iter
      .hasNext();) {
        Object o = iter.next();
        Principal p = null;
        if (o instanceof Principal) p = (Principal) o;
        if (p == null) return p;
        if (PrincipalUtil.isTopPrincipal(p)) continue;
        if (p instanceof DisjunctivePrincipal) {
          needed.addAll(((DisjunctivePrincipal) p).disjuncts);
        } else {
          needed.add(p);
        }
      }
      return new DisjunctivePrincipal@core(needed);
    } finally {
      LabelUtil.exitTiming();
    }

  }

        public static Principal conjunction(Collection/*Principal*/ principals) {
          final Core core = Client.getClient().getLocalCore();
          return conjunction(core, principals); 
        }

  public static Principal conjunction(Core core, Collection/* <Principal> */principals) {
    try {
      LabelUtil.enterTiming();
      if (principals == null || principals.isEmpty()) {
        return bottomPrincipal();
      }
      final Core localCore = Client.getClient().getLocalCore();
      if (principals.size() == 1) {
        Object o = principals.iterator(localCore).next();
        if (o == null || o instanceof Principal) return (Principal) o;
        return bottomPrincipal();
      }

      // go through the collection of principals, and flatten them
      Set/* <Principal> */needed = new LinkedHashSet/* <Principal> */@core();
      for (Iterator/* <Principal> */iter = principals.iterator(localCore); iter
      .hasNext();) {
        Object o = iter.next();
        Principal p = null;
        if (o instanceof Principal) p = (Principal) o;

        if (p == null) continue; // ignore bottom principals
        if (PrincipalUtil.isTopPrincipal(p)) return p;
        if (p instanceof ConjunctivePrincipal) {
          needed.addAll(((ConjunctivePrincipal) p).conjuncts);
        } else {
          needed.add(p);
        }
      }
      return new ConjunctivePrincipal@core(needed);
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static String toString(Principal p) {
    try {
      LabelUtil.enterTiming();
      return p == null ? "_" : p.name();
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static String stringValue(Principal p) {
    try {
      LabelUtil.enterTiming();
      return toString(p);
    } finally {
      LabelUtil.exitTiming();
    }

  }

  public static final class TopPrincipal extends Principal {
    public TopPrincipal() {
    }

    public String name() {
      return "*";
    }

    public boolean delegatesTo(Principal p) {
      return false;
    }

    public boolean equals(Principal p) {
      return p instanceof TopPrincipal;
      //  XXX No proper support for static state yet.
      //      return p == this;
    }

    public boolean isAuthorized(java.lang.Object authPrf, Closure closure, Label lb,
        boolean executeNow) {
      return false;
    }

    public ActsForProof findProofUpto(Core core, Principal p,
        java.lang.Object searchState) {
      return null;
    }

    public ActsForProof findProofDownto(Core core, Principal q,
        java.lang.Object searchState) {
      return null;
    }

  }

  private abstract static class PrincipalPair {
    final Principal p;
    final Principal q;

    PrincipalPair(Principal p, Principal q) {
      this.p = p;
      this.q = q;
    }

    public boolean equals(Object o) {
      if (o != null && o.getClass().equals(this.getClass())) {
        PrincipalPair that = (PrincipalPair) o;
        return eq(this.p, that.p) && eq(this.q, that.q);
      }
      return false;
    }

    public int hashCode() {
      return (p == null ? -4234 : p.hashCode())
      ^ (q == null ? 23 : q.hashCode());
    }

    public String toString() {
      return p.name() + "-" + q.name();
    }
  }

  private static class ActsForPair extends PrincipalPair {
    ActsForPair(Principal superior, Principal inferior) {
      super(superior, inferior);
    }
  }

  static class DelegationPair extends PrincipalPair {
    DelegationPair(Principal actor, Principal granter) {
      super(actor, granter);
    }
  }
}

/*
** vim: ts=2 sw=4 et cindent cino=\:0
*/
