#!/usr/bin/env python

#
# Usage:   runOO7 <core> <client> <size>
# Example: runOO7  core0  client0  small
#
# - creates a principal
# - creates a OO7 database
# - runs T1, T2, and T6 against it, hot and cold
# - computes and reports timing information

from subprocess import Popen, PIPE
import sys
import re

def main():
	global categories, core, client, size, overhead

	core   = sys.argv[1]
	client = sys.argv[2]
	size   = sys.argv[3]

	print "===== Finding categories ======"
	result     = sh( "bin/fab --time", PIPE )
	categories = result.split("\n")[1].split(", ")
	categories.remove("all")
	print categories

	print "===== Computing timing overhead ====="
	result     = sh( "bin/calibrate" )
	overhead   = float(result)
	print overhead, " ms"

	print "===== Creating principal ====="
	result = sh( "bin/fab --name %s --make-principal %s" % (client, core) )
	print result

	print "===== Creating database  ====="
	result = sh( "bin/fab --name %s --time all OO7.Benchmark     fab://%s/OO7 %s 3" % (client, core, size) )

	for traversal in ("T1", "T6"):
		print "===== Executing %3s ===========" % traversal
		runTraversal(traversal)

	
	print "===== Executing T2b ==========="
	

	print "===== Raw Data ================"
	for test in names:
		print test, "no timing"
		total = sum(untimed[test]) / len(untimed[test])
		print "    %s" % ', '.join([str(t) for t in untimed[test]])
		print "    %d" % total

		print test, "timing enabled"
		for cat in categories:
			for run in timed[test]:
				alpha, catNoTiming = computeCatTime(run.time, run.categories[cat], run.count, total)
				print "    %-7s %6d / %6d with %8d measurements ==> %5d (%5.4f)" % (cat + ":", run.categories[cat], run.time, run.count, catNoTiming, alpha)


	print "===== Report =================="
	out =    "%15s & Total time (ms)" % ''
	for cat in categories:
		out += " & \multicolumn{2}{c}{%6s}" % cat

	for test in names:
		runs    = timed[test]
		num     = len(runs)
		average = sum([run.time for run in runs]) / num
		out += "\n%-15s & %15d" % (test, average)
		for cat in categories:
			time = sum([run.categories[cat] for run in runs]) / num
			out += " & %8d           & %3d\\%%" % (time, time * 100 / average)

	print out

# name -> [time]
untimed = {}
# name -> [TimedRun]
timed   = {}
# [name]
names   = []

# cat->time, count, time
class TimedRun():
	def __init__(self, lines):
		self.categories = {}
		for line in lines[:-1]:
			match = catExpr.match(line)
			self.categories[match.group("cat")] = int(match.group("time"))

		match = totExpr.match(lines[-1])
		self.count = int(match.group("count"))
		self.time  = int(match.group("time"))


catExpr = re.compile(r" *(?P<cat>.+):\s*(?P<time>\d+) ms\Z")
totExpr = re.compile(r" Total: +(?P<time>\d+) ms \((?P<count>\d+) +measurements\)\Z")

def runTraversal(traversal):
	coldname = traversal + " " + size + " cold"
	hotname  = traversal + " " + size + " hot "

	names.append(coldname)
	names.append(hotname)

	timed[coldname] = []
	timed[hotname]  = []

	untimed[coldname] = []
	untimed[hotname]  = []

	# run 3 times with timing on.
	for i in range(3):
		result = sh( "bin/fab --name %s --time all OO7.traversals.%s fab://%s/OO7 --hot 3" % (client, traversal, core) )
		lines  = result.split("\n")

		timed[coldname].append(TimedRun(lines[2:10]))
		timed[ hotname].append(TimedRun(lines[13:21]))


	# run 3 times with timing off, collect total time
	for i in range(3):
		result = sh( "bin/fab --name %s            OO7.traversals.%s fab://%s/OO7 --hot 3" % (client, traversal, core) )
		lines  = result.split("\n")

		match  = totExpr.match(lines[2])
		untimed[coldname].append(int(match.group("time")))

		match  = totExpr.match(lines[6])
		untimed[hotname ].append(int(match.group("time")))

def computeCatTime(totalWithTiming, catWithTiming, count, totalWithoutTiming):
	global overhead, categories
	alpha = (totalWithTiming - count * overhead) / totalWithoutTiming - 1
	catWithoutTiming = (catWithTiming - count * overhead / len(categories)) / (1 + alpha)

	return alpha, catWithoutTiming

def sh(cmd, stderr = None):
	print ">> ", cmd
	result = Popen(cmd, stdout=PIPE, stderr=stderr, shell=True).communicate()[0]
	print  result
	return result

if __name__ == '__main__':
	main()

