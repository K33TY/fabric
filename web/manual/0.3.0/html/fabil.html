<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Fabric: The Fabric intermediate language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fabric
   &#160;<span id="projectnumber">0.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fabil.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">The Fabric intermediate language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Fabric's intermediate language, FabIL, is a Java dialect for writing programs that can run on the Fabric runtime system. As its name suggests, it is internally used by the Fabric compiler as an intermediate language. Therefore, FabIL is lower-level than the full Fabric language and does not enforce information-flow security. FabIL is exposed as a separate language with its own compiler, <code>filc</code>. Portions of the Fabric runtime is written in FabIL.</p>
<p>Like Fabric, FabIL supports using and creating <a class="el" href="language.html#persistent-objects">persistent objects</a> on remote stores, <a class="el" href="language.html#transactions">nested transactions</a>, and <a class="el" href="language.html#remote-calls">remote method calls</a>. Mobile code is not supported, however.</p>
<p>There are two primary differences between Fabric and FabIL. First, whereas Fabric has types labelled with policies for information-flow security, FabIL does not. In this respect, FabIL is more closely related to Java than it is to Fabric. The second difference is in how objects are constructed. Although FabIL programs do not enforce information-flow security, they do create full-fledged Fabric objects, which have labels. To support this, FabIL has:</p><ul>
<li>an API for <a class="el" href="fabil.html#fabil-creating-labels">creating label objects</a>,</li>
<li>syntax for <a class="el" href="fabil.html#fabil-array-construction">specifying labels on arrays</a>, and</li>
<li>an <a class="el" href="fabil.html#fabil-constructor-protocol">object-construction convention</a> that must be followed.</li>
</ul>
<h2>Creating label objects<a class="anchor" id="fabil-creating-labels"></a></h2>
<p>While Fabric has built-in syntax for labels, FabIL does not. Instead, labels in FabIL are constructed explicitly through the API provided by the library class <code>fabric.lang.security.LabelUtil</code>, which exposes several static methods for constructing label objects.</p>
<h3>Pre-built labels and policies</h3>
<table class="doxtable">
<tr>
<th>Method signature </th><th>Description  </th></tr>
<tr>
<td><code>Label noComponents()</code> </td><td>Returns the label <code>{⊥→⊥ ; ⊥←⊥}</code>. </td></tr>
<tr>
<td><code>ConfPolicy bottomConf()</code> </td><td>Returns the confidentiality policy <code>{⊥→⊥}</code>. </td></tr>
<tr>
<td><code>ConfPolicy topConf()</code> </td><td>Returns the confidentiality policy <code>{⊤→⊤}</code>. </td></tr>
<tr>
<td><code>IntegPolicy bottomInteg()</code> </td><td>Returns the integrity policy <code>{⊤←⊤}</code>. </td></tr>
<tr>
<td><code>IntegPolicy topInteg()</code> </td><td>Returns the integrity policy <code>{⊥←⊥}</code>. </td></tr>
</table>
<h3>Creating policies</h3>
<table class="doxtable">
<tr>
<th>Method signature </th><th>Description  </th></tr>
<tr>
<td><code>ConfPolicy readerPolicy(Store store, Principal owner, Principal reader)</code> </td><td>Creates and returns the confidentiality policy <code>{owner→reader}</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>IntegPolicy writerPolicy(Store store, Principal owner, Principal writer)</code> </td><td>Creates and returns the integrity policy <code>{owner←writer}</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>ConfPolicy join(Store store, ConfPolicy p1, ConfPolicy p2)</code> </td><td>Creates and returns the confidentiality policy <code>p1 ⊔ p2</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>ConfPolicy meet(Store store, ConfPolicy p1, ConfPolicy p2)</code> </td><td>Creates and returns the confidentiality policy <code>p1 ⊓ p2</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>IntegPolicy join(Store store, IntegPolicy p1, IntegPolicy p2)</code> </td><td>Creates and returns the integrity policy <code>p1 ⊔ p2</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>IntegPolicy meet(Store store, IntegPolicy p1, IntegPolicy p2)</code> </td><td>Creates and returns the integrity policy <code>p1 ⊓ p2</code>, allocated on <code>store</code>. </td></tr>
</table>
<h3>Creating labels</h3>
<table class="doxtable">
<tr>
<th>Method signature </th><th>Description  </th></tr>
<tr>
<td><code>Label readerPolicyLabel(Store store, Principal owner, Principal reader)</code> </td><td>Creates and returns the label <code>{owner→reader ; ⊥←⊥}</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>Label writerPolicyLabel(Store store, Principal owner, Principal writer)</code> </td><td>Creates and returns the label <code>{⊥→⊥ ; owner←writer}</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>Label toLabel(Store store, ConfPolicy cPolicy, IntegPolicy iPolicy)</code> </td><td>Creates and returns the label <code>{cPolicy ; iPolicy}</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>Label join(Store store, Label l1, Label l2)</code> </td><td>Creates and returns the label <code>l1 ⊔ l2</code>, allocated on <code>store</code>. </td></tr>
<tr>
<td><code>Label meet(Store store, Label l1, Label l2)</code> </td><td>Creates and returns the label <code>l1 ⊓ l2</code>, allocated on <code>store</code>. </td></tr>
</table>
<h2>Constructing arrays<a class="anchor" id="fabil-array-construction"></a></h2>
<p>In FabIL, arrays are created by specifying their label and a store to store them. For example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Store store = Worker.getWorker().getStore(&quot;storename&quot;);</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Label lbl = LabelUtil.noComponents();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;int[] array = new int[5] ~lbl @store;</div></div><!-- fragment --><p> The <code>~lbl</code> component of the <code>new</code> expression gives the name of a variable containing the label for the array. If the label is not specified, the array is created with the same label as the object <code>this</code>. Like in Fabric, the <code>@store</code> component gives the store on which to create the array; if it is omitted, the array is created on the same store as <code>this</code>.</p>
<h2>Object-construction convention<a class="anchor" id="fabil-constructor-protocol"></a></h2>
<p>Fabric ensures that final fields really are final: it should not be possible to observe final fields of an object before they have been initialized. This property, inherited from Jif, is important because final fields of type <code>label</code> or <code>principal</code> may be used in security policies. It also has implications for how constructors are written in Fabric and, consequentially, FabIL.</p>
<p>To ensure that final fields really are final, Fabric constructors must initialize all final fields before calling the superclass constructor. For example, a class in Fabric might look like the following: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;package geometry;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;class NCPoint extends Point {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  final String{} name;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Colour{} c;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  NCPoint(String name, int x, int y, Colour c) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    this.name = name; // Initialize all final fields.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    super(x,y);       // Then call super class&#39;s constructor.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    this.c = c;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  }</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div></div><!-- fragment --><p>In Java, no code is allowed to precede the call to the superclass constructor. Therefore, operationally, Fabric separates the <em>allocation</em> of objects from their <em>initialization</em>. This means that when a Fabric class is translated to FabIL, no explicit constructors are created. Instead, Fabric constructors are translated into <em>initializer methods</em>. For example, the Fabric compiler translates the above class into the following FabIL class:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;package geometry;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;class NCPoint extends Point {</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  String name; // intended to be final</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  Colour c;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  NCPoint geometry$NCPoint$(String name, int x, int y, Colour c) {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    this.name = name;      // initialize &quot;final&quot; fields</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    geometry$Point$(x,y);  // call super class&#39;s initializer</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    this.c = c;            // initialize other fields</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    return this;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  }</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  // Specifies the object&#39;s label and access policy. Called by the</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  // initializer for fabric.lang.Object.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  public Object $initLabels() {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    this.$updateLabel = LabelUtil.noComponents();</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    this.$accessPolicy = LabelUtil.bottomConf();</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    return this;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  }</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;}</div></div><!-- fragment --><p>To be compatible with Fabric, programs written in FabIL should follow this same convention. There are a few things to note:</p>
<ul>
<li>Although the field <code>name</code> is intended to be final, its <code>final</code> flag is removed.</li>
<li>No constructors are declared. Instead, the class has the initializer method <code>geometry$NCPoint$</code>, which implements the constructor's functionality. The call to the superclass's constructor is turned into a call to the appropriate initializer method in the superclass.</li>
<li>The name of the initializer method is derived from the fully qualified name of the class: dots are replaced with dollars, and an extra dollar is appended at the end.</li>
<li>The method <code>$initLabels()</code> is declared for specifying the object's label and access policy. This can depend on the object's "final" fields, because this method is called by the initializer for fabric.lang.Object, after all of the "final" fields are initialized.</li>
<li>Initializer methods and <code>$initLabels()</code> return <code>this</code>.</li>
</ul>
<p>Object construction is done in two stages. First, the implicit default constructor is called to allocate the object. Then, the desired initializer method is called to initialize the object: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;new NCPoint().geometry$NCPoint$(&quot;origin&quot;, 0, 0, Colour.BLACK)</div></div><!-- fragment --><p>The FabIL compiler does not enforce any aspect of this convention. It is up to the programmer to ensure that this convention is followed. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 27 2016 20:01:13 for Fabric by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
