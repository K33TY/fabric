<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Fabric: The Fabric language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Fabric
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('language.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">The Fabric language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Fabric programming language is an extension of the Jif programming language <a class="el" href="citelist.html#CITEREF_jif-popl1999">[5]</a>, which is in turn a version of Java extended with security labels that govern the confidentiality and integrity of information used in the program, and ensure that information flows in the programs respect those security policies. Therefore, a good place to start is with the <a href="http://www.cs.cornell.edu/jif/doc/jif-3.3.0/manual.html">Jif manual</a>.</p>
<p>Fabric extends Jif with several additional features:</p>
<ul>
<li><a class="el" href="language.html#persistent-objects">using and creating persistent objects on remote stores</a></li>
<li><a class="el" href="language.html#transactions">nested transactions</a></li>
<li><a class="el" href="language.html#remote-calls">remote method calls</a></li>
<li><a class="el" href="language.html#access-labels">access labels</a></li>
<li><a class="el" href="language.html#provider-labels">provider labels</a></li>
<li><a class="el" href="language.html#codebases">codebases</a></li>
</ul>
<p>These features are summarized below, but more information can be found in two papers about Fabric <a class="el" href="citelist.html#CITEREF_fabric2009">[4]</a>, <a class="el" href="citelist.html#CITEREF_mobile-fabric-2012">[1]</a>.</p>
<h2>Persistent objects <a class="anchor" id="persistent-objects"></a></h2>
<p>Fabric objects are, in general, persistent. Further, they may be stored persistently at a remote node (a storage node, or store). Applications that need persistent storage do not need a database to back them; they can record information directly in objects. Fabric supports <em>orthogonal persistence</em>: programs use objects in the same way regardless of whether they are persistent or not.</p>
<p>Remote persistent objects are created by specifying a store to store them. For example: </p>
<div class="fragment"><div class="line">Store s = FabricWorker.getWorker().getStore(<span class="stringliteral">&quot;storename&quot;</span>);</div>
<div class="line">Object o = <span class="keyword">new</span> Object@s(args);</div>
</div><!-- fragment --><p> If a store is not specified, objects are created at the same store as the object <code>this</code>. Each worker node also has a local, non-persistent store. A reference to this store can be obtained by calling <code>FabricWorker.getWorker().getLocalStore()</code>.</p>
<p>Every object in Fabric has an <em>object label</em> that specifies the security of the information it contains. The object label is declared by attaching it to a field or fields of the object. (If multiple fields have labels, the object label combines all of them.)</p>
<h2>Nested transactions <a class="anchor" id="transactions"></a></h2>
<p>Fabric computations are organized in <em>transactions</em>, which occur, as far as the programmer can tell, atomically and in isolation from the rest of the Fabric system.</p>
<p>Transactions are specified with an atomic block, for example: </p>
<div class="fragment"><div class="line">atomic {</div>
<div class="line">  o1.f();</div>
<div class="line">  o2.g();</div>
<div class="line">}</div>
</div><!-- fragment --><p> The semantics of the atomic block are that statements inside the atomic block are executed simultaneously and without interference from other concurrent transactions, even those taking place at other network nodes.</p>
<p>Transactions may be nested freely. The results of a nested transaction are only visible to the outer transaction once it successfully commits.</p>
<h2>Remote method calls <a class="anchor" id="remote-calls"></a></h2>
<p>Unlike in most distributed object systems, computation in Fabric stays on the same network node unless the program explicitly transfers control to another node, using a remote method call.</p>
<p>A remote method call is specified using the syntax <code>o.m@w(x)</code>. This is the same syntax as a Java method call, except for the annotation <code>@w</code>, which specifies the worker node at which to perform the method call. </p>
<div class="fragment"><div class="line">RemoteWorker w = FabricWorker.getWorker().getWorker(<span class="stringliteral">&quot;workername&quot;</span>);</div>
<div class="line">o.m@w(args);</div>
</div><!-- fragment --><p>Unlike in many other distributed systems with remote calls, the objects used during the computation of the method <code>m</code> need not reside at the remote worker <code>w</code>. Also note that transactions can span multiple remote calls; these calls will be executed as a single transaction.</p>
<h2>Access labels <a class="anchor" id="access-labels"></a></h2>
<p>When an object is accessed during computation on a worker, but is not yet cached at the worker, the worker must fetch the object data from the node where it is stored. Thus, the contacted node learns that an access to the object has occurred. This side channel is called a <em>read channel</em>.</p>
<p>Read channels are controlled by extending Jif with a second label on each object, called the <em>access label</em>. It is a confidentiality-only label that bounds what can be learned from the fact that the object has been accessed. The access label ensures that the object is stored on a node that is trusted to learn about all the accesses to it, and it prevents the object from being accessed from a context that is too confidential.</p>
<p>The access label of an object is declared as part of the label of its fields. Given object label <code>{u}</code> and access label <code>{a}</code>, a label annotation <code>{u} @ {a}</code> means that the field, and by extension the object, has the corresponding labels.</p>
<p>For example, the following code declares an object containing public information (in field <code>data</code>) that can be accessed without leaking information, according to any principal that trusts node <code>n</code> to enforce its confidentiality:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Public {</div>
<div class="line">    <span class="keywordtype">int</span> {} @ {⊤→n} data;</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this example, the object label is <code>{}</code> (public and untrusted), and the access label is <code>{⊤→n}</code> (readable by principal <code>n</code>).</p>
<p>If the access label is omitted from a field, its access label defaults to the label <code>{this.store→}</code>. For any object <code>o</code>, the pseudo-field <code>o.store</code> represents the node on which <code>o</code> is stored.</p>
<h2>Provider labels <a class="anchor" id="provider-labels"></a></h2>
<p>Remote method calls make it possible to invoke a method on a remote node even when that node has not previously seen the class of the object receiving the call, or its code. To make this possible, Fabric code is stored in <em>class objects</em>, which are also persistent objects in Fabric. We refer to the act of adding a class object to Fabric as <em>publishing</em> that class.</p>
<p>All code has an information-flow label called the <em>provider label</em>, which bounds who can have influenced the code. In fact, this label is precisely the object label of the class object.</p>
<p>Inside Fabric code, the provider label can be named explicitly as <code>provider</code>. Before loading code from a class object, a Fabric node checks the information flows within the code, using the provider label to implicitly keep track of the influence that the code publisher has on computations performed by the code.</p>
<h2>Codebases <a class="anchor" id="codebases"></a></h2>
<p>Unlike Java classes, Fabric class objects are accompanied by linkage specifications called <em>codebases</em>. There is no global mapping in Fabric from class names to class objects. Instead, each code publisher can choose their own mapping. Fabric helps to make sure that published code uses these namespaces consistently. Thus, codebases support <em>decentralized namespaces</em>; a class's own codebase defines the resolution of its dependencies. Linkage of a component's dependencies is fixed at publication, so nodes that download and compile mobile code independently can securely interact with each other.</p>
<p>Codebases are normally not visible in Fabric programs. However, to support evolution of running Fabric systems, it may be necessary to use two classes with the same fully qualified Java name within the same program. This is supported by the use of <em>explicit codebases</em>.</p>
<p>For example, to specify that the name <code>pkg.A</code> should be resolved through a different codebase than the default one being used in the current code, we might declare the existence of a separate codebase <code>cb1</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">package </span>pkg;</div>
<div class="line">codebase cb1;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>B <span class="keyword">extends</span> C {</div>
<div class="line">  <span class="keywordtype">void</span> m(cb1.pkg.A a) {</div>
<div class="line">    …</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> The fully qualified name <code>pkg.A</code> is resolved to a class object through a different class name than the current class, <code>pkg.B</code>. The binding between the name <code>cb1</code> and the actual Fabric codebase object is done at the time of publication. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Oct 19 2012 18:42:11 for Fabric by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
