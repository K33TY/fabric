package friendmap;

import java.io.PrintStream;

import jif.runtime.Runtime;

import mapserv.MapServer;
import mapserv.MapImage;
import mapserv.Box;
import snapp.UserV1;
import snapp.Location;
import util.GroupIterator;
import util.Delegator;
import util.AssertionFailedError;
import util.NoSuchElementException;
import util.Util;
import util.System;
import util.Store;

/**
 * This is the mapping application.  A FriendMap is instantiated with a particular
 * mapping service, and then can be run by any User to generate private or
 * public output maps.
 */
public class FriendMap {

  /** The map service that this app uses to fetch maps.  Must be non-null. */
  public final MapServer {this} service;

  /**
   * Create a new instance of the mapping service.
   *
   * @throws NullPointerException
   *         if service is null.
   */
  public
  FriendMap {this}
  (
    MapServer {this} service
  )
  throws
    NullPointerException
  where
    provider <= {this}
  {
    if (service == null)
      throw new NullPointerException();

    this.service = service;
  }


  /**
   * prints a map of the user's friends, visible to the user
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  /*
  public
  void
  viewMap {{user→} meet {service→}}
  (
    UserV1 {{user→} meet {service→}} user
  )
  throws
  (
    NullPointerException {user→}
  )
  where
    {service←} <= {user←},
    System.user actsfor user,
    provider <= {user←},
    MapImage.provider <= {user←}
  {
    printMap(user, new label {user→});
  }
  */

  /**
   * prints a map of the user's friends, visible to the user's friends
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  /*
  public
  void
  postMap {user.friends,service→}
  (
    final UserV1 {{user.friends→} meet {service→}} user // why??
  )
  throws
  (
    NullPointerException {user; user←}
  )
  where
    System.user actsfor user.friends,     // because the result gets output to the system user
    provider          <= {user.friends→}, // because the provider can affect the output
    MapImage.provider <= {user←},
    user actsfor user.friends,
    {user} <= {service←}
  {
    if (user == null)
      throw new NullPointerException();

    printMap(user, new label {user.friends→; _←});
  }
  */


  /**
   * Helper method that gets the map and prints it out.
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  /*
  private
  void
  printMap {{*lbl} meet {service→}}
  (
    final UserV1 user,
    final label  lbl
  )
  throws
  (
    NullPointerException {user}
  )
  where
    {service←}  <= lbl,                // because the service influences the map.
    lbl         <= {System.user→; _←}, // because data will be output to the system user
    {user; lbl} <= lbl,
    provider <= {*lbl},               
    MapImage.provider <= {*lbl},
    {user←} <= lbl,
    {user} <= {service→}
  {
    if (user == null)
      throw new NullPointerException();

    MapImage[lbl] result = createMap(lbl, user);
    PrintStream[lbl] out = System.stdout(lbl);

    if (result == null)                                             { throw new AssertionFailedError("createMap() returns a non-null value."); }
    try { result.print(out); } catch (final NullPointerException e) { throw new AssertionFailedError("System.stdout must return a non-null value"); }
  }
  */


  /**
   * creates a map of the user's friends, visible at label l.  Return value is non-null.
   */
  public
  MapImage[l]
  createMap {{*l} meet {service→}}
  (
    final label  {{*l} meet {service→}} l,
    final UserV1 {{*l} meet {service→}} user
  )
  throws
  (
    NullPointerException{user}
  )
  where
    {service←} <= l,
    {user←}    <= l,
    provider   <= l,
    provider   <= {service→}
  {
    // invariant checks
    if (user == null)
      throw new NullPointerException();
    if (user.friends == null)
      throw new AssertionFailedError("user.friends must be non-null");

    // this is the label of the data that gets sent to the service
    final label fetchLabel   = new label {{*l} meet {service→}};

    // compute the bounding box
    Box boundary = new Box(0,0,0,0);

    final GroupIterator[user, fetchLabel] i = user.friends.iterator(fetchLabel);
    if (i == null)
      throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (i.hasNext()) {
      Principal next;
      try { next = i.next(); } catch (NoSuchElementException e) {throw new AssertionFailedError("if i.hasNext() then i.next() should return normally.");}

      if (next instanceof UserV1) {
        final UserV1 friend = (UserV1) next;

        // if the friend doesn't mind his location leaking to the map service,
        // then we expand the bounding box to contain him
        if (friend.locationLabel <= fetchLabel) {
          final Location loc = friend.location;
          if (loc != null) {
            try { boundary = boundary.expand(loc.x, loc.y); }
            catch (final NullPointerException e) { throw new AssertionFailedError("boundary is non-null."); }
          }
        }

        // TODO: declassifiers
        else {
        }

        // otherwise we leave him off the map.
      }
    }

    return null;
    /*
    // get map
    MapImage[fetchLabel] map = this.service.getMap(fetchLabel, boundary);

    // make a local copy (with label l)
    // TODO
    final Store localStore = null;
    final MapImage[l] annotated = map.copy(l, localStore);

    if (annotated == null)          throw new AssertionFailedError("MapImage.copy return value should be non-null");
    if (annotated.boundary == null) throw new AssertionFailedError("Images should all have non-null boundaries");

    // annotate map
    final GroupIterator j = user.friends.iterator(l);
    if (j == null) throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (j.hasNext()) {
      Principal next;
      try { next = j.next(); } catch (NoSuchElementException e) { throw new AssertionFailedError("if j.hasNext() then j.next() should return normally."); }
      if (next instanceof UserV1) {
        final UserV1 friend = (UserV1) next;

        // add friend to the map if possible
        if (friend.locationLabel <= l) {
          final Location loc = friend.location;
          if (loc != null && annotated.boundary.contains(loc.x, loc.y)) {
            try {

              annotated.setAt(loc.x, loc.y, 'f');

            } catch (final ArrayIndexOutOfBoundsException e) {
              throw new AssertionFailedError("if img.boundary.contains(loc) then img.setAt(loc) should return normally");
            }
          }
        }
      }
    }

    return annotated;
    */
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
