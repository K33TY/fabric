package friendmap;

import java.io.PrintStream;

import jif.runtime.Runtime;

import mapserv.MapServer;
import mapserv.MapImage;
import mapserv.Box;
import snapp.UserV1;
import snapp.Location;
import util.GroupIterator;
import util.Delegator;
import util.AssertionFailedError;
import util.NoSuchElementException;
import util.Util;
import util.System;

/**
 * This is the mapping application.  A FriendMap is instantiated with a particular
 * mapping service, and then can be run by any User to generate private or
 * public output maps.
 */
public class FriendMap extends Delegator {
  /** The map service that this app uses to fetch maps.  Must be non-null. */
  public final MapServer {this←} service;

  /**
   * Create a new instance of the mapping service.
   *
   * @throws NullPointerException
   *         if service is null.
   */
  public
  FriendMap {this}
  (
    String    {this} name,
    MapServer {owner←} service,
    Principal {owner←} owner
  )
  throws NullPointerException
  where authority (this), provider <= {this}
  {
    // these endorsements are safe, because owner ≽ this,
    // and thus {owner←} ⊑ {this←}
    // we just can't convince the compiler of this fact.

    this.service = endorse(service, {owner←} to {this←});
    super(name, owner);
  }



  /**
   * prints a map of the user's friends, visible to the user
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  public
  void
  viewMap {user→}
  (
    UserV1 {user→} user
  )
  throws
  (
    NullPointerException {user→}
  )
  where
    service actsfor user.friendInfo,
    {service←} <= {user←},
    System.user actsfor user,
    provider <= {user←},
    MapImage.provider <= {user←}
  {
    printMap(user, new label {user→});
  }

  /**
   * prints a map of the user's friends, visible to the user's friends
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  public
  void
  postMap {user.friends→; _←}
  (
    final UserV1 {user.friends→; _←} user
  )
  throws
  (
    NullPointerException {user; user←}
  )
  where
    System.user actsfor user.friends, // because the result gets output to the system user
    provider <= {user.friends→},      // because the provider can affect the output
    MapImage.provider <= {user←}
  {
    if (user == null)
      throw new NullPointerException();

    printMap(user, new label {user.friends→; _←});
  }


  /**
   * Helper method that gets the map and prints it out.
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  private
  void
  printMap {*lbl}
  (
    final UserV1 user,
    final label  lbl
  )
  throws
  (
    NullPointerException {user}
  )
  where
    {service←}  <= lbl,                // because the service influences the map.
    lbl         <= {System.user→; _←}, // because data will be output to the system user
    {user; lbl} <= lbl,
    provider <= {*lbl},               
    MapImage.provider <= {*lbl}
  {
    if (user == null)
      throw new NullPointerException();

    MapImage[lbl] result = createMap(lbl, user);
    PrintStream[lbl] out = System.stdout(lbl);

    if (result == null)                                             { throw new AssertionFailedError("createMap() returns a non-null value."); }
    try { result.print(out); } catch (final NullPointerException e) { throw new AssertionFailedError("System.stdout must return a non-null value"); }
  }


  /**
   * creates a map of the user's friends, visible at label l.  Return value is non-null.
   */
  public
  MapImage[l]
  createMap
  (
    label l,
    final UserV1 user
  )
  throws
  (
    NullPointerException{user}
  )
  where
    {service←} <= l
  {
    return null;
    /*
    // invariant checks
    if (user == null)
      throw new NullPointerException();
    if (user.friends == null)
      throw new AssertionFailedError("user.friends must be non-null");

    // this is the label of the data that gets sent to the service
    final label serviceLabel = new label {service→};
    // TODO: does the compiler understand this is a meet?
    final label fetchLabel   = new label {*l meet *serviceLabel};

    // compute the bounding box
    Box boundary = new Box(0,0,0,0);

    final GroupIterator i = user.friends.iterator(fetchLabel);
    if (i == null)
      throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (i.hasNext()) {
      Principal next;
      try { next = i.next(); } catch (NoSuchElementException e) {throw new AssertionFailedError("if i.hasNext() then i.next() should return normally.");}

      if (next instanceof UserV1) {
        final UserV1 friend = (UserV1) next;

        // if the friend doesn't mind his location leaking to the map service,
        // then we expand the bounding box to contain him
        if (friend.locationLabel <= fetchLabel) {
          boundary = boundary.expand(friend.location.x, friend.location.y);
        }

        // TODO: declassifiers
        else {
        }

        // otherwise we leave him off the map.
      }
    }

    // get map
    MapImage[fetchLabel] map = this.service.getMap(fetchLabel, boundary);

    // make a local copy (with label l)
    // TODO
    final Store localStore = null;
    final MapImage[l] annotated = map.copy(l, localStore);

    if (annotated == null)          throw new AssertionFailedError("MapImage.copy return value should be non-null");
    if (annotated.boundary == null) throw new AssertionFailedError("Images should all have non-null boundaries");

    // annotate map
    final GroupIterator j = user.friends.iterator(l);
    if (j == null) throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (j.hasNext()) {
      Principal next;
      try { next = j.next(); } catch (NoSuchElementException e) { throw new AssertionFailedError("if j.hasNext() then j.next() should return normally."); }
      if (next instanceof UserV1) {
        final UserV1 friend = (UserV1) next;

        // add friend to the map if possible
        if (friend.locationLabel <= l) {
          final Location loc = friend.location;
          if (loc != null && annotated.boundary.contains(loc.x, loc.y)) {
            try {

              annotated.setAt(loc.x, loc.y, 'f');

            } catch (final ArrayIndexOutOfBoundsException e) {
              throw new AssertionFailedError("if img.boundary.contains(loc) then img.setAt(loc) should return normally");
            }
          }
        }
      }
    }

    return annotated;
  */
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
