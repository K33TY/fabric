package friendmap;

import java.io.PrintStream;

import fabric.runtime.Runtime;

import mapserv.MapServer;
import mapserv.MapImage;
import mapserv.Box;
import snapp.User;
import snapp.Location;
import util.GroupIterator;
import util.Delegator;
import util.AssertionFailedError;
import util.NoSuchElementException;
import util.Util;
import util.System;

/**
 * This is the mapping application.  A FriendMap is instantiated with a particular
 * mapping service, and then can be run by any User to generate private or
 * public output maps.
 */
public class FriendMap
where
  MapServer.provider <= MapImage.provider, MapImage.provider <= MapServer.provider,
  MapServer.provider <= Box.provider,      Box.provider      <= MapServer.provider
{

  /** The map service that this app uses to fetch maps.  Must be non-null. */
  public final MapServer {this} service;

  /**
   * Create a new instance of the mapping service.
   *
   * @throws NullPointerException
   *         if service is null.
   */
  public
  FriendMap {this}
  (
    MapServer {this} service
  )
  throws
    NullPointerException
  where
    provider <= {this}
  {
    if (service == null)
      throw new NullPointerException();

    this.service = service;
  }


  /**
   * prints a map of the user's friends, visible to the user
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  public
  void
  viewMap {{user→} meet {service→}}
  (
    User user
  )
  throws
  (
    NullPointerException{user}
  )
  where
    // the map will be output on standard out
    worker$ actsfor user,

    // these affect the fetch and resulting map
    {user; *provider; *MapServer.provider} <= {user→},
    {user; *provider; *MapServer.provider} <= {service→}
  {
    printMap(user, new label {user→});
  }

  /**
   * prints a map of the user's friends, visible to the user's friends
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  public
  void
  postMap {{user.friends→} meet {service→}}
  (
    final User user
  )
  throws
  (
    NullPointerException {user}
  )
  where
    worker$ actsfor user,
    user        actsfor user.friends,
    {user; *provider; *MapServer.provider} <= {user.friends→},
    {user; *provider; *MapServer.provider} <= {service→}
  {
    if (user == null)
      throw new NullPointerException();

    printMap(user, new label {user.friends→});
  }


  /**
   * Helper method that gets the map and prints it out.
   *
   * @throws NullPointerException
   *         if user is null.
   * @throws SecurityException
   *         under unspecified circumstances (whenever jif.runtime.Runtime[user].getRuntime().stdout() would)
   */
  private
  void
  printMap {{*lbl} meet {service→}}
  (
    final User user,
    final label  lbl
  )
  throws
  (
    NullPointerException {user}
  )
  where
    {service←; user←} <= lbl,        // because the service and the user influence the map.
    lbl               <= {worker$→}, // because data will be output to the system user

    // these components affect the fetch and constructed map 
    {user; lbl; *provider; *MapServer.provider} <= {*lbl},
    {user; lbl; *provider; *MapServer.provider} <= {service→}
  {
    if (user == null)
      throw new NullPointerException();

    MapImage[lbl] result = createMap(lbl, user);
    PrintStream[lbl] out = System.stdout(lbl);

    if (result == null)                                             { throw new AssertionFailedError("createMap() returns a non-null value."); }
    try { result.print(out); } catch (final NullPointerException e) { throw new AssertionFailedError("System.stdout must return a non-null value"); }
  }


  /**
   * creates a map of the user's friends, visible at label l.  Return value is non-null.
   *
   * @throws NullPointerException
   *         if user is null.
   */
  public
  MapImage[l] {*l}
  createMap   {{*l} meet {service→}} // the fact that this call happens leaks to the service and the return value
  (
    final label  l,
    final User user
  )
  throws
  (
    NullPointerException{user}
  )
  where
    {service←} <= l,                      // the result is tainted by the service
    {user←}    <= l,                      // the result is tainted by the user
    {user; l; *provider; *MapServer.provider}
              <= {{*l} meet {service→}}   // the arguments and code can affect the fetch and the return value
  {
    // invariant checks
    if (user == null)
      throw new NullPointerException();
    if (user.friends == null)
      throw new AssertionFailedError("user.friends must be non-null");
    if (this.service == null)
      throw new AssertionFailedError("service must be non-null");

    // this is the label of the data that gets sent to the service
    final label fetchLabel   = new label {{*l} meet {service→}};

    // compute the bounding box
    Box boundary = new Box(0,0,0,0);

    final GroupIterator[user, fetchLabel] i = user.friends.iterator(fetchLabel);
    if (i == null)
      throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (i.hasNext()) {
      Principal next;
      try { next = i.next(); } catch (NoSuchElementException e) {throw new AssertionFailedError("if i.hasNext() then i.next() should return normally.");}

      if (next instanceof User) {
        final User friend = (User) next;

        // if the friend doesn't mind his location leaking to the map service,
        // then we expand the bounding box to contain him
        if (friend.locationLabel <= fetchLabel) {
          final Location loc = friend.location;
          if (loc != null) {
            try { boundary = boundary.expand(loc.x, loc.y); }
            catch (final NullPointerException e) { throw new AssertionFailedError("boundary is non-null."); }
          }
        }

        // TODO: declassifiers
        else {
        }

        // otherwise we leave him off the map.
      }
    }

    // get map
    MapImage[fetchLabel] _map;
    try {
      _map = this.service.getMap(fetchLabel, boundary);
    } catch (final NullPointerException e) {
      throw new AssertionFailedError("boundary is non-null.");
    }
    final MapImage[fetchLabel] map = _map;
    if (map == null)
      throw new AssertionFailedError("getMap returned null");

    // make a local copy (with label l)
    final Store localStore = worker$.getLocalStore();
    MapImage[l] annotated;
    if (new label {localStore←} <= l && l <= new label {localStore→})  // localStore ≽ ℓ
      annotated = map.copy(l, localStore);
    else
      throw new AssertionFailedError("local store does not act for l");


    if (annotated == null)          throw new AssertionFailedError("MapImage.copy return value should be non-null");
    if (annotated.boundary == null) throw new AssertionFailedError("Images should all have non-null boundaries");

    // annotate map
    final GroupIterator[user, l] j = user.friends.iterator(l);
    if (j == null) throw new AssertionFailedError("Group.iterator() should return a non-null value");
    while (j.hasNext()) {
      Principal next;
      try { next = j.next(); } catch (NoSuchElementException e) { throw new AssertionFailedError("if j.hasNext() then j.next() should return normally."); }
      if (next instanceof User) {
        final User friend = (User) next;

        // add friend to the map if possible
        if (friend.locationLabel <= l) {
          final Location loc = friend.location;
          if (loc != null) {
            if (annotated.boundary.contains(loc.x, loc.y)) {
              try { addPin (annotated, loc, friend, l); }
              catch (final NullPointerException e)           { throw new AssertionFailedError("annotated and friend are non-null"); }
              catch (final ArrayIndexOutOfBoundsException e) { throw new AssertionFailedError("if img.boundary.contains(loc) then img.setAt(loc) should return normally"); }
            }
          }
        }
      }
    }

    return annotated;
  }

  /**
   * Add a pin corresponding to friend at a given location on a map.
   *
   * @throws NullPonterException
   *         if friend or map is null
   * @throws ArrayIndexOutOfBoundsException
   *         if location is not on the map
   */
  protected
  void
  addPin {*l}
  (
    final MapImage[l] {*l} map,
    final Location    {*l} location,
    final UserV1      {*l} friend,
    final label       {*l} l
  )
  throws
  (
    NullPointerException{*l},
    ArrayIndexOutOfBoundsException{*l}
  )
  where
    provider             <= l,
    MapImage.provider    <= l
  {
    if (map == null || friend == null || location == null)
      throw new NullPointerException();

    map.setAt(location.x, location.y, 'f');
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
