package util;

public class Meet extends AbstractPrincipal {

//  protected final String {this}@{this->} name;
//
//  protected final Principal{this}@{this->} left;
//  protected final Principal{this}@{this->} right;

  public
  Meet
  (
    String    {this} name,
    Principal {this} left,
    Principal {this} right
  )
  {
//    this.left  = left;
//    this.right = right;
//
//    final String leftName  = (left  == null ? "_" : left.name());
//    final String rightName = (right == null ? "_" : right.name());
//
//    this.name = "(" + leftName + " meet " + rightName + ")";
    super(name);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Principal methods                                                        //
  //////////////////////////////////////////////////////////////////////////////

  /**
   * See Principal.findProofUpto.
   */
  public native
  ActsForProof[{s→}]{this; p; this←; p←; s}
  findProofUpto {this←; ⊥->}
               (Store s, Principal p,
                java.lang.Object searchState);
//  {
//    if (left actsfor this && right actsfor this) {
//
//      ActsForProof leftProof  = PrincipalUtil.findActsForProof(s, p, left,  searchState);
//      ActsForProof rightProof = PrincipalUtil.findActsForProof(s, p, right, searchState);
//
//      if (leftProof != null)
//        return new TransitiveProof@s(leftProof,  left,  new DelegatesProof@s(left, this));
//      if (rightProof != null)
//        return new TransitiveProof@s(rightProof, right, new DelegatesProof@s(right, this));
//      else
//        return null;
//
//    } else throw new AssertionFailedError("left and right act for meet");
//  }

                 
  public void addDelegatesTo{this:;this!:}(principal{this:;this!:} p)
      where caller (this) {
    
  }
  public void removeDelegatesTo{this:;this!:}(principal{this:;this!:} p)
      where caller (this) {
    
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
