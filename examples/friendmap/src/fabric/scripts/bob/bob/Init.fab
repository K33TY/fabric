package bob;

import snapp.Snapp;
import snapp.User;
import snapp.Location;
import snapp.UserWrapper;
import mapserv.MapServer;
import util.AssertionFailedError;

public class Init
where
  provider <= {*←},

  snapp.User.provider        <= snapp.Snapp.provider, snapp.Snapp.provider <= snapp.User.provider,
  snapp.UserWrapper.provider <= snapp.Snapp.provider, snapp.Snapp.provider <= snapp.UserWrapper.provider,
  snapp.User.provider <= snapp.Location.provider,
  snapp.Location.provider <= snapp.User.provider
{
  public static void main {*←} (String[] args)@{*->*} {
    atomic {
      final Store store = worker$.getStore("snapp");
      final Snapp sn = (Snapp) store.getRoot().get("snapp");
      final MapServer serv = (MapServer) store.getRoot().get("mapserv");
      final principal accessors = new principal(((sn,store),serv), worker$);

      if (store actsfor sn
      &&  sn.store$ equiv store
      &&  snapp.Snapp.provider <= new label {*←sn}@store
      ) {

        final User[worker$,sn,accessors]  userBob = sn.createUser("Bob", worker$, accessors);

        if (new label{*->sn} <= new label{*->accessors}) {
           if (userBob.p equiv new principal@store (worker$,sn)) {
             // We get a stack overflow error here at runtime.
             final UserWrapper[{*→sn}] aw = new UserWrapper[{*→sn}]@store(store, worker$, sn, accessors, userBob);
             store.getRoot().put("Bob", aw);

             userBob.locationInfo.add(serv);
       
           } else throw new AssertionFailedError("userBob.p equiv (Bob worker, snapp)");
        } else throw new AssertionFailedError("Data the network sees should flow to the accessor visible data.");
      } else throw new AssertionFailedError("store actsfor snapp");
    }
  }

}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
