package alice;

import fabric.util.Map;

import util.AssertionFailedError;

import snapp.User;
import snapp.UserWrapper;
import snapp.Snapp;


public class AddFriends
where
  // trusted classes are trusted
  util.Group.provider         <= {*←},
  util.GroupIterator.provider <= {*←},
  provider                    <= {*←}
{
  public static
  void
  main
  {
    {*←}
  }
  (
    String[] args
  )@{*->*}
  {
   atomic {
    final Store  snappStore = worker$.getStore("snapp");
    final Map    rootMap    = snappStore.getRoot();
    final Snapp snappP = (Snapp) snappStore.getRoot().get("snapp");
    
    if (snappStore actsfor snappP
            &&  snappP.store$ equiv snappStore
            &&  snapp.Snapp.provider <= new label {*←snappP}@snappStore
            ) {
    

        final UserWrapper[{*→snappP}] aw = (UserWrapper[{*→snappP}]) rootMap.get("alice");
        final UserWrapper[{*→snappP}] bw = (UserWrapper[{*→snappP}]) rootMap.get("bob");

        if (new label{*->snappP} <= new label{*->aw.userAccessors} &&
            new label{*->snappP} <= new label{*->bw.userAccessors}) {
        final User[aw.userOwner,aw.userNetwork,aw.userAccessors] userAlice = aw.user;
        final User[bw.userOwner,bw.userNetwork,bw.userAccessors] bob   = bw.user;

        if (userAlice.p equiv new principal (aw.userNetwork, aw.userOwner) && userAlice.p actsfor userAlice.friends)
            userAlice.friends.add(bw);
        else
            throw new AssertionFailedError("User[n,o].p = (n, o)");
        } else throw new AssertionFailedError("Alice or Bob doesn't allow snapp to access their data");
    } else throw new AssertionFailedError("store actsfor snapp");
  }
      
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
