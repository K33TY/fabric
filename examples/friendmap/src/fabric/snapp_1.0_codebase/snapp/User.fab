package snapp;

import util.Group;
import util.Meet;
import util.AssertionFailedError;


// TODO: comment labels

/**
 * A User object contains all of the data associated with a given user account
 * in the social network.  Users are principals, and delegate to the social
 * network as well as the user who created them.
 *
 * Access label: {*→network}
 * Update label: {_→; *←network,owner}
 */
public class User[principal owner, principal network]
where
  // trusted classes are trusted
  util.Group.provider         <= {*←},
  util.GroupIterator.provider <= {*←},

  // code can flow to fields and field accesses
  provider <= {_→; *←(network,owner)},
  provider <= {*→network}
{
  /** The principal (network,owner) */
  public final principal   {_→; *←(network,owner)}@{*→network} p = new principal(owner,network);

  /** The label {p←;p→locationInfo} */
  public final label       {_→; *←(network,owner)}@{*→network} locationLabel; // Cannot be set as initializer due to jif bug.

  /** The user's friends. non-null.
   *  Contains UserWrapper[*→network] objects */
  public final Group[p,{*→network}]
                           {_→; *←(network,owner)}@{*→network} friends;

  /** The group containing anyone who can see the user's location. non-null.
   *  Contains UserWrapper[*→network] objects */
  public final Group[p,{*→network}]
                           {_→; *←(network,owner)}@{*→network} locationInfo;

  /** The user's location, only readable by members of the locationInfo group. */
  public Location[locationLabel, {*→network}]
                           {_→; *←(network,owner)}@{*→network} location = null;


  /**
   * Create a new user with the given name
   */
  User
  {                           // side effects
    {_→; *←(network,owner)} ⊓ // fields are set
    {*→network}               // this is read
  }
  (
    String name,
    Store  store
  )
  where
    // establish invariants
    store actsfor network,

    // fields updates and accesses are affected by arguments.
    {*provider; store; name} <= {_→; *←network,owner}
  {
    // assert p equiv p
        Group[p,{*→network}] friends_;
        Group[p,{*→network}] locationInfo_;
        label locationLabel_;
        if (p equiv new principal(owner,network)) {

            friends_       = new Group[p,{*→network}]@store(store, name + "'s friends");
            locationInfo_  = new Group[p,{*→network}]@store(store, name + "'s location viewers");
            locationLabel_ = new label {p←;p→locationInfo};

        } else throw new AssertionFailedError("75 (p,q) equiv (p,q)");
        this.friends       = friends_;
        this.locationInfo  = locationInfo_;
        this.locationLabel = locationLabel_;
        super();
  }
}

/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
