package snapp;

import util.AssertionFailedError;
import util.Group;
import util.GroupIterator;
import util.Meet;
import util.NoSuchElementException;
import util.Util;
import snapp.Location;

// TODO: comment labels

/**
 * A User object contains all of the data associated with a given user account
 * in the social network.  Users are principals, and delegate to the social
 * network as well as the user who created them.
 *
 * Access label: {*→network}
 * Update label: {_→; *←network,owner}
 */
public class User[principal owner, principal network, principal accessors]
where
  // trusted classes are trusted
  util.Group.provider         <= {*←},
  util.GroupIterator.provider <= {*←},

  // the owner and network both can access the data
  (owner,network) actsfor accessors,

  // code can flow to fields and field accesses
  provider <= {_→; *←(network,owner)},
  provider <= {*→accessors},
  provider <= Location.provider,
  Location.provider <= provider
{
  /** The principal (network,owner) */
  public final principal   {_→; *←(network,owner)}@{*→accessors} p;

  /** The label {p←;p→locationInfo} */
  public final label       {_→; *←(network,owner)}@{*→accessors} locationLabel; // Cannot be set as initializer due to jif bug.

  /** The user's friends. non-null.
   *  Contains UserWrapper[*→accessors] objects */
  public final Group[p,{*→accessors}]
                           {_→; *←(network,owner)}@{*→accessors} friends;

  /** The group containing anyone who can see the user's location. non-null.
   *  Contains UserWrapper[*→network] objects */
  public final Group[p,{*→accessors}]
                           {_→; *←(network,owner)}@{*→accessors} locationInfo;

  /** The user's location, only readable by members of the locationInfo group. */
  public Location[locationLabel, {*→accessors}]
                           {_→; *←(network,owner)}@{*→accessors} location;


  /**
   * Create a new user with the given name
   */
  User
  {                           // side effects
    {_→; *←(network,owner)} ⊓ // fields are set
    {*→accessors}             // this is read
  }@{*->accessors}
  (
    String name,
    Store  store
  ):{
    {_→; *←(network,owner)} ⊓ // fields are set
    {*→accessors}             // this is read
  }@{*->accessors}
  where
    // establish invariants
    store actsfor network,

    // fields updates and accesses are affected by arguments.
    {*provider; store; name} <= {_→; *←network,owner}
  {
    Group[p,{*→accessors}] friends_;
    Group[p,{*→accessors}] locationInfo_;
    label locationLabel_;
    p = new principal@store(owner,network);

    if (p equiv new principal(owner,network)) {
      friends_       = new Group[p,{*→accessors}]@store(name + "'s friends");
      locationInfo_  = new Group[p,{*→accessors}]@store(name + "'s location viewers");
      locationLabel_ = new label {p←;p→locationInfo}@store;
    } else throw new AssertionFailedError("75 (p,q) equiv (p,q)");

    this.friends       = friends_;
    this.locationInfo  = locationInfo_;
    this.locationLabel = locationLabel_;

    super();
  }

  /**
   * Give me an array of locations (x, y coordinates) of all my friends who
   * allow the given label to read their location.
  public float{*lbl}[@{*->accessors}]{*->}[@{*->accessors}]
  friendsLocations{*->accessors}@{*->accessors}
  (
      final label lbl,
      final Store s
  ):{*->accessors;*lbl}@{*->accessors}
  where
    {lbl} <= {*->accessors},
    provider <= lbl
  {
    // Figure out how big it should be
    int length = 0;
    GroupIterator[p, {*->accessors}, {*->accessors}] i = friends.iterator(store$,
        new label{*->accessors},
        new label{*->accessors});
    for (; i.hasNext();) {
      Principal next;
      try {
        next = i.next();
      } catch (NoSuchElementException e) {
        throw new AssertionFailedError("if i.hasNext() then i.next() should return normally.");
      }
      final UserWrapper[{*→accessors}] fw = (UserWrapper[{*→accessors}]) next;
      final principal          fo = fw.userOwner;
      final principal          fn = fw.userNetwork;
      final principal          fa = fw.userAccessors;
      final User[fo,fn,fa] friend = fw.user;

      if (fa equiv accessors &&
          friend.locationLabel <= lbl)
        length++;
    }
    // fill it up
    i = friends.iterator(store$, new label{*->accessors}, new label{*->accessors});
    float{*lbl}[@{*->accessors}]{*lbl}[@{*->accessors}]{*lbl} data = new float[length][2];
    for (int j = 0; j < length && i.hasNext();) {
      Principal next;
      try {
        next = i.next();
      } catch (NoSuchElementException e) {
        throw new AssertionFailedError("if i.hasNext() then i.next() should return normally.");
      }
      final UserWrapper[{*->accessors}] fw = (UserWrapper[{*->accessors}]) next;
      final principal          fo = fw.userOwner;
      final principal          fn = fw.userNetwork;
      final principal          fa = fw.userAccessors;
      final User[fo,fn,fa] friend = fw.user;

      if (fa equiv accessors &&
          friend.locationLabel <= lbl) {
        Location[friend.locationLabel, {*->fa}] l = friend.location;
        float x = l.x;
        float y = l.y;
        try {
          data[j][0] = x;
          data[j][1] = y;
        } catch (ArrayIndexOutOfBoundsException e) {
          throw new AssertionFailedError("This should not happen");
        }
        j++;
      }
    }
    return data;
  }
   */
}

/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
