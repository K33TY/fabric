package snapp;

import util.Delegator;
import util.AssertionFailedError;
import util.Meet;
import util.Group;
import util.GroupIterator;

/**
 * An instance of Snapp corresponds to an instance of the Snapp social network.
 */
public class Snapp extends Delegator 
where
  provider <= User.provider, User.provider <= provider,
  util.Group.provider <= provider // goes without saying, since Group.provider is bottom
{

  /* The store this object is stored on.  Used for allocating Users. */
  protected final Store {this}@{*->this} store;

  /**
   * Create a new Snapp, operated by owner.
   */
  public
  Snapp {this}
  (
    String    {this} name,
    principal {this} owner,
    Store     {this} store
  )
  where
    provider <= {this}
  {
  	this.store = store;
    super(store, name, owner);
  }

  // TODO: document/fix labels
  public
  User       {this; *<-owner; *provider} // 
  createUser
  {            // side effects:
    {this} ⊓   //
    {*<-owner} //
  }
  (
    String    {this} name,
    principal {this} owner
  )
  where
    provider <= {this}
  {
      // Note: this should always be equal to this.store; it is only here so that
      // we can explicitly annotate object creations (since the checks for implicit
      // store parameters are not implemented in the compiler).
	  User u = null;
	  if (store actsfor this && store actsfor owner) {
		  final principal p = new Meet@store(store, name, this, owner);
		  if (this actsfor p && provider <= new label {⊤←p} && GroupIterator.provider <= new label {⊤←p}) {
			  final Group[p] locationInfo = new Group[p]@store(store, name + "'s location readers");
			  final label locationLabel = new label {p←;locationInfo→}@store;
			  if (store actsfor p && locationLabel <= new label {⊤→store})
			  u = new User[p]@store(name, owner, this, store, locationInfo, locationLabel);
		  }
	  }
	  
	  return u;
  }
}

/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
