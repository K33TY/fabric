/**
 * Copyright (C) 2010-2013 Fabric project group, Cornell University
 *
 * This file is part of Fabric.
 *
 * Fabric is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 * 
 * Fabric is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 */
package mapserv;

import util.AssertionFailedError;
import util.Delegator;

// TODO: comments
// TODO: explicit @store

/**
 * A very simple map service: given a request for a region, it returns a 10x10
 * image containing the background value, scaled to the requested region.
 */
public class MapServer
extends Delegator 
where
  MapImage.provider <= provider, provider <= MapImage.provider,
       Box.provider <= provider, provider <=      Box.provider
{

  private char {_→;*←this}@{*→this.store$} background;

  /**
   * Create a new map server, with the given background character.
   */
  public
  MapServer
  {               // side effects:
    {this} ⊓      // TODO
    {_→; *←this} // TODO
  }
  (
    String {this} name,
    char   {_→; *←this} background
  )
  where
    provider <= {this}
  {
    super(name);

    if (store$ actsfor this
        && provider <= new label{_→;*←this})
      this.background = background;
    else
      throw new AssertionFailedError("49 Delegation failed");
  }

  /**
   * create a new map with the given bounds, containing the background
   * character.
   *
   * @return
   *     a reference to a public image stored at this service
   *
   * @throws NullPointerException
   *     if boundary is null.
   */
  public
  MapImage[l,{*→store$}] {*l}
                       // resulting map will be protected at l
                       // and stored at store
  createMap
  {            // side effects:
    {*l}     ⊓ // result is updated
    {*a}     ⊓ // boundary is accessed
    {*→store$}  // map is created
  }
  (
    label l,
    label a,
    Box[l,a] boundary
  )
  throws
  (
    NullPointerException{*provider;boundary}
  )
  where
    // TODO; store ≽ l@store; map is created at store
    {*←store$} <= l, l <= {*→store$}, {*→store$} <= {*→store$},
    l <= a, // access label for result must bound update label

    // result taints
    {*provider;*←this;boundary;l} <= l,

    // boundary lookup taints
    {*provider;boundary} <= a
  {
    if (boundary == null) throw new NullPointerException("92 boundary is null");

    if (store$ actsfor this) {

    final char{*l}[]{*l} data = new char[100]/* TODO: @store */;
    for (int i = 0; i < data.length; i++)
      data[i] = background;

    try {
      // TODO: solver failing, had to add annotation
      return new MapImage[l,{*→this.store$}]{*l}@store$(boundary, l, a,
                                                      10, 10, data,
                                                      this.store$);

    } catch (final ArrayIndexOutOfBoundsException e) {
      throw new AssertionFailedError("105 10 * 10 = 100");
    } catch (final NullPointerException e) {
      throw new AssertionFailedError("107 boundary and data are non-null");
    }

    } else throw new AssertionFailedError("110 delegators's store actsfor delegatee");
  }
}



/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/

