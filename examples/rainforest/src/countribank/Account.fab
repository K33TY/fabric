package countribank;

public class Account[principal bankP, principal holderP, principal vendorP]
    authority (bankP) where bankP ≽ holderP {
  @{⊤→bankP}

  // XXX There is something unsatisfactory about this label...
  private int{bankP→holderP;bankP←vendorP;vendorP←bankP} balance;

  public Account{bankP→holderP;bankP←vendorP;vendorP←bankP}(
      int{bankP→holderP;bankP←vendorP;vendorP←bankP} balance) {
    this.balance = balance;
  }

  public void credit{holderP→bankP}@{bankP→vendorP;vendorP→bankP}
      (int{holderP→bankP} amount)@{bankP→holderP,vendorP;vendorP→bankP}
      where
        authority(bankP),
        endorse({holderP→bankP;bankP←}) {
    endorse(amount, {holderP→bankP} to {holderP→bankP;bankP←})
    if (amount >= 0) {
      int amount_d =
        declassify (amount, {holderP→bankP;bankP←} to {bankP→holderP;bankP←});
      balance = balance + amount_d;
    }
  }

  // XXX There is something unsatisfactory about this return label.
  //     Shouldn't the integrity be {bankP←}?
  public boolean{holderP,bankP→;bankP←vendorP;vendorP←bankP}
    debit{holderP→bankP;holderP←}@{bankP→}(
      int{holderP→bankP;holderP←} amount
    )@{bankP→holderP} where
      authority(bankP),
      endorse({holderP→bankP;bankP←}) {
    atomic {
      endorse(amount, {holderP→bankP;holderP←} to {holderP→bankP;bankP←})
      if (0 <= amount && amount <= balance) {
        declassify (
            {holderP→bankP;bankP→holderP;bankP←} to {holderP,bankP→;bankP←}) {
          balance = balance - amount;
          return true;
        }
      } else {
        declassify (
            {holderP→bankP;bankP→holderP;bankP←} to {holderP,bankP→;bankP←}) {
          return false;
        }
      }
    }
  }
}
