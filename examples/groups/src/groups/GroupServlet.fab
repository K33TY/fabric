package groups;

import sif.servlet.*;
import auth.*;
import auth.rest.*;
import fabricated.util.Map;
import fabricated.util.HashMap;
import fabricated.util.NoSuchElementException;
import fabricated.util.ConcurrentModificationException;
import fabricated.util.Comparator;
import javax.servlet.ServletException;

public class GroupServlet extends Servlet[worker$] implements AuthServlet[worker$] authority (worker$) {

	final Store{this}@{*->} localStore;
	final Store{this}@{*->} helloStore;

	public GroupServlet{worker$→}() throws ServletException {
	   super();
	   localStore = worker$.getLocalStore();
	   helloStore = worker$.getStore(Config.helloStoreName);
	}

	public void initialize{worker$→; worker$←}() throws ServletException {
	  atomic {
	    final principal p = worker$;
	    addStartAction(new LoginAction[p](this));
	    addStartAction(new LogoffAction[p](this));
	    addStartAction(new CreateUserAction[p](this));
	    
	    addStartAction(new FrontPageAction[p](this));
	    addStartAction(new ListGroupMembersAction[p](this));
	    addStartAction(new CreateGroupAction[p](this));
	    addStartAction(new AddToGroupAction[p](this));
	  }
	}
	
        public String defaultContentType() {
          return "application/json";
        }
        
        public String getPrivateHostID() throws ServletException {
		return "";
	}

	protected String defaultActionName(Request[worker$] req) {
		return Config.defaultActionName;
	} 

	protected AuthSessState{*lbl} createSessionState{*lbl}(label{*lbl} lbl,
			String{*lbl} id, SessionPrincipal{*lbl} session) {
		atomic {
			if (localStore != null && localStore equiv worker$ &&
	                    lbl <= new label {⊤→worker$} && new label {⊤←worker$} <= lbl) {
				return new AuthSessState@localStore(id, session);
			}
		}
		// XXX: lame. really should error here.
		return null;
	}

	protected SessionPrincipal createSessionPrincipal(String{⊥→;⊤←} id) {
		SessionPrincipal toReturn = null;
		atomic {
			if (helloStore != null) {
				toReturn = new SessionPrincipal@helloStore(id);
			}
		}
		return toReturn;
	}

	public principal{p->; p<-} createUser{p->; p<-} (String{p->; p<-} uid, 
                                                     String{p->; p<-} password, 
                                                     principal{p->; p<-} p)
		throws ServletException
		where caller(p), authority (worker$)
	{
		int pc_caller = 0;
		declassify ({pc_caller} meet {_->_}) {
			fabric.util.Map rootMap = helloStore.getRoot();
			if (rootMap == null) {
				throw new ServletException("Store not acceesible");
			}
			Map[{worker$->;worker$<-}] allUsers = null;
			
			Object obj = rootMap.get(Config.usersMapKey);
			if (obj instanceof Map[{worker$->; worker$<-}]) {
				allUsers = (Map[{worker$->; worker$<-}])obj;
			}
			if (allUsers == null) {
				throw new ServletException("Cannot fetch the collection of users from store");
			}
			return addUserToMap(allUsers , uid, password, p);
		}
    }

	private principal{p->;p<-} addUserToMap{p->; p<-} (Map[{worker$->;worker$<-}]{p->; p<-} allUsers, String{p->; p<-} uid, String{p->; p<-} password, principal{p->; p<-} p)
		where caller(p, worker$),
			  endorse({p->; worker$<-})
	{
	  declassify({worker$<-}) {
	    Map[{worker$->; worker$<-}] users = declassify(endorse(allUsers, {p->; worker$<-}), {worker$<-});
	    String userID = declassify(endorse(uid, {p->; worker$<-}), {worker$<-});
	    String _password = declassify(endorse(password, {p->; worker$<-}), {worker$<-});
	    final GroupUser{worker$<-} ret = new GroupUser@helloStore(worker$, userID, _password);
	    if (worker$ actsfor ret) ; else throw new Error("worker$ doesn't act for ret");
	    users.put(userID, ret);
	    
	    declassify( {p->; p<-;worker$<-}) {
	      endorse({p->; p<-}) {
	        GroupUser{p->;p<-} theUser = declassify(endorse(ret, {p->; p<-}), {p->; p<-;worker$<-});
	        return theUser;
	      }
	    }
	  }
	}

	public principal{p->; p<-} lookupUserID{p->; p<-} (String{p->; p<-} uid, principal{p->; p<-} p)
		throws ServletException
		where caller(p),
			  authority (worker$)
	{
	  int pc_caller = 0;
	  declassify ({pc_caller} meet {_->_}) {
	    fabric.util.Map rootMap = helloStore.getRoot();
	    if (rootMap == null) {
	      throw new ServletException("Store not acceesible");
	    }
	    Map[{worker$->;worker$<-}] allUsers = null;
	    Object obj = rootMap.get(Config.usersMapKey);
	    if (obj instanceof Map[{worker$->; worker$<-}]) {
	      allUsers = (Map[{worker$->; worker$<-}])obj;
	    }
	    
	    if (allUsers == null) {
	      throw new ServletException("Cannot fetch the collection of users from store");
	    }
	    return findUserInMap(allUsers, uid, p);
	  }
	}

	private principal{p->;p<-} findUserInMap{p->; p<-} (Map[{worker$->; worker$<-}]{p->; p<-} allUsers, String{p->; p<-} uid, principal{p->; p<-} p)
		where caller(p, worker$),
			  endorse({p->; p<- meet worker$<-})
	{
	  declassify({p<- meet worker$<-}) {
	    GroupUser{p->;p<-} ret = null;
	    Map[{worker$->; worker$<-}] users = declassify(endorse(allUsers, {p->; p<- meet worker$<-}), {p<- meet worker$<-});
	    String userID = declassify(endorse(uid, {p->; p<- meet worker$<-}), {p<- meet worker$<-});
	    final Object o = users.get(userID);
	    if (o != null && new label {worker$->; worker$<-} <= new label {o.store$->}) {
	      if (o instanceof GroupUser) {
	        final GroupUser u = (GroupUser) o;
	        if (worker$ actsfor u
	            && new label {worker$->; worker$<-} <= new label {u.store$->}) {
	          if (u.name().equals(userID)) {
	            declassify({p->}) { endorse({p->;p<-}) { ;
	            ret = declassify(endorse( u,{worker$->;p->;p<-}), {p->});
	            }}
	          }
	        } else { 
	          throw new Error("worker$ doesn't act for user"); 
	        }
	      }
	    }
	    declassify({p->}) {
	      endorse({p->;p<-}) { 
	        return ret;
	      }
	    }
	  }
	}
}

