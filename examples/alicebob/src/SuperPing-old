
/**
 * Copyright (C) 2010-2013 Fabric project group, Cornell University
 *
 * 
 
 This file is part of Fabric.
 *
 * Fabric is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 * 
 * Fabric is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 */
import fabric.util.Map;
import fabric.runtime.Runtime;
import fabricated.util.List;
import fabricated.util.Comparator;
import fabricated.util.IdComparator;
import fabricated.util.ArrayList;
//import fabric.lang.PrincipalUtil;

class SuperPing[label incomingL] {

  private label{incomingL} readFutureRecursion{incomingL}(principal{incomingL} storeP, List[{incomingL}]{incomingL} storeList, int{incomingL} i) {
    if (storeList.size() > i) {
      try {
        final principal entryPrincipal = ((Store) storeList.get(i)).getPrincipal();
        final label entryLabel = new label{storeP → entryPrincipal};
        final label future = readFutureRecursion(storeP, storeList, i+1);
        return (new label{*future ⊓ *entryLabel});
      } catch (IndexOutOfBoundsException e) {
        // there is really no reason for this to happen.
      } catch (ClassCastException e) {
        // there is really no reason for this to happen.
      }
    }
    return (new label{storeP←; storeP→});
  }

  public int incr(int q) {
    return (q+1);
  }

  public Message[{⊥→⊥; ⊥←⊥}]{⊥→⊥; ⊥←⊥} ping{incomingL}(Message[{incomingL}]{incomingL} incoming, List[{incomingL}]{incomingL} storeList, label{incomingL} writePast) {
    final int{incomingL} storeListSize = storeList.size();
    final String{incomingL} incomingMessage = incoming.getMessage();
    final Store store = FabricWorker.getWorker().getLocalStore();
    final principal storeP = store.getPrincipal();
    final label{incomingL} readFuture = readFutureRecursion(storeP, storeList, 0);
    final Runtime[storeP] runtime = Runtime[storeP].getRuntime(); // I'm bloody hoping this can print shit.
    final label storePWrites = new label{⊤←storeP};
    final label storePReads  = new label{⊤→storeP};
        final label{incomingL} readFutureWritePast = new label{*readFuture; *writePast};
    ArrayList[readFutureWritePast]{*readFutureWritePast} futureListA  = null;
      try {
    if (incomingL <= readFutureWritePast  && readFutureWritePast <= storePReads && this.store$ equiv storeP && storePWrites <= readFutureWritePast){
              futureListA = new ArrayList[readFutureWritePast](
                new IdComparator[readFutureWritePast]{*readFutureWritePast}(), storeList.size() - 1);
              for (int{*readFutureWritePast} i = 0; i < futureListA.size(); ++i) {
                futureListA.set(i, storeList.get(i + 1));
              }
           }

    final ArrayList[readFutureWritePast]{*readFutureWritePast} futureList = futureListA;
    final principal top = new principal(⊤);
    final principal runtimeStore = runtime.store$;
    final label runtimeStoreReads = new label{runtimeStore→};
    if ((worker$ equiv storeP) && (storeP equiv store) && top actsfor storeP && top actsfor runtimeStore && runtimeStore equiv storeP && storePReads <= runtimeStoreReads) { // maybe I'm supposed to use  Worker.getLocalWorker()
        // construct a label representing that future stores in the chain can read it, and past stores in the chain can write it.
        
        if ((readFutureWritePast <= storePReads) && (storePWrites <= readFutureWritePast) && (incomingL <= readFutureWritePast)) {
          // Update your locally stored message, and print it out.
          Map root = store.getRoot();
          Message[readFutureWritePast]{*readFutureWritePast} myMessage = (Message[readFutureWritePast]) root.get("myMessage");
          if (myMessage == null) { // if it's not in the store yet, put it there.
            myMessage = new Message[readFutureWritePast]@store("I have, througout history, received the following messages:\n");
            root.put("myMessage", myMessage);
          }
          myMessage.update(myMessage.getMessage() + "\t" + incomingMessage + "\n");
          final String{*readFutureWritePast} myMessageText = myMessage.getMessage();
          runtime.out().println(myMessageText);

          // the recursive case: create a SuperPing object here which is parametrized with the next store
          // (the parameter affects the return value of ping)
          // and call ping on that object, taking place at the head of the list with the tail as argument.
          if (storeListSize != 0) {
            final Store{*readFutureWritePast} nextStore = (Store) storeList.get(0);
            final principal{*readFutureWritePast} nextStoreP = nextStore.getPrincipal();
            final label{*readFutureWritePast} topThinksNextReads = new label{⊤ → nextStoreP};
            if (readFutureWritePast <= topThinksNextReads && nextStore equiv nextStoreP) {
              final SuperPing[readFutureWritePast]{*readFutureWritePast} sp = new SuperPing[readFutureWritePast]();
              // Create a new message to pass forward
              final Message[readFutureWritePast]{*readFutureWritePast} outgoing = new Message[readFutureWritePast](incomingMessage + "!");


              final label{*readFutureWritePast} newWritePast = new label{*writePast ⊓ *storePWrites};
              int{*readFutureWritePast} q = 0;
              sp.incr@nextStore(q);
              final Message[{⊥→⊥; ⊥←⊥}]{⊥→⊥; ⊥←⊥} answer = sp.ping@nextStore(outgoing, futureList, newWritePast);
              return answer;
            } else {
              runtime.out().println("For some reason, readFutureWritePast doesn't flow to topThinksNextReads.");
              return (new Message[{⊥→⊥; ⊥←⊥}]("For some reason, readFutureWritePast doesn't flow to topThinksNextReads."));
            }
          }
        } else {
          runtime.out().println("readFutureWritePast does not flow to StoreReads!");
          return (new Message[{⊥→⊥; ⊥←⊥}]("readFutureWritePast does not flow to StoreReads!"));
        }
    } else {
      runtime.out().println("well, shit. store is not equiv to worker$");
      return (new Message[{⊥→⊥; ⊥←⊥}]("FAIL: well, shit. store is not equiv to worker$"));
    }
      } catch (IndexOutOfBoundsException e) {
        runtime.out().println("something has gone wrong with index bounds. this should not happen.");
        return (new Message[{⊥→⊥; ⊥←⊥}]("FAIL: something has gone wrong with index bounds. this should not happen."));
      } catch (UnsupportedOperationException e) {
        runtime.out().println("this List implementation doesn't implement sublist. great sadness.");
        return (new Message[{⊥→⊥; ⊥←⊥}]("FAIL: this List implementation doesn't implement sublist. great sadness."));
      } catch (ClassCastException e) {
        runtime.out().println("something has gone wrong casting an element of storeList to a Store.");
        return (new Message[{⊥→⊥; ⊥←⊥}]("FAIL: something has gone wrong casting an element of storeList to a Store."));
      }
    // the base case: return END OF LINE. 
    return (new Message[{⊥→⊥; ⊥←⊥}]("END OF LINE"));
  }
}
