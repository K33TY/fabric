/**
 * Copyright (C) 2010-2013 Fabric project group, Cornell University
 *
 * 
 
 This file is part of Fabric.
 *
 * Fabric is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version.
 * 
 * Fabric is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 */
import fabric.util.Map;
import fabric.runtime.Runtime;
//import fabric.lang.PrincipalUtil;

class Ping[principal alice, principal bob] {

  public int{alice→} m1{alice←} () {
    final RemoteWorker w = FabricWorker.getWorker().getWorker("bobnode");
    if (w actsfor bob) {
      int{alice→bob;alice<-} data = 1;
      int{alice→} y = 0;

      // Get a reference to the store called "alicenode".
      final Store alicestore = worker$.getStore("alicenode");
      final Store bobstore   = worker$.getStore("bobnode");

      // Get a reference to the runtime.
      // This is how Fabric programs access the console.
      final Runtime[alice] runtime = Runtime[alice].getRuntime();

      // We're storing p's message on "store", so we must ensure p trusts store.
      if (runtime.store$ actsfor alice) {
        if (alicestore actsfor alice) {
          final label message_label = new label{alice->;alice<-}@alicestore;
          // Create an object at 'store' holding our important message
          Message[message_label] h =
            new Message[message_label]@alicestore("Hello World!  Fabric is coming for you...");

          // Store a reference to our object in the store's root map.
          Map root = alicestore.getRoot();
          root.put("hello", h);

          // Output the contents of the object.
          runtime.out().println(h.getMessage());

        } else {
          runtime.out().println("store is not sufficiently trusted.");
        }
      }

      y = m2@w(data);
      return y;
    }
    return 0;
  }
  
  public int{alice→bob;alice<-bob;bob<-alice} m2{alice←} (int{alice→bob;alice<-bob} x) {
    Runtime[alice].getRuntime().out().println(x);
    final int{alice->bob;alice<-bob;bob<-alice} answer = x+1;
    try {
      // Get a reference to the store called "alicenode".
      //final Store alicestore = worker$.getStore("alicenode");
      final Store bobstore   = worker$.getStore("bobnode");
      final principal alice_meet_bob = new principal@bobstore(alice,bob);
      final label message_label = new label{alice<-alice_meet_bob;bob<-alice_meet_bob;bob->}@bobstore;

      // Get a reference to the runtime.
      // This is how Fabric programs access the console.
      final Runtime[bob] runtime = Runtime[bob].getRuntime();

      // We're storing p's message on "store", so we must ensure p trusts store.
      if (runtime.store$ actsfor alice_meet_bob && runtime.store$ equiv bob) {
        if (bobstore actsfor alice_meet_bob && bob actsfor alice_meet_bob && alice actsfor alice_meet_bob && bobstore equiv bob) {
          Message[message_label] h = (Message[message_label]) bobstore.getRoot().get("hello");
          if (h == null)
            h = new Message[message_label]@bobstore("Bob Hello World!  Fabric is coming for you...");


          // Store a reference to our object in the store's root map.
          Map root = bobstore.getRoot();
          root.put("hello", h);

          // Create an object at 'store' holding our important message
          h = (Message[message_label]) bobstore.getRoot().get("hello");
          final String{message_label} new_message = h.getMessage()+"!";
          h.update(new_message);

          // Output the contents of the object.
          runtime.out().println(h.getMessage());

        } else {
          runtime.out().println("bobstore is not sufficiently trusted.");
        }
      } else {
        runtime.out().println("bobstore is not sufficiently trusted 2.");
      }
    } catch (RuntimeException e) { }
    return answer;
  }
}

