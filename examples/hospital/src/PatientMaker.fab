import fabric.util.Map;
import fabric.runtime.Runtime;

class PatientMaker[
        principal alice,
        principal bob,
        principal carol,
        principal dave,
        label addressLabel,
        label hivLabel,
        label accessLabel,
        label listLabel]
where
listLabel <= {W2R(listLabel)},
addressLabel <= {W2R(addressLabel)},
hivLabel <= {W2R(hivLabel)}
{
  public PatientList[listLabel, addressLabel, hivLabel]{listLabel}
    makePatients{alice← }@{W2R(listLabel)}(Store store, int{listLabel} numPatients):{alice→ ; alice← } 
    where store actsfor alice,
          listLabel    <= {⊤ → store},
          {⊤ ← store } <= listLabel,
          addressLabel <= accessLabel,
          accessLabel  <= {⊤ → store},
          {⊤ ← store}  <= hivLabel,
          hivLabel     <= accessLabel,
          accessLabel  <= {hivLabel ; addressLabel},
          addressLabel <= hivLabel,
          listLabel    <= addressLabel,
          {alice← }    <= listLabel
           {
    PatientList[listLabel,addressLabel, hivLabel]{*listLabel} patientRoot = null;
    atomic {
      PatientList[listLabel,addressLabel, hivLabel]{*listLabel} patients =
        new PatientList[listLabel,addressLabel, hivLabel]@store();
        patientRoot = patients;
      for (int i = 0; i < numPatients; i++) {
        Address[addressLabel, accessLabel] addr = 
          new Address[addressLabel, accessLabel]@store(" " + i + " Wysteria Lane");
        Hiv[hivLabel, accessLabel]{*listLabel} h = 
          new Hiv[hivLabel,accessLabel]@store((i % 2) == 0);
        patients.patient = (new Patient[addressLabel, hivLabel]@store(addr,h));
        if ((i+1) < numPatients) { // avoid the stupid off-by-one issue
          patients.next = new PatientList[listLabel,addressLabel, hivLabel]@store();
          patients = patients.next;
        }
      }
    }
    return patientRoot;
  }
}
