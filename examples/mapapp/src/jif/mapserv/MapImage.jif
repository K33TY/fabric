package mapserv;

import java.io.PrintStream;

import util.Store;
import util.Util;
import util.AssertionFailedError;

/**
 * A simple image class.  The image is indexed by floating point numbers, and
 * stores its own boundary... puts and gets are done relative to the boundary.
 */
public class MapImage[label L] {

  //////////////////////////////////////////////////////////////////////////////
  // public fields                                                            //
  //////////////////////////////////////////////////////////////////////////////

  /* coordinates of map */
  public final Box {L} boundary;

  //////////////////////////////////////////////////////////////////////////////
  // internal state                                                           //
  //////////////////////////////////////////////////////////////////////////////

  /* packed data */
  protected final int{L}       width;
  protected final int{L}       height;
  protected final char{L}[]{L} data;

  //////////////////////////////////////////////////////////////////////////////
  // public methods                                                           //
  //////////////////////////////////////////////////////////////////////////////

  /**
   * Create a new image with the given boundary and data.
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if the given width and height do not match the size of the data.
   * @throws NullPointerException
   *         if either data or boundary is null
   */
  public
  MapImage
  (
    Box boundary,
    int width, int height, char[] data
  )
  throws
    ArrayIndexOutOfBoundsException,
    NullPointerException
  {
    if (data == null || boundary == null)
      throw new NullPointerException();

    if (width * height != data.length)
      throw new ArrayIndexOutOfBoundsException();

    this.width  = width;
    this.height = height;
    this.data   = data;

    this.boundary = boundary;
  }

  /**
   * Get the pixel corresponding to the global location (x,y).
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if (x,y) lies outside the bounding box of the image.
   */
  public char getAt(float x, float y) throws ArrayIndexOutOfBoundsException {
    if (this.data == null)
      throw new AssertionFailedError("data must be non-null");

    return data[index(x,y)];
  }

  /**
   * Set the pixel corresponding to the global location (x,y).
   *
   * @throws ArrayIndexOutOfBoundsException
   *         if (x,y) lies outside the bounding box of the image.
   */
  public void setAt(float x, float y, char value) throws ArrayIndexOutOfBoundsException {
    if (this.data == null)
      throw new AssertionFailedError("data must be non-null");

    data[index(x,y)] = value;
  }

  /**
   * Create a deep copy of this image on store s with label l.
   */
  public
  MapImage[l]
  copy
  (
    label l,
    Store s
  )
  where
    L <= l
  {
    try {

      return new MapImage[l] (boundary.copy(l,s), width, height, Util.copyArray(data, L, L, l, l, s));

    } catch (final NullPointerException e) {
      throw new AssertionFailedError("data and boundary must be non-null");
    } catch (final ArrayIndexOutOfBoundsException e) {
      throw new AssertionFailedError("width * height = data.length = Util.copyArray(data, ...).length");
    }
  }


  /**
   * Print image to the given output stream.
   */
  public void print(PrintStream[L] out) {

    try {
      out.println("(" + boundary.xmin + ", " + boundary.ymin + ")");
      for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
          try {

            out.print(data[i*width + j]);

          } catch (final ArrayIndexOutOfBoundsException e) {
            // claim: i*width + j < data.length
            // proof:
            //  0 <= i <= height - 1
            //  0 <= j <= width  - 1
            //  i*width + j <= (height - 1) * width + width - 1
            //               = height * width - 1
            //               < data.length
            throw new AssertionFailedError ("width * height = data.length");
          }
        }
        out.println();
      }

      for (int j = 0; j < width; j++)
        out.print(' ');

      out.println("(" + boundary.xmax + ", " + boundary.ymax + ")");

    } catch (final NullPointerException e) {
      throw new AssertionFailedError("boundary and data must be non-null.");
    }
  }


  //////////////////////////////////////////////////////////////////////////////
  // private helper methods                                                   //
  //////////////////////////////////////////////////////////////////////////////

  /** Return the index into data corresponding to the global coordinates (x,y).
   *  Note that if (x,y) is outside the boundary, the result will be outside the bounds
   *  of the data array.
   */
  private int index(float x, float y) {
    if (this.boundary == null)
      throw new AssertionFailedError("boundary must be non-null");

    int xoff = (int) (width  * boundary.scale_x(x));
    int yoff = (int) (height * boundary.scale_y(y));

    return yoff * width + xoff;
  }
}


/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/
