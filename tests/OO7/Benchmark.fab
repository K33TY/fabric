// You can redistribute this software and/or modify it under the terms of
// the Ozone Core License version 1 published by ozone-db.org.
//
// The original code and portions created by Thorsten Fiebig are
// Copyright (C) 2000-@year@ by Thorsten Fiebig. All rights reserved.
// Code portions created by SMB are
// Copyright (C) 1997-@year@ by SMB GmbH. All rights reserved.
//
// $Id: Benchmark.fab,v 1.11 2008-01-17 21:12:45 mdgeorge Exp $

package OO7;

import fabric.util.*;
import java.util.Random;
import java.net.URI;
import fabric.util.HashMap;

import fabric.client.Core;
import fabric.client.Client;

public class Benchmark {
  // data base parameters
  private final static int LARGE  = 3;
  private final static int MEDIUM = 2;
  private final static int SMALL  = 1;
  private final static int TINY   = 0;

  private final static Core local = Client.getClient().getLocalCore();

  // TODO: these shouldn't be @local, they should be @static (whatever that
  // means) but our implementation of static stuff makes it not matter yet

  //                            Database paramters                   TINY  SMALL  MEDIUM LARGE
  private final static int[]    numAtomicPerComp = new int[]@local    { 20,   20,    200,   200    };
  private final        int      numConnPerAtomic;                     
  private final static int[]    documentSize     = new int[]@local    { 20,   2000,  20000, 20000  };
  private final static double[] manualSize       = new double[]@local { 1e3,  100e3, 1e6,   1e6    };
  private final static int[]    numCompPerModule = new int[]@local    { 5,    500,   500,   500    };
  private final static int[]    numAssmPerAssm   = new int[]@local    { 3,    3,     3,     3      };
  private final static int[]    numAssmLevels    = new int[]@local    { 3,    7,     7,     7      };
  private final static int[]    numCompPerAssm   = new int[]@local    { 3,    3,     3,     3      };
  private final static int[]    numModules       = new int[]@local    { 1,    1,     1,     10     };

  private static final Random rand = new Random();

  int scale = 0;
  int maxId = 10;
  
  protected Core moduleCore;
  protected Core assemblyCore;
  protected Core partCore;
  protected Core documentCore;
  
  //////////////////////////////////////////////////////////////////////////////
  // Database traversals                                                      //
  //////////////////////////////////////////////////////////////////////////////

  /* TODO: extract into a separate traversal
  public void matchQuery() throws Exception {
    // generate a random list of objects to fetch
    Core local = Client.getClient().getLocalCore();
    int[] oids = new int[1000]@local;
    Map atomicParts = atomicPartsById();

    atomic {
      for (int i = 0; i < oids.length; ++i)
        oids[i] = rand.nextInt(atomicParts.size());
    }

    // access each
    long time = System.currentTimeMillis();
    for (int i = 0; i < oids.length; ++i) {
      AtomicPart part = (AtomicPart) atomicParts.get(new Integer@local(oids[i]));
      long x = part.x();
    }
    time = (System.currentTimeMillis() - time);
    System.out.println("Millis: " + time);
  }
  */

  //////////////////////////////////////////////////////////////////////////////
  // Extents                                                                  //
  //////////////////////////////////////////////////////////////////////////////

  // Note: each class is responsible for maintaining its own extents.
  Map/*Integer,AtomicPart*/    atomicPartsById;
  //Map/*Long,AtomicPart*/       atomicPartsByBuildDate;
  Map/*Integer,CompositePart*/ compositePartsById;
  //Map/*String,Document*/       documentsByTitle;
  Map/*Integer,Document*/      documentsById;
  Map/*Integer,BaseAssembly*/  baseAssembliesById;
  Map/*Integer,Module*/        modulesById;

  public Map atomicPartsById() {
    return atomicPartsById;
    // TODO: return Collections.unmodifiableMap(atomicPartsById);
  }

  /* This index isn't implemented because it requires multimaps
  public Map atomicPartsByBuildDate() {
    return atomicPartsByBuildDate;
    // TODO: return Collections.unmodifiableMap(atomicPartsByBuildDate);
  }*/

  public Map compositePartsById() {
    return compositePartsById;
    // TODO: return Collections.unmodifiableMap(compositePartsById);
  }

  /* This index isn't implemented because it requires multimaps
  public Map documentsByTitle() {
    return documentsByTitle;
    //TODO: return Collections.unmodifiableMap(documentsByTitle);
  }
  */

  public Map documentsById() {
    return documentsById;
    // TODO: return Collections.unmodifiableMap(documentsById);
  }

  public Map baseAssembliesById() {
    return baseAssembliesById;
    // TODO: return Collections.unmodifiableMap(baseAssembliesById);
  }

  public Map modulesById() {
    return modulesById;
    // TODO: return Collections.unmodifiableMap(modulesById);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Database creation                                                        //
  //////////////////////////////////////////////////////////////////////////////

  /** Return an unused identifier.
   */
  int newId() {
    return maxId++;
  }
  
  /** Create a benchmark of the corresponding size.
    *
    * @param scale either TINY, SMALL, MEDIUM or LARGE
    * @param numConnPerAtomic the fan-out value (either 3, 6 or 9)
    */
  
  public Benchmark(int scale,       int numConnPerAtomic,
                   Core moduleCore, Core assemblyCore,
                   Core partCore,   Core documentCore)
         throws Exception {
    this.moduleCore    = moduleCore;
    this.assemblyCore  = assemblyCore;
    this.partCore      = partCore;
    this.documentCore = documentCore;

    this.scale = scale;
    this.numConnPerAtomic = numConnPerAtomic;
    
    // Initialize extents
    this.atomicPartsById        = new HashMap@partCore();
    //this.atomicPartsByBuildDate = new HashMap@partCore();
    this.compositePartsById     = new HashMap@partCore();
    //this.documentsByTitle       = new HashMap@documentCore();
    this.documentsById          = new HashMap@documentCore();
    this.baseAssembliesById     = new HashMap@assemblyCore();
    this.modulesById            = new HashMap@moduleCore();

    // Create content
    for (int i = 0; i < numModules[scale]; i++)
      createModule();
  }

  protected Module createModule() throws Exception {
    Core local = Client.getClient().getLocalCore();
    CompositePart[] compositeParts =
        new CompositePart[numCompPerModule[scale]]@local;
    for (int i = 0; i < numCompPerModule[scale]; ++i)
      compositeParts[i] = createCompositePart();

    Module module = new Module@moduleCore(this);
    ComplexAssembly designRoot =
        (ComplexAssembly) createAssembly(module, numAssmLevels[scale],
            compositeParts);

    module.setDesignRoot(designRoot);
    module.setManual(new Manual@documentCore((int) manualSize[scale]));

    return module;
  }

  protected CompositePart createCompositePart() throws Exception {
    Core local = Client.getClient().getLocalCore();
    CompositePart compositePart = new CompositePart@partCore(this);
    compositePart.setDocumentation(new Document@documentCore(this, documentSize[scale]));

    AtomicPart[] parts = new AtomicPart[numAtomicPerComp[scale]]@local;
    for (int i = 0; i < parts.length; ++i) {
      parts[i] = createAtomicPart(compositePart);
      compositePart.addPart(parts[i]);
    }
    compositePart.setRootPart(parts[0]);

    for (int i = 0; i < parts.length; ++i) {
      // Add a connection to i's neighbor
      Connection c =
          new Connection@partCore(parts[i], parts[(i + 1) % parts.length]);

      // add random connections
      for (int j = 0; j < (numConnPerAtomic - 1); ++j) {
        c = new Connection@partCore(parts[i], parts[rand.nextInt(parts.length)]);
      }
    }

    return compositePart;
  }

  protected AtomicPart createAtomicPart(CompositePart parent) throws Exception {
    AtomicPart result = new AtomicPart@partCore(this);
    result.setPartOf(parent);

    return result;
  }

  protected Assembly createAssembly(Module parent, int level,
      CompositePart[] available) throws Exception {
    if (level == 1) {
      // create base assembly
      BaseAssembly result = new BaseAssembly@assemblyCore(this);
      parent.addAssembly(result);

      for (int j = 0; j < numCompPerAssm[scale]; ++j) {
        int k = rand.nextInt(available.length);
        result.addComponentsShar(available[k]);
      }

      return result;
    } else {
      // create complex assembly
      ComplexAssembly result = new ComplexAssembly@assemblyCore(this);
      parent.addAssembly(result);

      for (int i = 0; i < numAssmPerAssm[scale]; ++i)
        result.addSubAssembly(createAssembly(parent, level - 1, available));
      return result;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // main                                                                     //
  //////////////////////////////////////////////////////////////////////////////

  public static void main(String[] args) {
    if (args.length < 3 || args.length % 2 == 0) {
      printUsage();
      System.exit(1);
    }

    try {
      long start = System.currentTimeMillis();

      URI  path = new URI(args[0]);
      Core core = fabric.client.Client.getClient().getCore(path.getHost());
      Map  root = (Map) core.getRoot();

      int scale = -1;
      if (args[1].equalsIgnoreCase("TINY")) {
        scale = TINY;
      } else if (args[1].equalsIgnoreCase("SMALL")) {
        scale = SMALL;
      } else if (args[1].equalsIgnoreCase("MEDIUM")) {
        scale = MEDIUM;
      } else if (args[1].equalsIgnoreCase("LARGE")) {
        scale = LARGE;
      } else {
        printUsage();
        System.out.println("Invalid scale");
        System.exit(1);
      }

      int fanout = Integer.parseInt(args[2]);

      Core moduleCore    = core;
      Core assemblyCore  = core;
      Core partCore      = core;
      Core documentCore = core;

      for (int i = 3; i < args.length; i++) {
        if (args[i].equals("--assemblies"))
          assemblyCore = Client.getClient().getCore(args[i+1]);
        else if (args[i].equals("--modules"))
          moduleCore = Client.getClient().getCore(args[i+1]);
        else if (args[i].equals("--parts"))
          partCore = Client.getClient().getCore(args[i+1]);
        else if (args[i].equals("--documents"))
          documentCore = Client.getClient().getCore(args[i+1]);
        else {
          printUsage();
          System.exit(1);
        }
      }

      atomic {
        root.put(path.getPath(), new Benchmark@core(scale, fanout, moduleCore, assemblyCore, partCore, documentCore));
      }

      System.out.println("elapsed time: " + (System.currentTimeMillis() - start)
          + "msec");

    } catch (Exception e) {
      System.out.println(e);
      e.printStackTrace();
    }
  }

  static void printUsage() {
    System.out.println("usage: tailor Benchmark <path> <size> <fanout> [options]");
    System.out.println("  creates a OO7 database and places it at the given path.");
    System.out.println("");
    System.out.println("  <path>    should be a fabric URI, eg. \"fab://localhost/OO7\"");
    System.out.println("  <size>    should be one of \"tiny\", \"small\", \"medium\", or \"large\"");
    System.out.println("  <fanout>  can be any number, but the standard values are 3, 6 and 9");
    System.out.println(" [options] may include any of the following:");
    System.out.println("  --assemblies <host>   place the assemblies at the given core.");
    System.out.println("  --modules    <host>   place the modules at the given core.");
    System.out.println("  --parts      <host>   place the parts at the given core.");
    System.out.println("  --documents  <host>   place the documents at the given core.");
  }

}

/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/

