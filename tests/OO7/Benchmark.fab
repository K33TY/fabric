// You can redistribute this software and/or modify it under the terms of
// the Ozone Core License version 1 published by ozone-db.org.
//
// The original code and portions created by Thorsten Fiebig are
// Copyright (C) 2000-@year@ by Thorsten Fiebig. All rights reserved.
// Code portions created by SMB are
// Copyright (C) 1997-@year@ by SMB GmbH. All rights reserved.
//
// $Id: Benchmark.fab,v 1.8 2007-12-23 06:29:08 jed Exp $

package OO7;

import fabric.util.*;
import java.util.Random;
import java.net.URI;
import fabric.util.HashMap;

import fabric.client.Core;
import fabric.client.Client;

public class Benchmark {
  // data base parameters
  private final static int LARGE  = 3;
  private final static int MEDIUM = 2;
  private final static int SMALL  = 1;
  private final static int TINY   = 0;

  private final static Core local = Client.getClient().getLocalCore();

  //                            Database paramters                   TINY  SMALL  MEDIUM LARGE
  private final static int[]    numAtomicPerComp = new int[]@local    { 20,   20,    200,   200    };
  private final        int      numConnPerAtomic;                     
  private final static int[]    documentSize     = new int[]@local    { 20,   2000,  20000, 20000  };
  private final static double[] manualSize       = new double[]@local { 1e3,  100e3, 1e6,   1e6    };
  private final static int[]    numCompPerModule = new int[]@local    { 5,    500,   500,   500    };
  private final static int[]    numAssmPerAssm   = new int[]@local    { 3,    3,     3,     3      };
  private final static int[]    numAssmLevels    = new int[]@local    { 3,    7,     7,     7      };
  private final static int[]    numCompPerAssm   = new int[]@local    { 3,    3,     3,     3      };
  private final static int[]    numModules       = new int[]@local    { 1,    1,     1,     10     };

  private final static String database = "OO7 Database";

  private static final Random rand = new Random();

  int scale = 0;
  // TODO: expose extents
  Module module = null;
  HashMap atomicParts = null;

  //////////////////////////////////////////////////////////////////////////////
  // Database traversals                                                      //
  //////////////////////////////////////////////////////////////////////////////

  public void matchQuery() throws Exception {
    // generate a random list of objects to fetch
    Core local = Client.getClient().getLocalCore();
    int[] oids = new int[1000]@local;
    atomic {
      for (int i = 0; i < oids.length; ++i)
        oids[i] = rand.nextInt(atomicParts.size());
    }

    // access each
    long time = System.currentTimeMillis();
    for (int i = 0; i < oids.length; ++i) {
      AtomicPart part = (AtomicPart) atomicParts.get(new Integer@local(oids[i]));
      long x = part.x();
    }
    time = (System.currentTimeMillis() - time);
    System.out.println("Millis: " + time);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Database creation                                                        //
  //////////////////////////////////////////////////////////////////////////////

  /** Create a benchmark of the corresponding size.
    *
    * @param scale either TINY, SMALL, MEDIUM or LARGE
    * @param numConnPerAtomic the fan-out value (either 3, 6 or 9)
    */
  public Benchmark(int scale, int numConnPerAtomic) throws Exception {
    this.scale = scale;
    this.numConnPerAtomic = numConnPerAtomic;
    this.atomicParts = new HashMap();
    this.module = createModule();
  }

  protected Module createModule() throws Exception {
    Core local = Client.getClient().getLocalCore();
    CompositePart[] compositeParts =
        new CompositePart[numCompPerModule[scale]]@local;
    for (int i = 0; i < numCompPerModule[scale]; ++i)
      compositeParts[i] = createCompositePart();

    Module module = new Module();
    ComplexAssembly designRoot =
        (ComplexAssembly) createAssembly(module, numAssmLevels[scale],
            compositeParts);
    module.setDesignRoot(designRoot);

    return module;
  }

  protected CompositePart createCompositePart() throws Exception {
    Core local = Client.getClient().getLocalCore();
    CompositePart compositePart = new CompositePart();
    compositePart.setDocumentation(new Document());

    AtomicPart[] parts = new AtomicPart[numAtomicPerComp[scale]]@local;
    for (int i = 0; i < parts.length; ++i) {
      parts[i] = createAtomicPart(compositePart);
      compositePart.addPart(parts[i]);
    }
    compositePart.setRootPart(parts[0]);

    for (int i = 0; i < parts.length; ++i) {
      // Add a connection to i's neighbor
      Connection c =
          new Connection(parts[i], parts[(i + 1) % parts.length]);

      // add random connections
      for (int j = 0; j < (numConnPerAtomic - 1); ++j) {
        c = new Connection(parts[i], parts[rand.nextInt(parts.length)]);
      }
    }

    return compositePart;
  }

  protected AtomicPart createAtomicPart(CompositePart parent) throws Exception {
    AtomicPart result = new AtomicPart();
    atomicParts.put(new Integer(atomicParts.size()), result);
    result.setPartOf(parent);
    return result;
  }

  protected Assembly createAssembly(Module parent, int level,
      CompositePart[] available) throws Exception {
    if (level == 1) {
      // create base assembly
      BaseAssembly result = new BaseAssembly();
      parent.addAssembly(result);

      for (int j = 0; j < numCompPerAssm[scale]; ++j) {
        int k = rand.nextInt(available.length);
        result.addComponentsShar(available[k]);
      }

      return result;
    } else {
      // create complex assembly
      ComplexAssembly result = new ComplexAssembly();
      parent.addAssembly(result);

      for (int i = 0; i < numAssmPerAssm[scale]; ++i)
        result.addSubAssembly(createAssembly(parent, level - 1, available));
      return result;
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // main                                                                     //
  //////////////////////////////////////////////////////////////////////////////

  public static void main(String[] args) {
    if (args.length != 3) {
      printUsage();
      System.exit(1);
    }

    try {
      long start = System.currentTimeMillis();

      URI  path = new URI(args[0]);
      Core core = fabric.client.Client.getClient().getCore(path.getHost());
      Map  root = (Map) core.getRoot();

      int scale = -1;
      if (args[1].equalsIgnoreCase("TINY")) {
        scale = TINY;
      } else if (args[1].equalsIgnoreCase("SMALL")) {
        scale = SMALL;
      } else if (args[1].equalsIgnoreCase("MEDIUM")) {
        scale = MEDIUM;
      } else if (args[1].equalsIgnoreCase("LARGE")) {
        scale = LARGE;
      } else {
        printUsage();
        System.out.println("Invalid scale");
        System.exit(1);
      }

      int fanout = Integer.parseInt(args[2]);

      atomic {
        root.put(path.getPath(), new Benchmark@core(scale, fanout));
      }

      System.out.println("elapsed time: " + (System.currentTimeMillis() - start)
          + "msec");

    } catch (Exception e) {
      System.out.println(e);
      e.printStackTrace();
    }
  }

  static void printUsage() {
    System.out.println("usage: tailor Benchmark <path> <size> <fanout>");
    System.out.println("  creates a OO7 database and places it at the given path.");
    System.out.println("");
    System.out.println("  - <path> should be a fabric URI, eg. \"fab://localhost/OO7\"");
    System.out.println("  - <size> should be one of \"tiny\", \"small\", \"medium\", or \"large\"");
    System.out.println("  - <fanout> can be any number, but the standard values are 3, 6 and 9");
  }

}

/*
** vim: ts=2 sw=2 et cindent cino=\:0 syntax=java
*/

