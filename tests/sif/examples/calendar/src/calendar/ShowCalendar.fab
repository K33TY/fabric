package calendar;

import jif.util.*;
import userserv.*;
import sif.servlet.*;
import sif.html.*;

import javax.servlet.ServletException;

public class ShowCalendar extends UAction[CalServEP] {
    public ShowCalendar(Main{this} m) throws ServletException {
        super("show", m);
        
    }
    public void invokeImpl{*lbl}(label{*lbl} lbl,
            Request[CalServEP]{*lbl} req,
            UServlet[CalServEP]{*lbl} uservlet,
            USessState[CalServEP]{*lbl} ustate) 
    throws (ServletException{*lbl;req.session!:})
            where caller(req.session),
            lbl <= {*:req.session},
            req.session equiv ustate.sessionPrincipal
    {
        if (req == null || uservlet == null || ustate == null || 
                !(uservlet instanceof Main) || 
                !(ustate instanceof CalendarSessionState)) 
            throw new ServletException("invalid args");

        final Main servlet = (Main)uservlet;
        final CalendarSessionState state = (CalendarSessionState)ustate;
        
        // Direct the user to a session-specific show calendar action.
        // We store this session-specific action in the state, so that we
        // can reuse it.
        if (state.sessionPrincipal equiv req.session) {
            if (state.state == null) {
                // create a new state
                if (lbl <= new label {req.session!:}) {
                    final User[CalServEP]{req.session!:} currentUser = state.currentUser();
                    if (req.session actsfor currentUser) {
                        State s = new State(currentUser, 
                                            new Date[{currentUser!:}](), 
                                            ShowCalendarSessAction$1.DISPLAY_KIND_MONTH, 
                                            currentUser);
                        state.state = s;
                    }
                }
            }

            final State{*lbl;req.session!:} s = state.state;
            if (s == null) {                
                throw new ServletException("no state");
            }
            
            if (lbl <= new label {s.currentUser!:} && req.session actsfor s.currentUser) {
                if (state.scsa == null) {
                    // hasn't yet been created.
                    ShowCalendarSessAction scsa = new ShowCalendarSessAction(servlet, req.session, s.currentUser);
                    updateState(state, scsa, s.currentUser);
                }
                
                ServletException{*lbl;req.session!:} ex = null;
                
                final ShowCalendarSessAction scsa = state.scsa;
                if (scsa != null && s != null && req.session equiv scsa.session) {       
                    try {
                        final User[CalServEP] currentUser = s.currentUser;
                        scsa.invokeSessImpl(lbl, req, servlet, ustate, currentUser);
                    }
                    catch (ServletException e) {
                        ex = e;
                    }
                }
                if (ex != null) throw ex;
            }
        }
        
    }
    
    private void updateState{p!:}(CalendarSessionState{p!:} sessState, 
            ShowCalendarSessAction{p!:} scsa, 
            principal{p!:} p)
    where caller(sessState.sessionPrincipal), sessState.sessionPrincipal  actsfor p, endorse({sessState.sessionPrincipal!:}) 
    {
        if (endorse(sessState, {sessState.sessionPrincipal!:}) == null) return;
        final CalendarSessionState ss = endorse(sessState, {p!:} to {sessState.sessionPrincipal!:});
        final principal sess = endorse(sessState.sessionPrincipal, {p!:} to {sessState.sessionPrincipal!:});
        if (ss.sessionPrincipal equiv sess)
            ss.scsa = endorse(scsa, {p!:} to {sessState.sessionPrincipal!:});
    }
        
}

