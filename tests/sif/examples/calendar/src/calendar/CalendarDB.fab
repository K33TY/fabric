package calendar;

import userserv.*;

import jif.lang.LabelUtil;
import fabricated.util.HashSet;
import fabricated.util.Set;
import fabricated.util.Date;
import fabricated.util.Iterator;
import fabricated.util.NoSuchElementException;
import jif.util.List;
import jif.util.LinkedList;

/**
 * A Calendar holds the persistent state of the entire calendar system.
 */
public class CalendarDB authority(CalServEP, CalRootEP) {

	// TODO: This should be replaced with a map (ConcurrentHashMap?)
	private User[CalServEP, {CalServEP→;CalServEP←}]{CalServEP:;CalServEP!:}[]{CalServEP:;CalServEP!:} users;

	// counter for unique ids for events
	private int{CalServEP:;CalServEP!:} uidCounter = 0;

	// central repository of events.
	private Set[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} events;

	// TODO XXX : Establish relations between coreClient, client and CalServEP
	private final Core{CalServEP:;CalServEP!:} backend;
	private final RemoteClient{CalServEP:;CalServEP!:} coreClient;
	final Core{CalServEP:;CalServEP!:} localCore;

	public CalendarDB{CalServEP:;CalServEP!:}(Core{CalServEP:;CalServEP!:} core) {
		backend = core;
		FabricClient local = FabricClient.getClient();
		if(local != null && backend != null) {
		    coreClient = local.getClient(backend.name());
		    localCore = local.getLocalCore();
		} else {
		    coreClient = null;
		    localCore = null;
		}
		// fabric init stuff here
	}

	public void initialize{CalServEP:;CalServEP!:}() {
		// There's a bug here, I can't put the new statements directly in the array initializer.
		atomic {
			User[CalServEP, {CalServEP→;CalServEP←}] a = new CalUser[{CalServEP→;CalServEP←}]("liujed", "password", "Jed", "Liu");
			User[CalServEP, {CalServEP→;CalServEP←}] b = new CalUser[{CalServEP→;CalServEP←}]("kvikram", "password", "Krishnaprasad", "Vikram");
			User[CalServEP, {CalServEP→;CalServEP←}] c = new CalUser[{CalServEP→;CalServEP←}]("andru", "password", "Andrew", "Myers");
			User[CalServEP, {CalServEP→;CalServEP←}] d = new CalUser[{CalServEP→;CalServEP←}]("schong", "password", "Steve", "Chong");
			User[CalServEP, {CalServEP→;CalServEP←}] e = new CalUser[{CalServEP→;CalServEP←}]("michael", "password", "Michael", "Clarkson");
			User[CalServEP, {CalServEP→;CalServEP←}] f = new CalUser[{CalServEP→;CalServEP←}]("nate", "password", "Nathaniel", "Nystrom");
			User[CalServEP, {CalServEP→;CalServEP←}] g = new CalUser[{CalServEP→;CalServEP←}]("xin", "password", "Xin", "Qi");
			User[CalServEP, {CalServEP→;CalServEP←}] h = new CalUser[{CalServEP→;CalServEP←}]("mdgeorge", "password", "Michael", "George");
			User[CalServEP, {CalServEP→;CalServEP←}] i = new CalUser[{CalServEP→;CalServEP←}]("lantian", "password", "Lantian", "Zheng");
			User[CalServEP, {CalServEP→;CalServEP←}] j = new CalUser[{CalServEP→;CalServEP←}]("maksim", "password", "Maksim", "Orlovich");
			User[CalServEP, {CalServEP→;CalServEP←}] k = new CalUser[{CalServEP→;CalServEP←}]("siggi", "password", "Sigmund", "Cherem");
			User[CalServEP, {CalServEP→;CalServEP←}] l = new CalUser[{CalServEP→;CalServEP←}]("radu", "password", "Radu", "Rugina");

//			users = new User[CalServEP]@backend[] { a,b,c,d,e,f,g,h,i,j,k,l };
            users = new User[CalServEP, {CalServEP→;CalServEP←}][12]@backend;
            try {
                users[0] = a;
                users[1] = b;
                users[2] = c;
                users[3] = d;
                users[4] = e;
                users[5] = f;
                users[6] = g;
                users[7] = h;
                users[8] = i;
                users[9] = j;
                users[10] = k;
                users[11] = l;
            } catch (ArrayIndexOutOfBoundsException imposs) {}
              catch (NullPointerException imposs) {}

              if(backend actsfor CalServEP) {
                  events = new HashSet[{CalServEP:;CalServEP!:}]@backend();
              }
		}
	}

	public int{CalServEP:;CalServEP!:}
	getFreshUid{CalServEP:;CalServEP!:}()
	where authority(CalServEP) {
		atomic {
			return uidCounter++;
		}
	}
	
	public User[CalServEP, {CalServEP→;CalServEP←}]{CalServEP:; CalServEP!:; userID}
	    lookupUserID{client$→;client$←}(String{client$→;client$←} userID)
	{
        String{client$→;client$←} userID__ = userID;
	    if (coreClient actsfor client$ && CalServEP equiv client$) {
	        return lookupUserIDRemote@coreClient(userID__);
	    }
	    return null;
	}
	

	public User[CalServEP, {CalServEP→;CalServEP←}]{CalServEP:; CalServEP!:; userID_} 
	    lookupUserIDRemote{CalServEP:; CalServEP!:;client$→;client$←}(String{client$→;client$←} userID_) : {client$→;client$←}
	{
		User[CalServEP, {CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:}[] users = this.users;
		if (users == null || userID_ == null) return null;
		for (int i = 0; i < users.length; i++) {
			try {
				User[CalServEP, {CalServEP:;CalServEP!:}] u = users[i];
				if (u != null && userID_.equals(u.getUserID())) {
					return u;
				}
			}
			catch (ArrayIndexOutOfBoundsException imposs) { }
		}
		return null;
	}
	
	public Event[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} 
	retrieveEvent{CalServEP:;CalServEP!:}(int{CalServEP:;CalServEP!:} eventID) 
	where caller(CalServEP) {
	    if(coreClient actsfor client$ && CalServEP equiv client$) {
	        return retrieveEventRemote@coreClient(eventID);
	    } else {
	        return null;
	    }
	    
	}
	

	public Event[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} 
	retrieveEventRemote{CalServEP:;CalServEP!:}(int{CalServEP:;CalServEP!:} eventID) : {client$→;client$←}
	    where caller(CalServEP)
	{
		Set[{CalServEP:;CalServEP!:}] es = this.events;
		if (es != null) {
			for (Iterator[{CalServEP:;CalServEP!:}] iter = es.iterator();
			iter!=null && iter.hasNext(); ) {
				Event e = null;
				try {
					e = (Event)iter.next();
				}
				catch (NoSuchElementException impossible) { }
				catch (ClassCastException impossible) { }
				final Event event = e;

				if(event != null && event.uid != null) {
					if(event.uid.uid == eventID) return event;
				}
			}
		}
		return null;
	}

	public boolean updateEvent{CalServEP:;CalServEP!:}(
	    Event[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} newEvent)
	    where caller(CalServEP)
	{
		Set[{CalServEP:;CalServEP!:}] es = this.events;
		if (es != null) {
			try {
				atomic {
					// remove any old copies...
					es.remove(newEvent);

					// add the new/modified event
					es.add(newEvent);
				}
			}
			catch (ClassCastException impossible) { }
			catch (IllegalArgumentException impossible) { }
		}
		return true;
	}
	
	public jif.util.List[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:}
	eventSubset{CalServEP:;CalServEP!:}(
			Date[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} start, 
			Date[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} end,
			User[CalServEP, {CalServEP→;CalServEP←}]{CalServEP:;CalServEP!:} displayUser)
			where authority(CalRootEP), authority(CalServEP) {
	    if(coreClient actsfor client$ && CalServEP equiv client$) {
	        return eventSubsetRemote@coreClient(start, end, displayUser);
	    } else {
	        return null;
	    }
	}
	
	
	/**
	 * Get the subset of events that start on or after dt, and before end, 
	 * for which user is either an attendee, or created the event. (i.e.,
	 * if the info label is readable by user).
	 */
	public jif.util.List[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:}
	eventSubsetRemote{CalServEP:;CalServEP!:}(
			Date[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} start, 
			Date[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} end,
			User[CalServEP, {CalServEP→;CalServEP←}]{CalServEP:;CalServEP!:} displayUser) : {client$→;client$←}
			where authority(CalRootEP), authority(CalServEP) {

		Set[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} es = this.events;
		final jif.util.List[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:} sub = new jif.util.LinkedList[{CalServEP:;CalServEP!:}]();
		if (es != null) {

			for (Iterator[{CalServEP:;CalServEP!:}] iter = es.iterator();
			iter!=null && iter.hasNext(); ) {
				Event{CalServEP:;CalServEP!:} e = null;
				try {
					e = (Event)iter.next();
				}
				catch (NoSuchElementException impossible) { }
				catch (ClassCastException impossible) { }
				final Event{CalServEP:;CalServEP!:} event = e;

				atomic {
					if (event != null) {
						if (event.timeLbl <= new label {CalRootEP:; CalServEP!:}) {
							// should always be true!
							Date[{CalRootEP:; CalServEP!:}]{CalServEP:;CalServEP!:} eventStartR = event.startTime;
							Date[{CalServEP:; CalServEP!:}]{CalServEP:;CalServEP!:;CalRootEP:} eventStart = null;

							if (eventStartR != null) {
								try {
									eventStart = new Date[{CalServEP:;CalServEP!:}](
											eventStartR.getYear(),
											eventStartR.getMonth(),
											eventStartR.getDay());
								}
								catch (IllegalArgumentException impossible) {}
							}
							if ((start == null || !start.after(eventStart)) && 
									(end == null || end.after(eventStart))) {
								// is the event on user's calendar?
								boolean{CalServEP:;CalServEP!:} readable = false;
								try {
									readable = LabelUtil.isReadableBy(
											event.infoLbl, displayUser);
								} catch (NullPointerException imposs) {}
								if (readable) {
									// add event to the return subset.
									transferEvent(sub, event);
								}
							}                    
						}
					}
				}
			}
		}
		return sub;
	}

	String escapeString(String s) {
        if (s == null) return null;
        return s.replaceAll("'", "''");
	}

	private void 
	transferEvent{CalServEP:;CalRootEP:}(
			List[{CalServEP:;CalServEP!:}]{CalServEP:;CalServEP!:;CalRootEP:} c, 
			Event[{CalServEP:;CalRootEP:}]{CalServEP:;CalRootEP:} e_) 
			where caller(CalServEP,CalRootEP),
			endorse({CalServEP:;CalRootEP:; CalServEP!: meet CalRootEP!:}) {

		declassify({CalServEP:;CalRootEP:; CalServEP!: meet CalRootEP!:} to {CalServEP:;CalServEP!: meet CalRootEP!:}) {
			Event e = CalServDeclassifier.transferEvent(CalRootEP, CalServEP, e_);
			List[{CalServEP:;CalServEP!:}] c1 = endorse(c, {CalServEP:;CalRootEP:} to {CalServEP:;CalRootEP:;CalServEP!: meet CalRootEP!:});
			List[{CalServEP:;CalServEP!:}] c2 = declassify(c1, {CalServEP:;CalRootEP:;CalServEP!: meet CalRootEP!:} to {CalServEP:;CalServEP!: meet CalRootEP!:});
			try {
				c2.add(e);
			}
			catch (ClassCastException impossible) { }
			catch (IllegalArgumentException impossible) { }
			catch (NullPointerException ignore) { }
		}
	}

	boolean{p:; p!:} compareDates{p:; p!:}(
			principal{p:; p!:} p,
			Date[{CalRootEP:; p!:}]{p:; p!:} c,
			Date[{CalRootEP:; p!:}]{p:; p!:} d) 
			where caller(p),
			authority(CalRootEP),
			endorse({p:; CalRootEP!:}),
			CalRootEP actsfor p {
		boolean ret0 =  (c != null && c.before(d));
		boolean ret1 = endorse(ret0, {CalRootEP:; p!:} to {CalRootEP:; CalRootEP!:});
		boolean ret = declassify(ret1, {CalRootEP:; CalRootEP!:} to {p:; CalRootEP!:});
		return ret;
	}

}