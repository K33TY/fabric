package userserv;

/**
 * Represents a user, as would be found in a database. 
 */
public class User[principal servP, covariant label T] extends AbstractPrincipal implements JifObject[{servP:;servP!:}] {
    public User(String{T} name, 
                String{T} password, 
                String{servP:;servP!:} firstName, 
                String{servP:;servP!:} lastName) where authority (this) {
        this.password = password;
        this.remote1 = new User$1[servP](firstName, lastName);
        super(name);        
    }

    private final User$1[servP]{T} remote1;
    private final String{T} password; // XXX should be a secure hash of it 
    
    User(User$1{T} remote1, String{T} password) {
    	this.remote1 = remote1;
    	this.password = password;
    }

    public String{T} getPassword() {
        return this.password;
    }
    public String{servP:;servP!:} getFirstName() {
    	if(remote1 == null) return null;
        return remote1.firstName;
    }

    public String{servP:;servP!:} getLastName() {
    	if(remote1 == null) return null;
        return remote1.lastName;
    }

    public String{servP:;servP!: ; T} getRepresentation() {
        return this.displayString() + " <" + this.name() + ">";
    }

    public boolean{authPrf; closure; lb; executeNow; *lb; T} isAuthorized(Object authPrf, 
                                                            Closure[this, lb] closure,
                                                            label lb,
                                                            boolean executeNow) where authority (this) {
        if (closure instanceof LoginClosure[servP, this] && authPrf instanceof String) {
            String passwd = (String)authPrf;
            String myPass = this.password;
            
            if (myPass == passwd || (myPass != null && myPass.equals(passwd))) {
                // password supplied agrees with this password!
                return true;
            }
        }
        return false;
    }


    public String getUserID() {
        return this.name();
    }

    public String{servP:;servP!:} toString() {
        return this.name();
    }

    public String{servP:;servP!:} displayString() {
        return this.getFirstName()+" "+this.getLastName();
    }

    public int{servP:;servP!:} hashCode() {
        String s = this.name();
        return s==null?0:s.hashCode();
    }

    public boolean{servP:;servP!:;o} equals(IDComparable[{servP:;servP!:}] o) {
        return equals(new label {servP:;servP!:}, o);
    }
    public boolean{servP:;servP!:;o;lbl;*lbl} equals(label lbl, IDComparable[lbl] o) {
        Object obj = o;
        return equals(obj);
    }
    
    public static User[servP,{P←}]{P←} declassifyUser{P←}(principal{P←} P, User[servP,{P→;P←}]{P←} user) 
    where caller(P) {
    	final User$1[servP]{P←} nremote1 = declassify(user.remote1, {P→;P←} to {P←});
    	final String{P←} npassword = declassify(user.password, {P→;P←} to {P←});
    	return new User[servP,{P←}](nremote1, npassword);
    	
    }
}
