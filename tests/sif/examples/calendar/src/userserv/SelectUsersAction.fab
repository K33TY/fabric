package userserv;

import jif.util.*;

import javax.servlet.ServletException;

import sif.servlet.*;
import sif.html.*;

/**
 * Action to select one or more users. The action can be instantiated in
 * either "select single user" mode, or "select user list" mode. The action
 * can be instantiated with a specific message to display, and with a mutable List
 * of Users, in which the selected user(s) will be returned.
 */
public class SelectUsersAction[principal servP, covariant label T] extends USessAction[servP, T] authority(servP) {
    /**
     * Are we selecting a single user, or multiple users?
     */
    final boolean{T} singleMode;    

    /**
     * The label of the input level
     */
    final label{T} inputLbl;
    
    final SelectUsersAction$1[inputLbl, servP]{T} remote1;

    
    final User[servP]{T} currentUser;
    
    /**
     * The message to display when selecting users.
     */
    private final String{T} message;
    
    /**
     * Action to invoke upon the sucessful selection of user(s).
     */
    final UAction[servP]{T} successAction;
    /**
     * Action to invoke upon the cancelation of user selection.
     */
    final UAction[servP]{T} cancelAction;
    
    /**
     * Input used to store the user(s) entered by the logged-in user.
     */
    final Input[servP]{T} inpUsers;
    
    public SelectUsersAction{currentUser→;currentUser←}(boolean{T} singleMode,
            UServlet[servP]{T} servlet, 
            principal{T} session,
            User[servP]{T} currentUser,
            UAction[servP]{T} successAction, 
            UAction[servP]{T} cancelAction, 
            List[{servP→;servP←}]{currentUser→;currentUser←} selectedUsers, 
            String{T} message) where caller (servP)
    {
        this(singleMode, servlet, session, currentUser, successAction, cancelAction, selectedUsers, message, new label {currentUser→;currentUser←});
    }
    public SelectUsersAction{*inpLbl}(boolean{T} singleMode,
                             UServlet[servP]{T} servlet, 
                             principal{T} session,
                             User[servP]{T} currentUser,
                             UAction[servP]{T} successAction, 
                             UAction[servP]{T} cancelAction, 
                             List[{servP→;servP←}]{*inpLbl} selectedUsers, 
                             String{T} message,
                             label{T} inpLbl)
    where inpLbl <= {currentUser→;currentUser←}
    {
        this.successAction = successAction;
        this.cancelAction = cancelAction;
        this.singleMode = singleMode;
        this.currentUser = currentUser;
        this.inpUsers = new Input[servP](servlet, inpLbl);
        this.inputLbl = inpLbl;
        String mes = message;
        if (mes == null) {
            if (singleMode) {
                mes = "Please select a user.";                
            }
            else {
                mes = "Please select users.";                                
            }
        }
        else {
            mes = message;
        }      
        this.message = mes;
        this.remote1 = new SelectUsersAction$1[inputLbl, servP](selectedUsers);
        super(servlet, session);
    }
    
    public void invokeSessImpl{*lbl;session←}(label{*lbl;session←} lbl,
            Request[servP]{*lbl;session←} req,
            UServlet[servP]{*lbl;session←} servlet,
            USessState[servP]{*lbl;session←} state,
            User[servP]{*lbl;session←} currentUser) 
    throws (ServletException{*lbl;session←})
        where session equiv req.session, 
              session equiv state.sessionPrincipal,
              session actsfor currentUser,
              lbl <= {*→req.session},
              caller(session)
    {
    	if(req == null) throw new ServletException("invalid args");
    	if(T <= new label {*lbl;req.session←}) {
        if (req == null || servlet == null || state == null) 
            throw new ServletException("invalid args");
        	final Input[servP]{*lbl;req.session←} inpUsers = this.inpUsers;
        	final label{*lbl;req.session←} inputLbl = this.inputLbl;

        	if (inpUsers != null && new label {*lbl; req.session←} <= inpUsers.inputLbl && 
        			inpUsers.inputLbl <= new label {⊤→req.session} && new label {currentUser←} <= inpUsers.inputLbl &&
        			inpUsers.inputLbl equiv inputLbl && 
        			inputLbl <= new label {currentUser→;currentUser←} && 
//        			currentUser equiv this.currentUser &&
        			state.sessionPrincipal equiv req.session) {
        		producePage(new label {*lbl; session←}, req, servlet, state, null, inpUsers, inputLbl, currentUser);
        	}
        	else {
        		String lblString = null;
        		try {
        			lblString = LabelUtil.singleton().toString(lbl);
        		}
        		catch (NullPointerException imposs) { }            
        		throw new ServletException("SelectUsersAction.invokeSessImpl: lbl was unexpectedly high: " + lblString);
        	}
    	}
    }

    /**
     * Produce the select users page, with error messages if needed. The 
     * argument bnd allows this method to be called from a couple of different
     * places, with different behaviour.
     * 
     */
    protected void producePage{*bnd}(label{*bnd} bnd, Request[servP]{*bnd} req,
            UServlet[servP]{*bnd} servlet,
            USessState[servP]{*bnd} state,
            String{*bnd} errMessage,
            Input[servP]{*bnd} inpUsers,
            label{*bnd} inputLbl,
            User[servP]{*bnd} currentUser) 
      where req.session equiv state.sessionPrincipal,
            req.session equiv session,
            session actsfor currentUser,
            {*bnd} <= {*inpUsers.inputLbl},
            {session←} <= {*bnd},
            {currentUser←} <= {*inpUsers.inputLbl},
            {*inpUsers.inputLbl} equiv {*inputLbl},
            {*inputLbl} <= {currentUser→;currentUser←},
            caller(session),
            authority(servP)
    {
        if(T equiv bnd) {
        if(this.inpUsers == null) return;
        if(this.inputLbl equiv inputLbl && this.inpUsers.inputLbl equiv inputLbl) {

        String title = "Select User" + (singleMode?"":"s");
        Node[bnd, bnd] banner = createBanner(bnd, title);

        NodeList[bnd,bnd] blurb = new NodeList[bnd,bnd](bnd, bnd, new Paragraph[bnd, bnd](message));
        if (!singleMode) {
            blurb = blurb.append(bnd, bnd, new Paragraph[bnd, bnd]("Enter each user id on a separate line."));     
        }
        Node[bnd, inputLbl] instructions = desc(bnd,inputLbl, singleMode ? "Select user" : "Select users");

        if (req == null || servlet == null || state == null || inpUsers == null) 
            return; // throw new ServletException("invalid args");
                    
        NodeList[inpUsers.inputLbl, inpUsers.inputLbl] entries = new NodeList[inpUsers.inputLbl, inpUsers.inputLbl](bnd, inpUsers.inputLbl, instructions);
        

        String defaultUsers = defaultUsers(bnd, req, currentUser);
        InputNode[servP, inpUsers.inputLbl, inpUsers.inputLbl] inp;
        if (singleMode) {
            inp = new TextInput[servP, inpUsers.inputLbl, inpUsers.inputLbl](inpUsers, 40, defaultUsers);
        }
        else {
            inp = new TextArea[servP, inpUsers.inputLbl, inpUsers.inputLbl](inpUsers, 3, 40, defaultUsers);
        }
        entries = entries==null?null:
            entries.append(inpNode(inpUsers.inputLbl, inp, inpUsers.inputLbl, errMessage));
        
        Node[bnd,inpUsers.inputLbl] buttonRow = new NodeList[bnd,inpUsers.inputLbl](bnd, inpUsers.inputLbl, new SubmitButton[servP, bnd, inpUsers.inputLbl](servlet, inpUsers.inputLbl, "OK"),
                                                  new NBSP[bnd, inpUsers.inputLbl](),
                                                  new Hyperlink[servP, bnd, inpUsers.inputLbl](cancelAction, "Cancel")); 
        entries = entries==null?null:entries.append(bnd, inpUsers.inputLbl, new TRow[bnd, inpUsers.inputLbl](new TCell[bnd, inpUsers.inputLbl](null, buttonRow, 2, false)));
        Node[inpUsers.inputLbl,inpUsers.inputLbl] content = servlet.createForm(inpUsers.inputLbl, inpUsers.inputLbl, new FinishSelectUsers[servP, T](servlet, session, this),
                                                                 inpUsers.inputLbl, inpUsers.inputLbl, new Table[inpUsers.inputLbl, inpUsers.inputLbl](entries)); 
        servlet.createPage(req, title, inpUsers.inputLbl, bnd, 
                           new NodeList[inpUsers.inputLbl, bnd](bnd,bnd, 
                                   banner, inpUsers.inputLbl, bnd,createBody(inpUsers.inputLbl, bnd, 
                                                      new NodeList[inpUsers.inputLbl, bnd](bnd,bnd, blurb, inpUsers.inputLbl, inpUsers.inputLbl, content))));
        }
        }
        	
    }

    /**
     * Produce the default value for the users field. If there is
     * a value stored in the request, under the input this.inpUsers, that
     * value is used; otherwise, a string is produced from the list of Users, 
     * this.selectedUsers.
     */
    String{*lbl; *inpUsers.inputLbl; *←session; T} defaultUsers{*lbl}(label{*lbl} lbl, Request[servP]{*lbl} req, User[servP]{*lbl} currentUser) 
            where authority(servP), 
                  req.session actsfor currentUser, 
                  req.session equiv this.session, 
                  {*lbl} <= {currentUser→;currentUser←},
                  {*this.inputLbl} <= {currentUser→;currentUser←},
                  {*inpUsers.inputLbl} equiv {*this.inputLbl},
                  {currentUser←} <= inpUsers.inputLbl,
                  caller(this.session)
    {
        String defaultUsers = null;
        if(T <= new label {currentUser→;currentUser←}) {
        if (req != null && inpUsers != null && this.remote1 != null) {
            String users = req.getParam(inpUsers);
            if (users != null) {
                defaultUsers = users;
            }
            else {               
                defaultUsers = declassUserListStringToString(currentUser, inpUsers.inputLbl, userListToString(currentUser, this.remote1.selectedUsers, false));                
            }
        }
        }
        return defaultUsers;        
    }
    
    private String{servP→;servP←;p→;p←} userListToString{p→;p←}(principal{users} p, 
                                                               List[{servP→;servP←}]{p→;p←} users, 
                                                               boolean{users} useDisplayString) {
        String sb = "";
        if (users != null) {
            int i = 0;
            while (i < users.size()) {
                try {
                    User[servP] u = (User[servP])users.get(i);
                    if (u != null) {
                        if (useDisplayString) {
                            sb += u.displayString();
                        }
                        else {
                            sb += u.name();                          
                        }
                    }
                    if (i < users.size()) {
                        sb += "\n";                
                    }
                }
                catch (IndexOutOfBoundsException impossible) { }
                catch (ClassCastException impossible) { }
                
                i++;
            }
        }
        return sb;
    }
    
    // DOWNGRADE REASON: transfer ownership from servP. servP needs to be prepared to give the ownership away, hence the autoendorse. &&& access control
    private String{*lbl} declassUserListStringToString{p→;p←}(principal{s} p, label lbl, String{servP→;servP←;p→;p←} s)
    where lbl <= {p→;p←}, {p←} <= lbl, caller (servP, p), endorse({p→;p← meet servP←}) {
        String s1 = endorse(s, {servP→;servP←;p→;p←} to {servP→;p→;servP← meet p←});
        String s2 = declassify(s1, {servP→;p→;servP← meet p←} to {servP← meet p←});
        return s2;    
    }
    
    
    
    /**
     * Utility method to produce a TCell with class "desc" that wraps around the
     * text txt.
     */
    private static Node[lbl,E] desc{*lbl meet *E}(label{*lbl meet *E} lbl, label{*lbl meet *E} E, String{*lbl} txt) {
        return new TCell[lbl,E]("desc", lbl, E, new Text[lbl,E](txt));
    }
    
    /**
     * Utility method that returns either a TCell containing the InputNode
     * inp, or (if there is an error message, i.e., errMessage is not null)
     * a NodeList containind two TCells, one with inp, the other with 
     * errMessage.
     */
    private static Node[lbl, bnd] inpNode{*bnd}(label{*bnd} lbl, 
                                     InputNode[servP, lbl, bnd]{*bnd} inp,
                                     label{*bnd} bnd,       
                                     String{*bnd} errMessage) where bnd <= lbl {
        TCell[lbl,bnd] cell = new TCell[lbl,bnd](lbl, bnd, inp);
        
        if (errMessage == null) {
            return cell;
        }
        // There is an error for this input
        TCell[bnd,bnd] err = new TCell[bnd,bnd]("error", bnd, bnd, new Text[bnd,bnd](errMessage));
        return new NodeList[lbl,bnd](lbl, bnd, cell, bnd, bnd, err);
    }
}

/**
 * Action that is invoked when the user submits the selected user(s). The
 * submitted users are validated, and depending on the result, the session
 * is either directed back to the SelectUsers action (to fix errors)
 * or the list selectedUsers in the SelectUsersAction is updated, and the
 * session directed to the success action.
 */
class FinishSelectUsers[principal servP, covariant label T] extends USessAction[servP, T] authority(servP) {
    /**
     * The SelectUsersAction that created this Action.
     */
    private final SelectUsersAction[servP, T]{T} selectUsersAction;

    public FinishSelectUsers(UServlet[servP]{T} s, 
                             principal{T} session, 
                             SelectUsersAction[servP, T]{T} selectUsersAction) {
        this.selectUsersAction = selectUsersAction;
        super(s, session);
    }

        
    public void invokeSessImpl{*lbl;session←}(label{*lbl;session←} lbl,
            Request[servP]{*lbl;session←} req,
            UServlet[servP]{*lbl;session←} servlet,
            USessState[servP]{*lbl;session←} state,
            User[servP]{*lbl;session←} currentUser) 
    throws (ServletException{*lbl;session←})
        where session equiv req.session, 
              session equiv state.sessionPrincipal,
              session actsfor currentUser,              
              lbl <= {*→req.session},
              caller(session)
    {
    	if(T equiv lbl) {
        if (req == null || servlet == null || state == null) 
            throw new ServletException("invalid args");

        final SelectUsersAction[servP, {*lbl;req.session←}]{*lbl;req.session←} selectUsersAction = this.selectUsersAction;
        if(selectUsersAction == null) return;
        final Input[servP]{*lbl;req.session←} inpUsers = selectUsersAction.inpUsers; 

        if (selectUsersAction == null || inpUsers == null) 
            throw new ServletException("selectUsersAction is null!");
        
        if (req.session equiv selectUsersAction.session && currentUser equiv selectUsersAction.currentUser &&
        		req.session equiv state.sessionPrincipal && inpUsers.inputLbl equiv selectUsersAction.inputLbl &&
                selectUsersAction.inputLbl <= new label {currentUser→;currentUser←} &&
                lbl equiv selectUsersAction.inputLbl) {
        		this.submit(lbl, req, servlet, state, currentUser, selectUsersAction);
        }
        else {
            String lblString = null;
            try {
                lblString = LabelUtil.singleton().toString(lbl);
            }
            catch (NullPointerException imposs) { }            
            throw new ServletException("FinishSelectUsers.invokeSessImpl: lbl is too high: " + lblString);
        }
    	}
    }

    /**
     * Process the submitted list of users.
     */
    protected void submit{*lbl;session←}(label{*lbl;session←} lbl,
            Request[servP]{*lbl;session←} req,
            UServlet[servP]{*lbl;session←} servlet,
            USessState[servP]{*lbl;session←} state,
            User[servP]{*lbl;session←} currentUser,
            SelectUsersAction[servP, {*lbl;session←}]{*lbl;session←} selectUsersAction)
    throws (ServletException{*lbl;session←})
        where session equiv req.session, 
              session equiv state.sessionPrincipal,
              session actsfor currentUser,              
              currentUser equiv selectUsersAction.currentUser,
              selectUsersAction.session equiv req.session,
              lbl <= {*→req.session},
              {*selectUsersAction.inputLbl} <= {currentUser→;currentUser←},
              {*lbl} equiv {*selectUsersAction.inputLbl},
              {*selectUsersAction.inpUsers.inputLbl} equiv {*selectUsersAction.inputLbl},
              caller(session),
              authority(servP)
      {
          if(T equiv lbl) {
          List[{servP→;servP←}] validatedUsers = new ArrayList[new label {servP→;servP←}]();
          
          if (req == null || servlet == null || state == null) 
              throw new ServletException("invalid args");
          
          if (selectUsersAction == null) throw new ServletException("selectUsersAction is null!");
          if (selectUsersAction.successAction == null) throw new ServletException("selectUsersAction.successAction is null!");
          if (selectUsersAction.inpUsers == null) throw new ServletException("selectUsersAction.successAction is null!");
          if (selectUsersAction.remote1 == null) throw new ServletException("selectUsersAction.successAction is null!");
          
          // user has finished editing.
          // validate data
          final label bnd = new label {*lbl;*selectUsersAction.inpUsers.inputLbl;session←};
          
          String errMessage = null;
          ServletException{*lbl;session←} ex = null;

          // get the list of user ids              
          String input = req.getParam(selectUsersAction.inpUsers);
          String{*bnd}[] names = splitInput(bnd, input);
          
          // validate the list of user ids
          if (selectUsersAction.singleMode && (names == null || names.length != 1)) {
              errMessage = "Please enter a user id.";                
          }
          else {
              String errMsg = "";
              for (int i = 0; names != null && i < names.length; i++) {
                  try {
                      String userID = names[i];
                      User[servP] u = servlet.lookupUserID(userID, currentUser); 
                      if (u == null) {
                          errMsg += userID + " is not a valid user id. ";
                      }
                      else {
                          addToUserList(currentUser, validatedUsers, u);
                      }
                  }
                  catch (ArrayIndexOutOfBoundsException impossible) { }
              } 
              if (errMsg.length() > 0) {
                  errMessage = errMsg;
              }
          }          

          String em = declassErrMessage(errMessage, lbl, currentUser, selectUsersAction);
          if (em != null) {
        	  if(T <= bnd) {
        		  final Input[servP]{*bnd} inpUsers = selectUsersAction.inpUsers;
        		  final label{*bnd} inputLbl = inpUsers.inputLbl;
              // send user back to page as the data is not validated
              if (bnd <= selectUsersAction.inpUsers.inputLbl && selectUsersAction.inpUsers.inputLbl <= new label {currentUser→;currentUser←} && 
                      new label {currentUser←} <= selectUsersAction.inpUsers.inputLbl && selectUsersAction.session equiv req.session) 
                              selectUsersAction.producePage(bnd, req, servlet, state, em, inpUsers, inputLbl, currentUser);            
        	  }
          }
          else {
              // list is valid, so store the users into the user list
              copyUserList(currentUser, validatedUsers, selectUsersAction.remote1.selectedUsers);
              
              // send user back to return action.
              try {
                  selectUsersAction.successAction.invokeImpl(new label{*lbl; session←}, req, servlet, state);
              }
              catch (ServletException e) {
                  ex = e;
              }
          }
          if (ex != null) throw ex;
          }
      }   
    
      // DOWNGRADE REASON: downgrade the error message to *lbl;session←. i.e., the session user is prepared to
      // endorse whether there were errors, and the current user is prepared to declassify the result (possibly down to public). &&& imprecision
      private String{*lbl;session←} declassErrMessage{currentUser→;currentUser←}(String{currentUser→;currentUser←} errMess,
                                                       label{*lbl;session←} lbl,
                                                       User[servP]{*lbl;session←} currentUser,
                                                       SelectUsersAction[servP, {*lbl;session←}]{*lbl;session←} selectUsersAction) 
        where session actsfor currentUser,              
              currentUser equiv selectUsersAction.currentUser,              
              lbl <= {currentUser→;currentUser←},
              caller(session),
              authority(servP),
              endorse({currentUser→;session←})
      {
          String em1 = endorse(errMess, {currentUser→;currentUser←} to {*lbl;currentUser→;session←});
          String em2 = declassify(em1, {*lbl;currentUser→;session←} to {*lbl;session←});
          return em2;
      }
    
      // DOWNGRADE REASON: transfer ownership from currentUser to servP, and hide side effcts &&& access control
      private void addToUserList{currentUser→;currentUser←}(User[servP]{currentUser→;currentUser←} currentUser,
                                 List[{servP→;servP←}]{currentUser→;currentUser←} userList, 
                                 User[servP]{currentUser→;currentUser←} u) 
                           where caller(currentUser), 
                                 caller(servP),
                                 endorse({currentUser→;currentUser← meet servP←}) {
          declassify ({currentUser← meet servP←}) {
              User[servP] u1 = endorse(u, {currentUser→;servP→;currentUser←; servP←} to {currentUser→;servP→;currentUser← meet servP←});
              User[servP] u2 = declassify(u1, {servP→;currentUser→;currentUser← meet servP←} to {servP→;currentUser← meet servP←});
              
              List[{servP→;servP←}] ul1 = endorse(userList, {currentUser→;currentUser←;servP→;servP←} to {currentUser→;servP→;currentUser← meet servP←});
              List[{servP→;servP←}] ul2 = declassify(ul1, {servP→;currentUser→;currentUser← meet servP←} to {servP→;currentUser← meet servP←});
              
              try {
                  if (ul2 != null) 
                      ul2.add(u2);
              }
              catch (ClassCastException impossible) { }
              catch (IllegalArgumentException impossible) { }
              
          }
      }

      // DOWNGRADE REASON: transfer ownership from currentUser to servP, and hide side effcts of copying list      
      private void copyUserList{currentUser→;currentUser←}(User[servP]{currentUser→;currentUser←} currentUser,
              List[{servP→;servP←}]{currentUser→;currentUser←} source, 
              List[{servP→;servP←}]{currentUser→;currentUser←} target) 
              where caller(currentUser), 
                    caller(servP),
                    endorse({currentUser→;currentUser← meet servP←}) {          
          declassify ({currentUser← meet servP←}) {
              List[{servP→;servP←}] s1 = endorse(source, {currentUser→;currentUser←;servP→;servP←} to {currentUser→;servP→;currentUser← meet servP←});
              List[{servP→;servP←}] s2 = declassify(s1, {servP→;currentUser→;currentUser← meet servP←} to {servP→;currentUser← meet servP←});
              
              List[{servP→;servP←}] t1 = endorse(target, {currentUser→;currentUser←;servP→;servP←} to {currentUser→;servP→;currentUser← meet servP←});
              List[{servP→;servP←}] t2 = declassify(t1, {servP→;currentUser→;currentUser← meet servP←} to {servP→;currentUser← meet servP←});
              
              try {
                  if (s2 != null && t2 != null) {
                      t2.clear();
                      t2.addAll(s2);                      
                  }
              }
              catch (ClassCastException impossible) { }
              catch (IllegalArgumentException impossible) { }
              
          }
      }
      
      /**
       * Splits input into an array of strings, separating on '\n' or
       * '\r' characters.
       */
      private String{*lbl}[]{*lbl} splitInput{*lbl}(label{*lbl} lbl, String{*lbl} input) {
          if (input == null) return null;
          ArrayList[lbl] l = new ArrayList[lbl]();
          String s = "";
          for (int i = 0; i < input.length(); i++) {
              try {
                  char c = input.charAt(i);
                  if (c == '\n' || c == '\r') {
                      if (s.length() > 0) {
                          l.add(new JifString[lbl](s));
                      }
                      s = "";
                  }
                  else {
                      s += c;
                  }
              }
              catch (StringIndexOutOfBoundsException imposs) { }
          }
          if (s.length() > 0) {
              l.add(new JifString[lbl](s));
          }
          int size = l.size();
          String{*lbl}[] array = new String[size<0?0:size];
          int count = 0;
          for (Iterator[lbl] iter = l.iterator(); iter != null && iter.hasNext(); ) {
              try {
                  JifObject[lbl] jo = iter.next();
                  if (jo instanceof JifString[lbl]) {
                      JifString[lbl] js = (JifString[lbl])jo;
                      array[count++] = js.toString();
                  }
              }
              catch (NoSuchElementException impossible) { }
              catch (ArrayIndexOutOfBoundsException impossible) { }
          }
          return array;          
      }
}
