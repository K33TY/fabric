package jif.principals;

import fabric.util.Map;
import travel.Config;
import fabric.worker.Store;

import login.LoginClosure;

public class BankPrincipal extends ExternalPrincipal {

  // XXX Is the label for password good enough?    
  private final String{this→;this←} password;
  
  public BankPrincipal() {
    // XXX Is this kind of initialization secure?
    this.password  = "password";
    super("bank");
  }
  
  // XXX Can we label this method anywhich way we want, since it won't
  // be invoked from Fabric code??
  // XXX Where will the declassification w.r.t. password happen?
  public boolean{authPrf; closure; lb; executeNow; *lb; this; this→; this←}
  isAuthorized(java.lang.Object authPrf, 
          fabric.lang.security.Closure[this, lb] closure,
          label lb,
          boolean executeNow) where authority (this) 
  {
      if (closure instanceof LoginClosure[this] && authPrf instanceof String) {
          String passwd = (String)authPrf;
          String myPass = this.password;

          if (myPass == passwd || (myPass != null && myPass.equals(passwd))) {
              // password supplied agrees with this password!
              return true;
          }
      }
      return false;
  }
  
  
  public static BankPrincipal{*!:} getInstance{*!:}() {
    atomic {
      FabricWorker cl = FabricWorker.getWorker();
      if (cl != null) {
        final Store brokerStore = cl.getStore(Config.brokerStoreName);
        if (brokerStore != null) {
          Map rootMap = brokerStore.getRoot();
          if (rootMap != null) {
            Object obj = rootMap.get(Config.bankPrincipalMapKey);
            BankPrincipal bankPrincipal = null;
            if (obj instanceof BankPrincipal) {
              bankPrincipal = (BankPrincipal) obj;
            } else {
                bankPrincipal = new BankPrincipal@brokerStore();
                rootMap.put(Config.bankPrincipalMapKey, bankPrincipal);
            }
            
            return bankPrincipal;
          }
        }
      }
      
      return null;
    }
  }
  
  // Don't much care what store is, we're going to create it where we want
  public static BankPrincipal{*!:} getInstance{*!:}(Store store) {
      return getInstance();
  }
}
