package travel;

import fabric.util.Map;

public class Broker[principal bank, principal customer] extends AbstractPrincipal { // on broker worker (and store)
    final Account[bank]{this←} customerAcct;
    final Account[bank]{this←} airlineAcct;
    final principal{this←} airline;
    final Tickets[bank, airline, customer]{this←} custTickets;

    public void coordinatePurchase{}(
      float{BankPrincipal→AirlinePrincipal,CustomerPrincipal; CustomerPrincipal←; BankPrincipal←} amountArg) 
          : {bank->customerAcct.user; this←; bank<-; airline<-}
        throws PurchasingError
        where authority(this), endorse({this←}), this actsfor bank, this actsfor airline, 
        customerAcct.user equiv CustomerPrincipal,
        airlineAcct.user equiv AirlinePrincipal,        
        bank equiv BankPrincipal {
            // The broker trusts the value of the amount enough that it can influence the bank balance
        float amount = endorse(amountArg,
                {BankPrincipal→AirlinePrincipal,CustomerPrincipal; BankPrincipal←; CustomerPrincipal←} to
                {BankPrincipal→AirlinePrincipal,CustomerPrincipal; this←});
        
        try {
            final principal cust1 = customerAcct.user; // bank←
            final principal cust2 = customer;
            final principal airline_ = airlineAcct.user;

            FabricWorker cl = FabricWorker.getWorker();
            final RemoteWorker bankWorker = cl.getWorker(Config.bankCoreName);
            final RemoteWorker airlineWorker = cl.getWorker(Config.airlineCoreName);
            boolean success = false;
            if (bankWorker actsfor bank && airlineWorker actsfor airline) {
                success = true;
                atomic {
                    success = customerAcct.debit@bankWorker(amount) && success;   // @wBank
                    success = airlineAcct.credit@bankWorker(amount) && success;   // @wBank
                    success = incTickets@airlineWorker() && success;  // @wAirline
                }
            }

            if (!success) throw new PurchasingError();
        } catch (NullPointerException e) {
            throw new PurchasingError();
        }
    }

        // XXX why airline←
    public boolean{this←} incTickets{this←}() :{airline←} {
        if (custTickets != null && this actsfor airline) {
            custTickets.num_tickets++;
            return true;
        }
        return false;
    }

    Broker{this←}(Account[bank]{this←} ca,
            Account[bank]{this←} aa,
            Tickets[bank, airline_, customer]{this←} tick,
            principal{this←} airline_) {
        customerAcct = ca;
        airlineAcct = aa;
        custTickets = tick;
        airline = airline_;
        super("broker");
    }
}
