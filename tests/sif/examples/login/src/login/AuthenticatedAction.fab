package login;

import javax.servlet.ServletException;

import sif.servlet.*;
import sif.html.*;

/**
 * Extend this class to create actions that are protected by login requirement
 */
abstract public class AuthenticatedAction[principal servP] extends AbstractAction[servP] {
    public AuthenticatedAction(Servlet[servP] m) {
        super();
        initFields(m);
    }
    public AuthenticatedAction(String name, Servlet[servP] m) {
        super();
        initFields(name, m);
    }
    
    /**
     * Ensure that there is a logged in user. This method should be called first
     * in the invoke() method of any action that requires the user to be logged in.
     * 
     * @param req the Request
     * @return false if the user is not logged in, true otherwise.
     * @throws ServletException
     */
    static boolean{*lbl;req.session←} ensureLoggedIn{*lbl}
                                (label{*lbl} lbl,
                                 Request[servP]{*lbl} req,
                                 Action[servP]{*lbl} successAction)
    throws (ServletException{*lbl;req.session!:})
    where caller(req.session),
    lbl <= {*:req.session}
    {
        if (req == null) return false;
        ServletException{*lbl;req.session!:} ex = null;
        boolean{*lbl;req.session!:} ret = true;
        try {
            final AuthSessState[servP, lbl] state = (AuthSessState[servP, lbl])req.getSessionState();
            final LoginAction[servP] la = new LoginAction[servP](this, successAction, req.session);
            
            if (state != null && 
                    state.sessionPrincipal equiv la.session && 
                    req.session equiv la.session &&
                    state.currentUser() == null) {
                // not logged in yet.
                try {
                    la.invokeImpl(lbl, req, this, state, null);
                    ret = false;
                }
                catch (ServletException e) {
                    ex = e;
                }
            }
        }
        catch (ClassCastException impossible) {  }
        if (ex != null) throw ex;
        return ret;
    }
    
    public final void invoke{*lbl}(label{*lbl} lbl, Request[servP]{*lbl} req) 
    throws (ServletException{*lbl;*:req.session;req.session!:})
        where caller(req.session),
        lbl <= {*:req.session} {

        Servlet[servP] servlet = getServlet();
        SessionState state = req.getSessionState();
        if (req == null || servlet == null || state == null) throw new ServletException("Error processing request");        

        atomic {
            // Check if someone is logged in
            if (!ensureLoggedIn(lbl, req, this)) return;

            final label newLbl = new label {*lbl; req.session!:};
            SessionState ss = req.getSessionState();
            if (!(ss instanceof AuthSessState[servP, lbl])) throw new ServletException("Incorrect session state");
            final AuthSessState[servP, lbl] css = (AuthSessState[servP, lbl])ss;
            if (css == null) return;

            if (req.session equiv css.sessionPrincipal) {
                this.invokeImpl(newLbl, req, servlet, css, css.currentUser());
            }
            else {
                throw new ServletException("req.session not equivalent to state.sessionPrincipal"); 
            }
        }
    }
          
    public abstract void invokeImpl{*lbl}(label{*lbl} lbl,
                                      Request[servP]{*lbl} req,
                                      Servlet[servP]{*lbl} servlet,
                                      AuthSessState[servP, lbl]{*lbl} state,
                                      principal{*lbl} currentUser) 
        throws (ServletException{*lbl;req.session!:})
          where caller(req.session),
          lbl <= {⊤→req.session},
          req.session equiv state.sessionPrincipal,
          req.session actsfor currentUser;

}

