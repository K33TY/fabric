import fabric.util.LinkedList;
import fabric.util.List;
import java.io.IOException;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.Random;
import fabric.worker.transaction.TransactionManager;

public class Tester {
  public Tester() {
  }

  public Tester Tester$() {
    fabric$lang$Object$();
    return this;
  }

  private void printList(List a) {
    System.out.print("[");
    for (int i = 0; i < a.size(); i++) {
      System.out.print(" " + a.get(i) + " ");
    }
    System.out.print("]");
  }

  private List merge(int n, List a_orig, List b_orig) {
    Store s = Config.STORE;
    List merged = new LinkedList().fabric$util$LinkedList$();
    List a = new LinkedList().fabric$util$LinkedList$(a_orig);
    List b = new LinkedList().fabric$util$LinkedList$(b_orig);
    for (int i = 0; i < n; i++) {
      if (a.isEmpty() && b.isEmpty()) {
        break;
      } else if (a.isEmpty()
          || (!b.isEmpty()
            && (compare((TwooterAccount) a.get(0),
                        (TwooterAccount) b.get(0)) < 0))) {
        merged.add(b.get(0));
        b.remove(0);
      } else {
        merged.add(a.get(0));
        a.remove(0);
      }
    }
    return merged;
  }

  private memoized int compare(TwooterAccount a, TwooterAccount b) {
    int aCount = a.numFollowers();
    int bCount = b.numFollowers();
    if (aCount < bCount) return -1;
    if (aCount > bCount) return 1;
    return 0;
  }

  private memoized List topAccountsBetween(int n, int min, int max) {
    Store s = Config.STORE;
    List rtn = new LinkedList@s().fabric$util$LinkedList$(); 
    if (max - min <= n) {
      for (int i = min; i < max; i++) {
        TwooterAccount foo = (TwooterAccount) s.getRoot().get(new Integer(i));
        int j = 0;
        for (j = 0; j < rtn.size(); j++)
          if (((TwooterAccount) rtn.get(j)).numFollowers() < foo.numFollowers())
            break;
        rtn.add(j, foo);
      }
    } else if (max > min) {
      rtn.addAll(merge(n, topAccountsBetween(n, min, min + ((max - min) >> 1)),
            topAccountsBetween(n, min + ((max - min) >> 1), max)));
    }
    return rtn;
  }

  public List topAccounts(int n, int total) {
    return topAccountsBetween(n, 0, total);
  }

  public void worstCase(Random rand) {
    long id = rand.nextLong();
    Logger HOTOS_LOGGER = Logger.getLogger("HOTOS");
    HOTOS_LOGGER.log(Level.INFO, "===started {0} at " + System.currentTimeMillis() + " ===", String.valueOf(id));
    long transactionSeed = rand.nextLong();
    atomic {
      Random tranRand = new Random(transactionSeed);
      Config c = (Config) Config.STORE.getRoot().get("config");

      List top5 = topAccounts(5, c.NUM_USERS);
      TwooterAccount second = (TwooterAccount) top5.get(1);
      TwooterAccount first = (TwooterAccount) top5.get(0);
      int firstCount = first.numFollowers();
      int secondCount = second.numFollowers();
      for (int i = 0; i < (firstCount - secondCount); i++) {
        first.removeRandomFollower(tranRand);
        second.addRandomFollower(tranRand);
      }
    }
    Long commitTime = (Long) TransactionManager.COMMIT_TIME.get();
    HOTOS_LOGGER.log(Level.INFO, "===committed {0} {1} at {2} ===",
        new java.lang.Object native[] { String.valueOf(id), "W", commitTime });
  }

  public void randomOperation(Random rand, double writeRatio, int topCount) {
    long id = rand.nextLong();
    Logger HOTOS_LOGGER = Logger.getLogger("HOTOS");
    HOTOS_LOGGER.log(Level.INFO, "===started {0} at " + System.currentTimeMillis() + " ===", String.valueOf(id));
    long transactionSeed = rand.nextLong();
    boolean isWrite = false;
    atomic {
      Random tranRand = new Random(transactionSeed);
      Config c = (Config) Config.STORE.getRoot().get("config");
      double choice = tranRand.nextDouble();
      if (choice <= writeRatio) {
        isWrite = true;
        TwooterAccount.getRandomTwooterAccount(tranRand).randomlyUpdateFollowers(tranRand,
            id);
      } else {
        topAccounts(topCount, c.NUM_USERS);
      }
    }
    String transactionType = isWrite ? "W" : "R";
    Long commitTime = (Long) TransactionManager.COMMIT_TIME.get();
    HOTOS_LOGGER.log(Level.INFO, "===committed {0} {1} at {2} ===",
        new java.lang.Object native[] {
          String.valueOf(id),
          transactionType,
          commitTime
        });
  }
}
