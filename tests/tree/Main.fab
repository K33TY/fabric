package tree;

//import java.util.Random;
import fabric.client.AbortException;
import fabric.client.Core;
import fabric.util.Map;
import jif.runtime.Runtime;
import java.io.PrintStream;

public class Main {
	public final principal{*bot} pp = new jif.lang.ExternalPrincipal("localhost");
	public final label{*bot} lbl = new label {pp→;pp←};
	public static final label{*bot} bot = new label {⊥→⊥;⊤←⊤};

	public static void main{*bot}(String{*bot}[]{*bot} args) {
		if(args == null) return;
		Main m_ = null;
		atomic {
			m_ = new Main();
		}
		final Main m = m_;
		String{*m.lbl}[]{*m.lbl} argsCopy = null;
		atomic {
			argsCopy = new String[args.length];
		}

		try {
			for(int i = 0; i < args.length; i++) {
				argsCopy[i] = args[i];
			}
			m.begin(argsCopy);
		} catch (ArrayIndexOutOfBoundsException imposs) {}
		catch (AbortException e) { /* do nothing for now */ }
		catch (SecurityException e) { /* do nothing for now */ }
	}

	public void begin{*lbl}(String{*lbl}[]{*lbl} args)
	throws (AbortException{*lbl}, SecurityException{*lbl}) {
		Runtime[pp] runtime = null;
		atomic {
			runtime = Runtime[pp].getRuntime();
		}
		if(runtime == null || args == null) return;

		String arg = null;
		PrintStream[{pp→;⊥←⊥}] out = null;
		out = runtime.out();

		try {
			if (args.length != 1 || !args[0].equals("create") && !args[0].equals("read")) {
				out.println("Usage: tree.Main [create|read]");
				return;
			} else {
				arg = args[0];
			}
		} catch (ArrayIndexOutOfBoundsException imposs) {}
		catch (NullPointerException imposs) {}

		if(out == null || arg == null) return;
		try {
			Map root = (Map) client$.getCore("core1").getRoot();
			//    Random random = new Random();
			Tree[lbl] treeVar = null;
			if (arg.equals("create")) {
				atomic {
					Core treeCore = client$.getCore("core0");
					Core nodeCore = client$.getCore("core1");
					treeVar = new Tree[lbl]@treeCore(nodeCore);
					root.put("theTree", treeVar);
					for (int i = 0; i < 10; i++) {
						atomic {
							//            int toInsert = random.nextInt();
							//            tree.insertIterative(toInsert);
							treeVar.insertIterative(i);
						}
					}
				}
				return;
			}

			treeVar = (Tree[lbl]) root.get("theTree");

			int cycle = 0;
			while (true) {
				atomic {
					//        int toFind = random.nextInt();
					//        tree.lookup(toFind);

					treeVar.lookup(cycle);
				}

				if (++cycle % 100 == 0)
					out.println(cycle + " lookups done.");
			}
		} catch (NullPointerException unlikely) {}
		catch (ClassCastException unlikely) {}
	}
}