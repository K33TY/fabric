class Balance[principal bank, principal user]
{ // on bank store and worker
    int{bank←; bank→user} value = 0;

    int{bank←; bank→user} debit{bank←}(int{bank←; bank→user} amt) {
        if (amt <= value & value > 0 & amt > 0) {
            value -= amt;
        }
        return value;
    }
    int{bank←; bank→user} credit{bank←}(int{bank←; bank→user} amt) {
        if (amt > 0) {
            value += amt;
        }
        return value;
    }
}

class Account[principal bank]
{ // on bank store and worker
    final principal{bank←} user;
    final Balance[bank,user] {bank←} balance;

    Account(principal{bank←} user_) {
        user = user_;
        balance = new Balance(); // @ bank store
    }
    public int{bank←; bank→user} debit{bank←}(int{bank←; bank→user} amt) {
        try { balance.debit(amt); return balance.value; }
        catch (NullPointerException e) { return 0; }
    }
    public int{bank←; bank→user} credit{bank←}(int{bank←; bank→user} amt) {
        try { balance.credit(amt); return balance.value; }
        catch (NullPointerException e) { return 0; }
    }

}

class Tickets[principal bank, principal airline, principal user]
{ // on airline store and worker
    int {airline←bank; airline→user} num_tickets;
    Tickets{airline←}() {
        num_tickets = 0;
    }
}

class Broker[principal bank, principal customer] extends AbstractPrincipal
{ // on broker worker (and store)
    final Account[bank]{this←} customerAcct;
    final Account[bank]{this←} airlineAcct;
    final principal{this←} airline;
    final Tickets[bank, airline, customer]{this←} custTickets;
    
    // XXX These should not be hard-coded!
    final static String{⊤←} bankCore = "compute-0-2.local";
    final static String{⊤←} airlineCore = "compute-0-3.local";

    void coordinatePurchase{}()
        where authority(this), endorse({this←})
    {
      try {
        final principal cust1 = customerAcct.user; // bank←
        final principal cust2 = customer;
        final principal airline_ = airlineAcct.user;
        if (this actsfor bank
               & this actsfor airline
            // & this actsfor cust1
            // & this actsfor cust2
            // & this actsfor airline_
            // & bank actsfor airline // this is not acceptable. For debugging.
            )
        {
            FabricClient cl = FabricClient.getClient();
            final RemoteClient bankClient = cl.getClient(bankCore);
            final RemoteClient airlineClient = cl.getClient(airlineCore);
            if (bank equiv bankClient) {
                customerAcct.debit@bankClient(1000);   // @wBank
                airlineAcct.credit@bankClient(1000);   // @wBank
            }
            if (airline equiv airlineClient) {
                incTickets@airlineClient();  // @wAirline
            }
        }
      } catch (NullPointerException e) {}

    }
    
    public void incTickets{this←}() :{airline←} {
        if (custTickets != null && this actsfor airline) 
            custTickets.num_tickets++;
    }

    Broker{this←}(Account[bank]{this←} ca,
                  Account[bank]{this←} aa,
                  Tickets[bank, airline_, customer]{this←} tick,
                  principal{this←} airline_) {
        customerAcct = ca;
        airlineAcct = aa;
        custTickets = tick;
        airline = airline_;
        super("broker");
    }
}


class SimplePrincipal extends AbstractPrincipal {
    SimplePrincipal(String{*<-} name) { super(name); }
}
